{
  "repair_end": "2018-12-01 13:14:36.330729", 
  "repair_begin": "2018-12-01 12:30:02.258978", 
  "patches": [
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_754/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:04:10.968161721 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "continue;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 124, 
          "faulty": "return row;", 
          "type": "InsertBefore", 
          "seed": "incrementIterationsCounter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_244/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:58:37.865506073 -0500\n@@ -101,7 +101,6 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n@@ -117,13 +116,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Delete", 
          "seed": "while (!tableau.isOptimal()) {\n  doIteration(tableau);\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "doIteration(tableau);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1110/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:08:29.175118971 -0500\n@@ -101,7 +101,6 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n@@ -137,17 +136,6 @@\n             // This heuristic is based on empirical data gathered while investigating MATH-828.\n                 Integer minRow = null;\n                 int minIndex = tableau.getWidth();\n-                for (Integer row : minRatioPositions) {\n-                    int i = tableau.getNumObjectiveFunctions();\n-                    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n-                        if (row == tableau.getBasicRow(i)) {\n-                            if (i < minIndex) {\n-                                minIndex = i;\n-                                minRow = row;\n-                            }\n-                        }\n-                    }\n-                }\n                 return minRow;\n         }\n         return minRatioPositions.get(0);\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Delete", 
          "seed": "throw new NoFeasibleSolutionException();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 140, 
          "faulty": "for (Integer row : minRatioPositions) {\n  int i=tableau.getNumObjectiveFunctions();\n  for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n    if (row == tableau.getBasicRow(i)) {\n      if (i < minIndex) {\n        minIndex=i;\n        minRow=row;\n      }\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "doIteration(tableau);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_951/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:06:21.447630573 -0500\n@@ -115,17 +115,6 @@\n         } else if (minRatioPositions.size() > 1) {\n             // there's a degeneracy as indicated by a tie in the minimum ratio test\n \n-            // 1. check if there's an artificial variable that can be forced out of the basis\n-                for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n-                }\n-\n             // 2. apply Bland's rule to prevent cycling:\n             //    take the row for which the corresponding basic variable has the smallest index\n             //\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 122, 
          "faulty": "final double entry=tableau.getEntry(row,column);", 
          "type": "InsertBefore", 
          "seed": "setMaxIterations(DEFAULT_MAX_ITERATIONS);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 119, 
          "faulty": "for (Integer row : minRatioPositions) {\n  for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n    int column=i + tableau.getArtificialVariableOffset();\n    final double entry=tableau.getEntry(row,column);\n    if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n      return row;\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "if (minRatioPositions.size() == 0) {\n  return null;\n}\n else if (minRatioPositions.size() > 1) {\n  for (  Integer row : minRatioPositions) {\n    for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n      int column=i + tableau.getArtificialVariableOffset();\n      final double entry=tableau.getEntry(row,column);\n      if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n        return row;\n      }\n    }\n  }\n  Integer minRow=null;\n  int minIndex=tableau.getWidth();\n  for (  Integer row : minRatioPositions) {\n    int i=tableau.getNumObjectiveFunctions();\n    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n      if (row == tableau.getBasicRow(i)) {\n        if (i < minIndex) {\n          minIndex=i;\n          minRow=row;\n        }\n      }\n    }\n  }\n  return minRow;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_168/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:57:44.469711509 -0500\n@@ -101,7 +101,6 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Delete", 
          "seed": "if (!Precision.equals(entry,0d,maxUlps)) {\n  return null;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1117/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:08:32.451106047 -0500\n@@ -115,17 +115,6 @@\n         } else if (minRatioPositions.size() > 1) {\n             // there's a degeneracy as indicated by a tie in the minimum ratio test\n \n-            // 1. check if there's an artificial variable that can be forced out of the basis\n-                for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n-                }\n-\n             // 2. apply Bland's rule to prevent cycling:\n             //    take the row for which the corresponding basic variable has the smallest index\n             //\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java\t2018-12-01 06:29:45.303620234 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1117/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java\t2018-12-01 07:08:32.451106047 -0500\n@@ -83,6 +83,6 @@\n     /** {@inheritDoc} */\n     @Override\n     public String getLocalizedMessage() {\n-        return context.getLocalizedMessage();\n+        return context.getMessage();\n     }\n }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 119, 
          "faulty": "for (Integer row : minRatioPositions) {\n  for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n    int column=i + tableau.getArtificialVariableOffset();\n    final double entry=tableau.getEntry(row,column);\n    if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n      return row;\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "if (minRatioPositions.size() == 0) {\n  return null;\n}\n else if (minRatioPositions.size() > 1) {\n  for (  Integer row : minRatioPositions) {\n    for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n      int column=i + tableau.getArtificialVariableOffset();\n      final double entry=tableau.getEntry(row,column);\n      if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n        return row;\n      }\n    }\n  }\n  Integer minRow=null;\n  int minIndex=tableau.getWidth();\n  for (  Integer row : minRatioPositions) {\n    int i=tableau.getNumObjectiveFunctions();\n    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n      if (row == tableau.getBasicRow(i)) {\n        if (i < minIndex) {\n          minIndex=i;\n          minRow=row;\n        }\n      }\n    }\n  }\n  return minRow;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java", 
          "line": 86, 
          "faulty": "return context.getLocalizedMessage();", 
          "type": "Replace", 
          "seed": "return context.getMessage();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_665/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:03:05.548417295 -0500\n@@ -148,7 +148,6 @@\n                         }\n                     }\n                 }\n-                return minRow;\n         }\n         return minRatioPositions.get(0);\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 151, 
          "faulty": "return minRow;", 
          "type": "Delete", 
          "seed": "minRatioPositions=new ArrayList<Integer>();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_928/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:06:07.559687194 -0500\n@@ -115,16 +115,7 @@\n         } else if (minRatioPositions.size() > 1) {\n             // there's a degeneracy as indicated by a tie in the minimum ratio test\n \n-            // 1. check if there's an artificial variable that can be forced out of the basis\n-                for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n-                }\n+            setMaxIterations(DEFAULT_MAX_ITERATIONS);\n \n             // 2. apply Bland's rule to prevent cycling:\n             //    take the row for which the corresponding basic variable has the smallest index\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 06:29:45.307620212 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_928/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 07:06:07.559687194 -0500\n@@ -134,7 +134,7 @@\n      * @return the localized message.\n      */\n     public String getLocalizedMessage() {\n-        return getMessage(Locale.getDefault());\n+        return getMessage(Locale.US);\n     }\n \n     /**\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 119, 
          "faulty": "for (Integer row : minRatioPositions) {\n  for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n    int column=i + tableau.getArtificialVariableOffset();\n    final double entry=tableau.getEntry(row,column);\n    if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n      return row;\n    }\n  }\n}", 
          "type": "Replace", 
          "seed": "setMaxIterations(DEFAULT_MAX_ITERATIONS);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java", 
          "line": 137, 
          "faulty": "return getMessage(Locale.getDefault());", 
          "type": "Replace", 
          "seed": "return getMessage(Locale.US);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1290/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:10:17.158697421 -0500\n@@ -119,7 +119,7 @@\n                 for (Integer row : minRatioPositions) {\n                     for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                         int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n+                        final double entry = tableau.getEntry(i, col);\n                         if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n                             return row;\n                         }\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java\t2018-12-01 06:29:45.303620234 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1290/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java\t2018-12-01 07:10:17.162697405 -0500\n@@ -77,7 +77,7 @@\n     /** {@inheritDoc} */\n     @Override\n     public String getMessage() {\n-        return context.getMessage();\n+        return context.getLocalizedMessage();\n     }\n \n     /** {@inheritDoc} */\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 122, 
          "faulty": "final double entry=tableau.getEntry(row,column);", 
          "type": "Replace", 
          "seed": "final double entry=tableau.getEntry(i,col);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java", 
          "line": 80, 
          "faulty": "return context.getMessage();", 
          "type": "Replace", 
          "seed": "return context.getLocalizedMessage();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1186/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:09:12.014950659 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 06:29:45.307620212 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1186/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 07:09:12.018950643 -0500\n@@ -134,7 +134,7 @@\n      * @return the localized message.\n      */\n     public String getLocalizedMessage() {\n-        return getMessage(Locale.getDefault());\n+        return getMessage(Locale.US);\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java\t2018-12-01 06:29:45.303620234 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1186/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java\t2018-12-01 07:09:12.018950643 -0500\n@@ -83,6 +83,7 @@\n     /** {@inheritDoc} */\n     @Override\n     public String getLocalizedMessage() {\n-        return context.getLocalizedMessage();\n+        context.addMessage(LocalizedFormats.ARITHMETIC_EXCEPTION);\n+\t\treturn context.getLocalizedMessage();\n     }\n }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "continue;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java", 
          "line": 137, 
          "faulty": "return getMessage(Locale.getDefault());", 
          "type": "Replace", 
          "seed": "return getMessage(Locale.US);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java", 
          "line": 86, 
          "faulty": "return context.getLocalizedMessage();", 
          "type": "InsertBefore", 
          "seed": "context.addMessage(LocalizedFormats.ARITHMETIC_EXCEPTION);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_379/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:00:08.533129269 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java\t2018-12-01 06:29:45.303620234 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_379/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java\t2018-12-01 07:00:08.533129269 -0500\n@@ -83,6 +83,7 @@\n     /** {@inheritDoc} */\n     @Override\n     public String getLocalizedMessage() {\n-        return context.getLocalizedMessage();\n+        context.addMessage(LocalizedFormats.ARITHMETIC_EXCEPTION);\n+\t\treturn context.getLocalizedMessage();\n     }\n }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "continue;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java", 
          "line": 86, 
          "faulty": "return context.getLocalizedMessage();", 
          "type": "InsertBefore", 
          "seed": "context.addMessage(LocalizedFormats.ARITHMETIC_EXCEPTION);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1211/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:09:26.846892726 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java\t2018-12-01 06:29:45.303620234 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1211/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java\t2018-12-01 07:09:26.846892726 -0500\n@@ -77,7 +77,7 @@\n     /** {@inheritDoc} */\n     @Override\n     public String getMessage() {\n-        return context.getMessage();\n+        return context.getLocalizedMessage();\n     }\n \n     /** {@inheritDoc} */\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "incrementIterationsCounter();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java", 
          "line": 80, 
          "faulty": "return context.getMessage();", 
          "type": "Replace", 
          "seed": "return context.getLocalizedMessage();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_541/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:01:39.300760089 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "continue;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 124, 
          "faulty": "return row;", 
          "type": "Delete", 
          "seed": "incrementIterationsCounter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_133/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:57:19.741808236 -0500\n@@ -101,7 +101,6 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n@@ -115,17 +114,6 @@\n         } else if (minRatioPositions.size() > 1) {\n             // there's a degeneracy as indicated by a tie in the minimum ratio test\n \n-            // 1. check if there's an artificial variable that can be forced out of the basis\n-                for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n-                }\n-\n             // 2. apply Bland's rule to prevent cycling:\n             //    take the row for which the corresponding basic variable has the smallest index\n             //\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 119, 
          "faulty": "for (Integer row : minRatioPositions) {\n  for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n    int column=i + tableau.getArtificialVariableOffset();\n    final double entry=tableau.getEntry(row,column);\n    if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n      return row;\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "setMaxIterations(DEFAULT_MAX_ITERATIONS);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Delete", 
          "seed": "incrementIterationsCounter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_965/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:06:29.815596558 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 06:29:45.307620212 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_965/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 07:06:29.819596542 -0500\n@@ -134,7 +134,7 @@\n      * @return the localized message.\n      */\n     public String getLocalizedMessage() {\n-        return getMessage(Locale.getDefault());\n+        return getMessage(Locale.US);\n     }\n \n     /**\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "if (minRatioPositions.size() > 1) {\n  for (  Integer row : minRatioPositions) {\n    for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n      int column=i + tableau.getArtificialVariableOffset();\n      final double entry=tableau.getEntry(row,column);\n      if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n        return row;\n      }\n    }\n  }\n  Integer minRow=null;\n  int minIndex=tableau.getWidth();\n  for (  Integer row : minRatioPositions) {\n    int i=tableau.getNumObjectiveFunctions();\n    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n      if (row == tableau.getBasicRow(i)) {\n        if (i < minIndex) {\n          minIndex=i;\n          minRow=row;\n        }\n      }\n    }\n  }\n  return minRow;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java", 
          "line": 137, 
          "faulty": "return getMessage(Locale.getDefault());", 
          "type": "Replace", 
          "seed": "return getMessage(Locale.US);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 124, 
          "faulty": "return row;", 
          "type": "Delete", 
          "seed": "solvePhase1(tableau);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_581/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:02:00.204676340 -0500\n@@ -101,7 +101,6 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n@@ -120,9 +119,6 @@\n                     for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                         int column = i + tableau.getArtificialVariableOffset();\n                         final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n                     }\n                 }\n \n@@ -137,17 +133,6 @@\n             // This heuristic is based on empirical data gathered while investigating MATH-828.\n                 Integer minRow = null;\n                 int minIndex = tableau.getWidth();\n-                for (Integer row : minRatioPositions) {\n-                    int i = tableau.getNumObjectiveFunctions();\n-                    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n-                        if (row == tableau.getBasicRow(i)) {\n-                            if (i < minIndex) {\n-                                minIndex = i;\n-                                minRow = row;\n-                            }\n-                        }\n-                    }\n-                }\n                 return minRow;\n         }\n         return minRatioPositions.get(0);\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Delete", 
          "seed": "throw new NoFeasibleSolutionException();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 123, 
          "faulty": "if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n  return row;\n}", 
          "type": "Delete", 
          "seed": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 140, 
          "faulty": "for (Integer row : minRatioPositions) {\n  int i=tableau.getNumObjectiveFunctions();\n  for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n    if (row == tableau.getBasicRow(i)) {\n      if (i < minIndex) {\n        minIndex=i;\n        minRow=row;\n      }\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "if (!Precision.equals(tableau.getEntry(0,tableau.getRhsOffset()),0d,epsilon)) {\n  throw new NoFeasibleSolutionException();\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_276/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:58:54.597437504 -0500\n@@ -101,7 +101,6 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 06:29:45.307620212 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_276/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 06:58:54.597437504 -0500\n@@ -183,7 +183,8 @@\n             }\n         }\n \n-        return sb.toString();\n+        msgArguments = new ArrayList<Object[]>(len);\n+\t\treturn sb.toString();\n     }\n \n     /**\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Delete", 
          "seed": "setMaxIterations(DEFAULT_MAX_ITERATIONS);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java", 
          "line": 186, 
          "faulty": "return sb.toString();", 
          "type": "InsertBefore", 
          "seed": "msgArguments=new ArrayList<Object[]>(len);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_597/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:02:08.336643880 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/AbstractLinearOptimizer.java\t2018-12-01 06:29:45.579618752 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_597/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/AbstractLinearOptimizer.java\t2018-12-01 07:02:08.340643865 -0500\n@@ -125,7 +125,8 @@\n     protected void incrementIterationsCounter()\n         throws MaxCountExceededException {\n         if (++iterations > maxIterations) {\n-            throw new MaxCountExceededException(maxIterations);\n+            setMaxIterations(DEFAULT_MAX_ITERATIONS);\n+\t\t\tthrow new MaxCountExceededException(maxIterations);\n         }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/AbstractLinearOptimizer.java", 
          "line": 128, 
          "faulty": "throw new MaxCountExceededException(maxIterations);", 
          "type": "InsertBefore", 
          "seed": "setMaxIterations(DEFAULT_MAX_ITERATIONS);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "incrementIterationsCounter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_117/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:57:11.985838805 -0500\n@@ -101,7 +101,6 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n@@ -126,7 +125,36 @@\n                     }\n                 }\n \n-            // 2. apply Bland's rule to prevent cycling:\n+            if (minRatioPositions.size() == 0) {\n+\t\t\t\t\treturn null;\n+\t\t\t\t} else if (minRatioPositions.size() > 1) {\n+\t\t\t\t\tfor (Integer row : minRatioPositions) {\n+\t\t\t\t\t\tfor (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n+\t\t\t\t\t\t\tint column = i\n+\t\t\t\t\t\t\t\t\t+ tableau.getArtificialVariableOffset();\n+\t\t\t\t\t\t\tfinal double entry = tableau.getEntry(row, column);\n+\t\t\t\t\t\t\tif (Precision.equals(entry, 1d, maxUlps)\n+\t\t\t\t\t\t\t\t\t&& row.equals(tableau.getBasicRow(column))) {\n+\t\t\t\t\t\t\t\treturn row;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tInteger minRow = null;\n+\t\t\t\t\tint minIndex = tableau.getWidth();\n+\t\t\t\t\tfor (Integer row : minRatioPositions) {\n+\t\t\t\t\t\tint i = tableau.getNumObjectiveFunctions();\n+\t\t\t\t\t\tfor (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n+\t\t\t\t\t\t\tif (row == tableau.getBasicRow(i)) {\n+\t\t\t\t\t\t\t\tif (i < minIndex) {\n+\t\t\t\t\t\t\t\t\tminIndex = i;\n+\t\t\t\t\t\t\t\t\tminRow = row;\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\treturn minRow;\n+\t\t\t\t}\n+\t\t\t\t// 2. apply Bland's rule to prevent cycling:\n             //    take the row for which the corresponding basic variable has the smallest index\n             //\n             // see http://www.stanford.edu/class/msande310/blandrule.pdf\n@@ -143,7 +171,6 @@\n                         if (row == tableau.getBasicRow(i)) {\n                             if (i < minIndex) {\n                                 minIndex = i;\n-                                minRow = row;\n                             }\n                         }\n                     }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 138, 
          "faulty": "Integer minRow=null;", 
          "type": "InsertBefore", 
          "seed": "if (minRatioPositions.size() == 0) {\n  return null;\n}\n else if (minRatioPositions.size() > 1) {\n  for (  Integer row : minRatioPositions) {\n    for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n      int column=i + tableau.getArtificialVariableOffset();\n      final double entry=tableau.getEntry(row,column);\n      if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n        return row;\n      }\n    }\n  }\n  Integer minRow=null;\n  int minIndex=tableau.getWidth();\n  for (  Integer row : minRatioPositions) {\n    int i=tableau.getNumObjectiveFunctions();\n    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n      if (row == tableau.getBasicRow(i)) {\n        if (i < minIndex) {\n          minIndex=i;\n          minRow=row;\n        }\n      }\n    }\n  }\n  return minRow;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Delete", 
          "seed": "if (!Precision.equals(entry,0d,maxUlps)) {\n  return null;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 146, 
          "faulty": "minRow=row;", 
          "type": "Delete", 
          "seed": "throw new NoFeasibleSolutionException();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1658/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:14:12.697764025 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/AbstractLinearOptimizer.java\t2018-12-01 06:29:45.579618752 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1658/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/AbstractLinearOptimizer.java\t2018-12-01 07:14:12.697764025 -0500\n@@ -125,7 +125,7 @@\n     protected void incrementIterationsCounter()\n         throws MaxCountExceededException {\n         if (++iterations > maxIterations) {\n-            throw new MaxCountExceededException(maxIterations);\n+            throw new NoFeasibleSolutionException();\n         }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/AbstractLinearOptimizer.java", 
          "line": 128, 
          "faulty": "throw new MaxCountExceededException(maxIterations);", 
          "type": "Replace", 
          "seed": "throw new NoFeasibleSolutionException();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "minRatioPositions=new ArrayList<Integer>();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 124, 
          "faulty": "return row;", 
          "type": "Delete", 
          "seed": "incrementIterationsCounter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_565/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:01:51.788710004 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "continue;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 124, 
          "faulty": "return row;", 
          "type": "InsertBefore", 
          "seed": "solvePhase1(tableau);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_398/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:00:18.193089521 -0500\n@@ -117,13 +117,7 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n+                    continue;\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Replace", 
          "seed": "continue;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_577/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:01:58.248684159 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\t2018-12-01 06:29:45.583618730 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_577/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\t2018-12-01 07:01:58.252684142 -0500\n@@ -228,7 +228,10 @@\n             if (constraint.getRelationship() == Relationship.LEQ) {\n                 matrix.setEntry(row, getSlackVariableOffset() + slackVar++, 1);  // slack\n             } else if (constraint.getRelationship() == Relationship.GEQ) {\n-                matrix.setEntry(row, getSlackVariableOffset() + slackVar++, -1); // excess\n+                if (constraint.getRelationship() == Relationship.GEQ) {\n+\t\t\t\t\tmatrix.setEntry(row, getSlackVariableOffset() + slackVar++,\n+\t\t\t\t\t\t\t-1);\n+\t\t\t\t}\n             }\n \n             // artificial variables\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java", 
          "line": 231, 
          "faulty": "matrix.setEntry(row,getSlackVariableOffset() + slackVar++,-1);", 
          "type": "Replace", 
          "seed": "if (constraint.getRelationship() == Relationship.GEQ) {\n  matrix.setEntry(row,getSlackVariableOffset() + slackVar++,-1);\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "continue;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_269/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:58:50.645454192 -0500\n@@ -119,7 +119,7 @@\n                 for (Integer row : minRatioPositions) {\n                     for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                         int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n+                        final double entry = tableau.getEntry(i, col);\n                         if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n                             return row;\n                         }\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 06:29:45.307620212 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_269/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 06:58:50.645454192 -0500\n@@ -170,7 +170,8 @@\n                                 String separator) {\n         final StringBuilder sb = new StringBuilder();\n         int count = 0;\n-        final int len = msgPatterns.size();\n+        this.throwable = throwable;\n+\t\tfinal int len = msgPatterns.size();\n         for (int i = 0; i < len; i++) {\n             final Localizable pat = msgPatterns.get(i);\n             final Object[] args = msgArguments.get(i);\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 122, 
          "faulty": "final double entry=tableau.getEntry(row,column);", 
          "type": "Replace", 
          "seed": "final double entry=tableau.getEntry(i,col);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java", 
          "line": 173, 
          "faulty": "final int len=msgPatterns.size();", 
          "type": "InsertBefore", 
          "seed": "this.throwable=throwable;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1004/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:06:57.991482570 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "if (minRatioPositions.size() > 1) {\n  for (  Integer row : minRatioPositions) {\n    for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n      int column=i + tableau.getArtificialVariableOffset();\n      final double entry=tableau.getEntry(row,column);\n      if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n        return row;\n      }\n    }\n  }\n  Integer minRow=null;\n  int minIndex=tableau.getWidth();\n  for (  Integer row : minRatioPositions) {\n    int i=tableau.getNumObjectiveFunctions();\n    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n      if (row == tableau.getBasicRow(i)) {\n        if (i < minIndex) {\n          minIndex=i;\n          minRow=row;\n        }\n      }\n    }\n  }\n  return minRow;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 121, 
          "faulty": "int column=i + tableau.getArtificialVariableOffset();", 
          "type": "InsertBefore", 
          "seed": "this.epsilon=epsilon;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_836/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:05:09.043928205 -0500\n@@ -101,7 +101,6 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n@@ -137,7 +136,8 @@\n             // This heuristic is based on empirical data gathered while investigating MATH-828.\n                 Integer minRow = null;\n                 int minIndex = tableau.getWidth();\n-                for (Integer row : minRatioPositions) {\n+                incrementIterationsCounter();\n+\t\t\t\tfor (Integer row : minRatioPositions) {\n                     int i = tableau.getNumObjectiveFunctions();\n                     for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n                         if (row == tableau.getBasicRow(i)) {\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Delete", 
          "seed": "this.epsilon=epsilon;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 140, 
          "faulty": "for (Integer row : minRatioPositions) {\n  int i=tableau.getNumObjectiveFunctions();\n  for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n    if (row == tableau.getBasicRow(i)) {\n      if (i < minIndex) {\n        minIndex=i;\n        minRow=row;\n      }\n    }\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "incrementIterationsCounter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_823/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:05:01.779958413 -0500\n@@ -115,17 +115,6 @@\n         } else if (minRatioPositions.size() > 1) {\n             // there's a degeneracy as indicated by a tie in the minimum ratio test\n \n-            // 1. check if there's an artificial variable that can be forced out of the basis\n-                for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n-                }\n-\n             // 2. apply Bland's rule to prevent cycling:\n             //    take the row for which the corresponding basic variable has the smallest index\n             //\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 06:29:45.307620212 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_823/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 07:05:01.779958413 -0500\n@@ -183,7 +183,8 @@\n             }\n         }\n \n-        return sb.toString();\n+        msgArguments = new ArrayList<Object[]>(len);\n+\t\treturn sb.toString();\n     }\n \n     /**\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 122, 
          "faulty": "final double entry=tableau.getEntry(row,column);", 
          "type": "Replace", 
          "seed": "final double entry=tableau.getEntry(i,col);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 119, 
          "faulty": "for (Integer row : minRatioPositions) {\n  for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n    int column=i + tableau.getArtificialVariableOffset();\n    final double entry=tableau.getEntry(row,column);\n    if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n      return row;\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "setMaxIterations(DEFAULT_MAX_ITERATIONS);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java", 
          "line": 186, 
          "faulty": "return sb.toString();", 
          "type": "InsertBefore", 
          "seed": "msgArguments=new ArrayList<Object[]>(len);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "continue;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_204/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:58:04.393634337 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "continue;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 123, 
          "faulty": "if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n  return row;\n}", 
          "type": "InsertBefore", 
          "seed": "this.maxUlps=maxUlps;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1668/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:14:29.205697493 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "continue;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 123, 
          "faulty": "if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n  return row;\n}", 
          "type": "Replace", 
          "seed": "this.maxUlps=maxUlps;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 124, 
          "faulty": "return row;", 
          "type": "Delete", 
          "seed": "solvePhase1(tableau);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1297/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:10:21.154681986 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "incrementIterationsCounter();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 123, 
          "faulty": "if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n  return row;\n}", 
          "type": "InsertBefore", 
          "seed": "if (minRatioPositions.size() == 0) {\n  return null;\n}\n else if (minRatioPositions.size() > 1) {\n  for (  Integer row : minRatioPositions) {\n    for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n      int column=i + tableau.getArtificialVariableOffset();\n      final double entry=tableau.getEntry(row,column);\n      if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n        return row;\n      }\n    }\n  }\n  Integer minRow=null;\n  int minIndex=tableau.getWidth();\n  for (  Integer row : minRatioPositions) {\n    int i=tableau.getNumObjectiveFunctions();\n    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n      if (row == tableau.getBasicRow(i)) {\n        if (i < minIndex) {\n          minIndex=i;\n          minRow=row;\n        }\n      }\n    }\n  }\n  return minRow;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 124, 
          "faulty": "return row;", 
          "type": "Replace", 
          "seed": "if (minRatioPositions.size() > 1) {\n  for (  Integer row : minRatioPositions) {\n    for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n      int column=i + tableau.getArtificialVariableOffset();\n      final double entry=tableau.getEntry(row,column);\n      if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n        return row;\n      }\n    }\n  }\n  Integer minRow=null;\n  int minIndex=tableau.getWidth();\n  for (  Integer row : minRatioPositions) {\n    int i=tableau.getNumObjectiveFunctions();\n    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n      if (row == tableau.getBasicRow(i)) {\n        if (i < minIndex) {\n          minIndex=i;\n          minRow=row;\n        }\n      }\n    }\n  }\n  return minRow;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1369/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:11:07.238504743 -0500\n@@ -115,17 +115,6 @@\n         } else if (minRatioPositions.size() > 1) {\n             // there's a degeneracy as indicated by a tie in the minimum ratio test\n \n-            // 1. check if there's an artificial variable that can be forced out of the basis\n-                for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n-                }\n-\n             // 2. apply Bland's rule to prevent cycling:\n             //    take the row for which the corresponding basic variable has the smallest index\n             //\n@@ -148,7 +137,6 @@\n                         }\n                     }\n                 }\n-                return minRow;\n         }\n         return minRatioPositions.get(0);\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 151, 
          "faulty": "return minRow;", 
          "type": "Delete", 
          "seed": "while (!tableau.isOptimal()) {\n  doIteration(tableau);\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 119, 
          "faulty": "for (Integer row : minRatioPositions) {\n  for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n    int column=i + tableau.getArtificialVariableOffset();\n    final double entry=tableau.getEntry(row,column);\n    if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n      return row;\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "if (minRatioPositions.size() == 0) {\n  return null;\n}\n else if (minRatioPositions.size() > 1) {\n  for (  Integer row : minRatioPositions) {\n    for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n      int column=i + tableau.getArtificialVariableOffset();\n      final double entry=tableau.getEntry(row,column);\n      if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n        return row;\n      }\n    }\n  }\n  Integer minRow=null;\n  int minIndex=tableau.getWidth();\n  for (  Integer row : minRatioPositions) {\n    int i=tableau.getNumObjectiveFunctions();\n    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n      if (row == tableau.getBasicRow(i)) {\n        if (i < minIndex) {\n          minIndex=i;\n          minRow=row;\n        }\n      }\n    }\n  }\n  return minRow;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_163/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:57:42.509719136 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "continue;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 124, 
          "faulty": "return row;", 
          "type": "Replace", 
          "seed": "solvePhase1(tableau);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_123/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:57:14.601828482 -0500\n@@ -101,7 +101,6 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n@@ -119,7 +118,7 @@\n                 for (Integer row : minRatioPositions) {\n                     for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                         int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n+                        final double entry = tableau.getEntry(i, col);\n                         if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n                             return row;\n                         }\n@@ -137,7 +136,24 @@\n             // This heuristic is based on empirical data gathered while investigating MATH-828.\n                 Integer minRow = null;\n                 int minIndex = tableau.getWidth();\n-                for (Integer row : minRatioPositions) {\n+                for (int i = tableau.getNumObjectiveFunctions(); i < tableau\n+\t\t\t\t\t\t.getHeight(); i++) {\n+\t\t\t\t\tfinal double rhs = tableau.getEntry(i,\n+\t\t\t\t\t\t\ttableau.getWidth() - 1);\n+\t\t\t\t\tfinal double entry = tableau.getEntry(i, col);\n+\t\t\t\t\tif (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n+\t\t\t\t\t\tfinal double ratio = rhs / entry;\n+\t\t\t\t\t\tfinal int cmp = Double.compare(ratio, minRatio);\n+\t\t\t\t\t\tif (cmp == 0) {\n+\t\t\t\t\t\t\tminRatioPositions.add(i);\n+\t\t\t\t\t\t} else if (cmp < 0) {\n+\t\t\t\t\t\t\tminRatio = ratio;\n+\t\t\t\t\t\t\tminRatioPositions = new ArrayList<Integer>();\n+\t\t\t\t\t\t\tminRatioPositions.add(i);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tfor (Integer row : minRatioPositions) {\n                     int i = tableau.getNumObjectiveFunctions();\n                     for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n                         if (row == tableau.getBasicRow(i)) {\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 06:29:45.307620212 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_123/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 06:57:14.605828466 -0500\n@@ -125,7 +125,7 @@\n      * @return the message.\n      */\n     public String getMessage() {\n-        return getMessage(Locale.US);\n+        return getMessage(Locale.getDefault());\n     }\n \n     /**\n@@ -170,7 +170,8 @@\n                                 String separator) {\n         final StringBuilder sb = new StringBuilder();\n         int count = 0;\n-        final int len = msgPatterns.size();\n+        this.throwable = throwable;\n+\t\tfinal int len = msgPatterns.size();\n         for (int i = 0; i < len; i++) {\n             final Localizable pat = msgPatterns.get(i);\n             final Object[] args = msgArguments.get(i);\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java", 
          "line": 128, 
          "faulty": "return getMessage(Locale.US);", 
          "type": "Replace", 
          "seed": "return getMessage(Locale.getDefault());"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 122, 
          "faulty": "final double entry=tableau.getEntry(row,column);", 
          "type": "Replace", 
          "seed": "final double entry=tableau.getEntry(i,col);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Delete", 
          "seed": "throw new NoFeasibleSolutionException();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java", 
          "line": 173, 
          "faulty": "final int len=msgPatterns.size();", 
          "type": "InsertBefore", 
          "seed": "this.throwable=throwable;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 140, 
          "faulty": "for (Integer row : minRatioPositions) {\n  int i=tableau.getNumObjectiveFunctions();\n  for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n    if (row == tableau.getBasicRow(i)) {\n      if (i < minIndex) {\n        minIndex=i;\n        minRow=row;\n      }\n    }\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "for (int i=tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n  final double rhs=tableau.getEntry(i,tableau.getWidth() - 1);\n  final double entry=tableau.getEntry(i,col);\n  if (Precision.compareTo(entry,0d,maxUlps) > 0) {\n    final double ratio=rhs / entry;\n    final int cmp=Double.compare(ratio,minRatio);\n    if (cmp == 0) {\n      minRatioPositions.add(i);\n    }\n else     if (cmp < 0) {\n      minRatio=ratio;\n      minRatioPositions=new ArrayList<Integer>();\n      minRatioPositions.add(i);\n    }\n  }\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_198/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:58:01.749644541 -0500\n@@ -101,7 +101,6 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java\t2018-12-01 06:29:45.303620234 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_198/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java\t2018-12-01 06:58:01.749644541 -0500\n@@ -83,6 +83,7 @@\n     /** {@inheritDoc} */\n     @Override\n     public String getLocalizedMessage() {\n-        return context.getLocalizedMessage();\n+        getContext().addMessage(LocalizedFormats.EVALUATIONS);\n+\t\treturn context.getLocalizedMessage();\n     }\n }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Delete", 
          "seed": "incrementIterationsCounter();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java", 
          "line": 86, 
          "faulty": "return context.getLocalizedMessage();", 
          "type": "InsertBefore", 
          "seed": "getContext().addMessage(LocalizedFormats.EVALUATIONS);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_570/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:01:54.340699788 -0500\n@@ -101,7 +101,6 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n@@ -121,7 +120,7 @@\n                         int column = i + tableau.getArtificialVariableOffset();\n                         final double entry = tableau.getEntry(row, column);\n                         if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n+                            doIteration(tableau);\n                         }\n                     }\n                 }\n@@ -148,7 +147,7 @@\n                         }\n                     }\n                 }\n-                return minRow;\n+                minRatioPositions = new ArrayList<Integer>();\n         }\n         return minRatioPositions.get(0);\n     }\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java\t2018-12-01 06:29:45.303620234 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_570/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java\t2018-12-01 07:01:54.340699788 -0500\n@@ -83,6 +83,7 @@\n     /** {@inheritDoc} */\n     @Override\n     public String getLocalizedMessage() {\n-        return context.getLocalizedMessage();\n+        getContext().addMessage(LocalizedFormats.EVALUATIONS);\n+\t\treturn context.getLocalizedMessage();\n     }\n }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 151, 
          "faulty": "return minRow;", 
          "type": "Replace", 
          "seed": "minRatioPositions=new ArrayList<Integer>();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Delete", 
          "seed": "return minRatioPositions.get(0);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java", 
          "line": 86, 
          "faulty": "return context.getLocalizedMessage();", 
          "type": "InsertBefore", 
          "seed": "getContext().addMessage(LocalizedFormats.EVALUATIONS);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 124, 
          "faulty": "return row;", 
          "type": "Replace", 
          "seed": "doIteration(tableau);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1591/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:13:35.261915883 -0500\n@@ -101,7 +101,6 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n@@ -117,13 +116,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 122, 
          "faulty": "final double entry=tableau.getEntry(row,column);", 
          "type": "Replace", 
          "seed": "final double entry=tableau.getEntry(i,col);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Delete", 
          "seed": "throw new NoFeasibleSolutionException();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "if (minRatioPositions.size() > 1) {\n  for (  Integer row : minRatioPositions) {\n    for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n      int column=i + tableau.getArtificialVariableOffset();\n      final double entry=tableau.getEntry(row,column);\n      if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n        return row;\n      }\n    }\n  }\n  Integer minRow=null;\n  int minIndex=tableau.getWidth();\n  for (  Integer row : minRatioPositions) {\n    int i=tableau.getNumObjectiveFunctions();\n    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n      if (row == tableau.getBasicRow(i)) {\n        if (i < minIndex) {\n          minIndex=i;\n          minRow=row;\n        }\n      }\n    }\n  }\n  return minRow;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java", 
          "line": 86, 
          "faulty": "return context.getLocalizedMessage();", 
          "type": "Replace", 
          "seed": "return context.getLocalizedMessage();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1135/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:08:43.391062952 -0500\n@@ -101,7 +101,6 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n@@ -142,7 +141,7 @@\n                     for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n                         if (row == tableau.getBasicRow(i)) {\n                             if (i < minIndex) {\n-                                minIndex = i;\n+                                minRow = row;\n                                 minRow = row;\n                             }\n                         }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Delete", 
          "seed": "if (!Precision.equals(entry,0d,maxUlps)) {\n  return null;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 145, 
          "faulty": "minIndex=i;", 
          "type": "Replace", 
          "seed": "minRow=row;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_309/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:59:17.553341012 -0500\n@@ -101,7 +101,6 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n@@ -117,13 +116,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n@@ -141,10 +133,6 @@\n                     int i = tableau.getNumObjectiveFunctions();\n                     for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n                         if (row == tableau.getBasicRow(i)) {\n-                            if (i < minIndex) {\n-                                minIndex = i;\n-                                minRow = row;\n-                            }\n                         }\n                     }\n                 }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Delete", 
          "seed": "return minRatioPositions.get(0);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 144, 
          "faulty": "if (i < minIndex) {\n  minIndex=i;\n  minRow=row;\n}", 
          "type": "Delete", 
          "seed": "throw new UnboundedSolutionException();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "minRatioPositions=new ArrayList<Integer>();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_827/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:05:03.743950238 -0500\n@@ -101,7 +101,6 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n@@ -141,10 +140,6 @@\n                     int i = tableau.getNumObjectiveFunctions();\n                     for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n                         if (row == tableau.getBasicRow(i)) {\n-                            if (i < minIndex) {\n-                                minIndex = i;\n-                                minRow = row;\n-                            }\n                         }\n                     }\n                 }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Delete", 
          "seed": "if (!Precision.equals(entry,0d,maxUlps)) {\n  return null;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 144, 
          "faulty": "if (i < minIndex) {\n  minIndex=i;\n  minRow=row;\n}", 
          "type": "Delete", 
          "seed": "row=i;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_789/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:04:33.676073808 -0500\n@@ -101,7 +101,6 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n@@ -121,7 +120,6 @@\n                         int column = i + tableau.getArtificialVariableOffset();\n                         final double entry = tableau.getEntry(row, column);\n                         if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n                         }\n                     }\n                 }\n@@ -137,17 +135,6 @@\n             // This heuristic is based on empirical data gathered while investigating MATH-828.\n                 Integer minRow = null;\n                 int minIndex = tableau.getWidth();\n-                for (Integer row : minRatioPositions) {\n-                    int i = tableau.getNumObjectiveFunctions();\n-                    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n-                        if (row == tableau.getBasicRow(i)) {\n-                            if (i < minIndex) {\n-                                minIndex = i;\n-                                minRow = row;\n-                            }\n-                        }\n-                    }\n-                }\n                 return minRow;\n         }\n         return minRatioPositions.get(0);\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Delete", 
          "seed": "return minRatioPositions.get(0);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 140, 
          "faulty": "for (Integer row : minRatioPositions) {\n  int i=tableau.getNumObjectiveFunctions();\n  for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n    if (row == tableau.getBasicRow(i)) {\n      if (i < minIndex) {\n        minIndex=i;\n        minRow=row;\n      }\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "while (!tableau.isOptimal()) {\n  doIteration(tableau);\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 124, 
          "faulty": "return row;", 
          "type": "Delete", 
          "seed": "if (minRatioPositions.size() == 0) {\n  return null;\n}\n else if (minRatioPositions.size() > 1) {\n  for (  Integer row : minRatioPositions) {\n    for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n      int column=i + tableau.getArtificialVariableOffset();\n      final double entry=tableau.getEntry(row,column);\n      if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n        return row;\n      }\n    }\n  }\n  Integer minRow=null;\n  int minIndex=tableau.getWidth();\n  for (  Integer row : minRatioPositions) {\n    int i=tableau.getNumObjectiveFunctions();\n    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n      if (row == tableau.getBasicRow(i)) {\n        if (i < minIndex) {\n          minIndex=i;\n          minRow=row;\n        }\n      }\n    }\n  }\n  return minRow;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_520/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:01:26.124813108 -0500\n@@ -115,17 +115,6 @@\n         } else if (minRatioPositions.size() > 1) {\n             // there's a degeneracy as indicated by a tie in the minimum ratio test\n \n-            // 1. check if there's an artificial variable that can be forced out of the basis\n-                for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n-                }\n-\n             // 2. apply Bland's rule to prevent cycling:\n             //    take the row for which the corresponding basic variable has the smallest index\n             //\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 122, 
          "faulty": "final double entry=tableau.getEntry(row,column);", 
          "type": "Replace", 
          "seed": "final double entry=tableau.getEntry(i,col);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 119, 
          "faulty": "for (Integer row : minRatioPositions) {\n  for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n    int column=i + tableau.getArtificialVariableOffset();\n    final double entry=tableau.getEntry(row,column);\n    if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n      return row;\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "if (minRatioPositions.size() == 0) {\n  return null;\n}\n else if (minRatioPositions.size() > 1) {\n  for (  Integer row : minRatioPositions) {\n    for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n      int column=i + tableau.getArtificialVariableOffset();\n      final double entry=tableau.getEntry(row,column);\n      if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n        return row;\n      }\n    }\n  }\n  Integer minRow=null;\n  int minIndex=tableau.getWidth();\n  for (  Integer row : minRatioPositions) {\n    int i=tableau.getNumObjectiveFunctions();\n    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n      if (row == tableau.getBasicRow(i)) {\n        if (i < minIndex) {\n          minIndex=i;\n          minRow=row;\n        }\n      }\n    }\n  }\n  return minRow;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_553/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:01:45.892733631 -0500\n@@ -115,17 +115,6 @@\n         } else if (minRatioPositions.size() > 1) {\n             // there's a degeneracy as indicated by a tie in the minimum ratio test\n \n-            // 1. check if there's an artificial variable that can be forced out of the basis\n-                for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n-                }\n-\n             // 2. apply Bland's rule to prevent cycling:\n             //    take the row for which the corresponding basic variable has the smallest index\n             //\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 06:29:45.307620212 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_553/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 07:01:45.892733631 -0500\n@@ -173,7 +173,8 @@\n         final int len = msgPatterns.size();\n         for (int i = 0; i < len; i++) {\n             final Localizable pat = msgPatterns.get(i);\n-            final Object[] args = msgArguments.get(i);\n+            context = new HashMap<String, Object>();\n+\t\t\tfinal Object[] args = msgArguments.get(i);\n             final MessageFormat fmt = new MessageFormat(pat.getLocalizedString(locale),\n                                                         locale);\n             sb.append(fmt.format(args));\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 122, 
          "faulty": "final double entry=tableau.getEntry(row,column);", 
          "type": "Replace", 
          "seed": "final double entry=tableau.getEntry(i,col);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 119, 
          "faulty": "for (Integer row : minRatioPositions) {\n  for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n    int column=i + tableau.getArtificialVariableOffset();\n    final double entry=tableau.getEntry(row,column);\n    if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n      return row;\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "setMaxIterations(DEFAULT_MAX_ITERATIONS);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java", 
          "line": 176, 
          "faulty": "final Object[] args=msgArguments.get(i);", 
          "type": "InsertBefore", 
          "seed": "context=new HashMap<String,Object>();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_148/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:57:33.173755559 -0500\n@@ -101,7 +101,6 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n@@ -119,7 +118,7 @@\n                 for (Integer row : minRatioPositions) {\n                     for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                         int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n+                        final double entry = tableau.getEntry(i, col);\n                         if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n                             return row;\n                         }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 122, 
          "faulty": "final double entry=tableau.getEntry(row,column);", 
          "type": "Replace", 
          "seed": "final double entry=tableau.getEntry(i,col);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Delete", 
          "seed": "incrementIterationsCounter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1166/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:09:01.134993265 -0500\n@@ -101,7 +101,6 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n@@ -137,7 +136,12 @@\n             // This heuristic is based on empirical data gathered while investigating MATH-828.\n                 Integer minRow = null;\n                 int minIndex = tableau.getWidth();\n-                for (Integer row : minRatioPositions) {\n+                if (!Precision.equals(\n+\t\t\t\t\t\ttableau.getEntry(0, tableau.getRhsOffset()), 0d,\n+\t\t\t\t\t\tepsilon)) {\n+\t\t\t\t\tthrow new NoFeasibleSolutionException();\n+\t\t\t\t}\n+\t\t\t\tfor (Integer row : minRatioPositions) {\n                     int i = tableau.getNumObjectiveFunctions();\n                     for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n                         if (row == tableau.getBasicRow(i)) {\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Delete", 
          "seed": "if (!Precision.equals(entry,0d,maxUlps)) {\n  return null;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 140, 
          "faulty": "for (Integer row : minRatioPositions) {\n  int i=tableau.getNumObjectiveFunctions();\n  for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n    if (row == tableau.getBasicRow(i)) {\n      if (i < minIndex) {\n        minIndex=i;\n        minRow=row;\n      }\n    }\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "if (!Precision.equals(tableau.getEntry(0,tableau.getRhsOffset()),0d,epsilon)) {\n  throw new NoFeasibleSolutionException();\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1021/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:07:13.875418667 -0500\n@@ -101,7 +101,6 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n@@ -121,7 +120,7 @@\n                         int column = i + tableau.getArtificialVariableOffset();\n                         final double entry = tableau.getEntry(row, column);\n                         if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n+                            incrementIterationsCounter();\n                         }\n                     }\n                 }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Delete", 
          "seed": "if (!Precision.equals(entry,0d,maxUlps)) {\n  return null;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 124, 
          "faulty": "return row;", 
          "type": "Replace", 
          "seed": "incrementIterationsCounter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1558/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:13:16.769991315 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n@@ -224,7 +217,8 @@\n         tableau.dropPhase1Objective();\n \n         while (!tableau.isOptimal()) {\n-            doIteration(tableau);\n+            tableau.dropPhase1Objective();\n+\t\t\tdoIteration(tableau);\n         }\n         return tableau.getSolution();\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "continue;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 227, 
          "faulty": "doIteration(tableau);", 
          "type": "InsertBefore", 
          "seed": "tableau.dropPhase1Objective();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_82/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:56:46.077941785 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "doIteration(tableau);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 123, 
          "faulty": "if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n  return row;\n}", 
          "type": "Delete", 
          "seed": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_535/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:01:36.220772466 -0500\n@@ -101,7 +101,6 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n@@ -137,7 +136,12 @@\n             // This heuristic is based on empirical data gathered while investigating MATH-828.\n                 Integer minRow = null;\n                 int minIndex = tableau.getWidth();\n-                for (Integer row : minRatioPositions) {\n+                if (!Precision.equals(\n+\t\t\t\t\t\ttableau.getEntry(0, tableau.getRhsOffset()), 0d,\n+\t\t\t\t\t\tepsilon)) {\n+\t\t\t\t\tthrow new NoFeasibleSolutionException();\n+\t\t\t\t}\n+\t\t\t\tfor (Integer row : minRatioPositions) {\n                     int i = tableau.getNumObjectiveFunctions();\n                     for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n                         if (row == tableau.getBasicRow(i)) {\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 06:29:45.307620212 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_535/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 07:01:36.220772466 -0500\n@@ -125,7 +125,7 @@\n      * @return the message.\n      */\n     public String getMessage() {\n-        return getMessage(Locale.US);\n+        return getMessage(Locale.getDefault());\n     }\n \n     /**\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java", 
          "line": 128, 
          "faulty": "return getMessage(Locale.US);", 
          "type": "Replace", 
          "seed": "return getMessage(Locale.getDefault());"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Delete", 
          "seed": "if (!Precision.equals(entry,0d,maxUlps)) {\n  return null;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 140, 
          "faulty": "for (Integer row : minRatioPositions) {\n  int i=tableau.getNumObjectiveFunctions();\n  for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n    if (row == tableau.getBasicRow(i)) {\n      if (i < minIndex) {\n        minIndex=i;\n        minRow=row;\n      }\n    }\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "if (!Precision.equals(tableau.getEntry(0,tableau.getRhsOffset()),0d,epsilon)) {\n  throw new NoFeasibleSolutionException();\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_895/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:05:48.755764204 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n@@ -148,7 +141,6 @@\n                         }\n                     }\n                 }\n-                return minRow;\n         }\n         return minRatioPositions.get(0);\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 151, 
          "faulty": "return minRow;", 
          "type": "Delete", 
          "seed": "tableau.dropPhase1Objective();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "doIteration(tableau);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_322/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:59:30.141288409 -0500\n@@ -115,17 +115,6 @@\n         } else if (minRatioPositions.size() > 1) {\n             // there's a degeneracy as indicated by a tie in the minimum ratio test\n \n-            // 1. check if there's an artificial variable that can be forced out of the basis\n-                for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n-                }\n-\n             // 2. apply Bland's rule to prevent cycling:\n             //    take the row for which the corresponding basic variable has the smallest index\n             //\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 119, 
          "faulty": "for (Integer row : minRatioPositions) {\n  for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n    int column=i + tableau.getArtificialVariableOffset();\n    final double entry=tableau.getEntry(row,column);\n    if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n      return row;\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "setMaxIterations(DEFAULT_MAX_ITERATIONS);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "doIteration(tableau);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_584/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:02:01.444671387 -0500\n@@ -101,7 +101,6 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n@@ -117,13 +116,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/AbstractLinearOptimizer.java", 
          "line": 128, 
          "faulty": "throw new MaxCountExceededException(maxIterations);", 
          "type": "Replace", 
          "seed": "throw new MaxCountExceededException(maxIterations);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Delete", 
          "seed": "if (!Precision.equals(entry,0d,maxUlps)) {\n  return null;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "incrementIterationsCounter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_333/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:59:36.237263012 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "doIteration(tableau);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java", 
          "line": 80, 
          "faulty": "return context.getMessage();", 
          "type": "Replace", 
          "seed": "return context.getMessage();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_814/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:04:57.335976926 -0500\n@@ -101,7 +101,6 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n\n\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Delete", 
          "seed": "this.maxUlps=maxUlps;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java", 
          "line": 80, 
          "faulty": "return context.getMessage();", 
          "type": "Replace", 
          "seed": "return context.getMessage();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_801/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:04:44.892028903 -0500\n@@ -101,7 +101,7 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n+                    return minRatioPositions.get(0);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n@@ -143,7 +143,7 @@\n                         if (row == tableau.getBasicRow(i)) {\n                             if (i < minIndex) {\n                                 minIndex = i;\n-                                minRow = row;\n+                                return row;\n                             }\n                         }\n                     }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Replace", 
          "seed": "return minRatioPositions.get(0);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 146, 
          "faulty": "minRow=row;", 
          "type": "Replace", 
          "seed": "return row;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_810/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:04:55.439984833 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 122, 
          "faulty": "final double entry=tableau.getEntry(row,column);", 
          "type": "InsertBefore", 
          "seed": "setMaxIterations(DEFAULT_MAX_ITERATIONS);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "doIteration(tableau);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1214/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:09:28.154887625 -0500\n@@ -115,16 +115,7 @@\n         } else if (minRatioPositions.size() > 1) {\n             // there's a degeneracy as indicated by a tie in the minimum ratio test\n \n-            // 1. check if there's an artificial variable that can be forced out of the basis\n-                for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n-                }\n+            setMaxIterations(DEFAULT_MAX_ITERATIONS);\n \n             // 2. apply Bland's rule to prevent cycling:\n             //    take the row for which the corresponding basic variable has the smallest index\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 119, 
          "faulty": "for (Integer row : minRatioPositions) {\n  for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n    int column=i + tableau.getArtificialVariableOffset();\n    final double entry=tableau.getEntry(row,column);\n    if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n      return row;\n    }\n  }\n}", 
          "type": "Replace", 
          "seed": "setMaxIterations(DEFAULT_MAX_ITERATIONS);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "if (minRatioPositions.size() > 1) {\n  for (  Integer row : minRatioPositions) {\n    for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n      int column=i + tableau.getArtificialVariableOffset();\n      final double entry=tableau.getEntry(row,column);\n      if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n        return row;\n      }\n    }\n  }\n  Integer minRow=null;\n  int minIndex=tableau.getWidth();\n  for (  Integer row : minRatioPositions) {\n    int i=tableau.getNumObjectiveFunctions();\n    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n      if (row == tableau.getBasicRow(i)) {\n        if (i < minIndex) {\n          minIndex=i;\n          minRow=row;\n        }\n      }\n    }\n  }\n  return minRow;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1608/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:13:45.037876092 -0500\n@@ -101,7 +101,6 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/AbstractLinearOptimizer.java\t2018-12-01 06:29:45.579618752 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1608/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/AbstractLinearOptimizer.java\t2018-12-01 07:13:45.037876092 -0500\n@@ -125,7 +125,7 @@\n     protected void incrementIterationsCounter()\n         throws MaxCountExceededException {\n         if (++iterations > maxIterations) {\n-            throw new MaxCountExceededException(maxIterations);\n+            return;\n         }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/AbstractLinearOptimizer.java", 
          "line": 128, 
          "faulty": "throw new MaxCountExceededException(maxIterations);", 
          "type": "Replace", 
          "seed": "return;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Delete", 
          "seed": "if (!Precision.equals(entry,0d,maxUlps)) {\n  return null;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1262/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:09:56.482777463 -0500\n@@ -119,7 +119,7 @@\n                 for (Integer row : minRatioPositions) {\n                     for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                         int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n+                        final double entry = tableau.getEntry(i, col);\n                         if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n                             return row;\n                         }\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java\t2018-12-01 06:29:45.303620234 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1262/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java\t2018-12-01 07:09:56.482777463 -0500\n@@ -83,6 +83,7 @@\n     /** {@inheritDoc} */\n     @Override\n     public String getLocalizedMessage() {\n-        return context.getLocalizedMessage();\n+        getContext().addMessage(LocalizedFormats.EVALUATIONS);\n+\t\treturn context.getLocalizedMessage();\n     }\n }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 122, 
          "faulty": "final double entry=tableau.getEntry(row,column);", 
          "type": "Replace", 
          "seed": "final double entry=tableau.getEntry(i,col);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java", 
          "line": 86, 
          "faulty": "return context.getLocalizedMessage();", 
          "type": "InsertBefore", 
          "seed": "getContext().addMessage(LocalizedFormats.EVALUATIONS);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1624/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:13:53.357842303 -0500\n@@ -121,7 +121,6 @@\n                         int column = i + tableau.getArtificialVariableOffset();\n                         final double entry = tableau.getEntry(row, column);\n                         if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n                         }\n                     }\n                 }\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/AbstractLinearOptimizer.java\t2018-12-01 06:29:45.579618752 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1624/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/AbstractLinearOptimizer.java\t2018-12-01 07:13:53.357842303 -0500\n@@ -125,7 +125,7 @@\n     protected void incrementIterationsCounter()\n         throws MaxCountExceededException {\n         if (++iterations > maxIterations) {\n-            throw new MaxCountExceededException(maxIterations);\n+            throw new UnboundedSolutionException();\n         }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/AbstractLinearOptimizer.java", 
          "line": 128, 
          "faulty": "throw new MaxCountExceededException(maxIterations);", 
          "type": "Replace", 
          "seed": "throw new UnboundedSolutionException();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 124, 
          "faulty": "return row;", 
          "type": "Delete", 
          "seed": "return minRatioPositions.get(0);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_306/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:59:16.233346540 -0500\n@@ -148,7 +148,6 @@\n                         }\n                     }\n                 }\n-                return minRow;\n         }\n         return minRatioPositions.get(0);\n     }\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 06:29:45.307620212 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_306/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 06:59:16.237346523 -0500\n@@ -169,7 +169,8 @@\n     private String buildMessage(Locale locale,\n                                 String separator) {\n         final StringBuilder sb = new StringBuilder();\n-        int count = 0;\n+        this.throwable = throwable;\n+\t\tint count = 0;\n         final int len = msgPatterns.size();\n         for (int i = 0; i < len; i++) {\n             final Localizable pat = msgPatterns.get(i);\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 151, 
          "faulty": "return minRow;", 
          "type": "Delete", 
          "seed": "while (!tableau.isOptimal()) {\n  doIteration(tableau);\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java", 
          "line": 172, 
          "faulty": "int count=0;", 
          "type": "InsertBefore", 
          "seed": "this.throwable=throwable;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_382/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:00:09.817123980 -0500\n@@ -121,7 +121,6 @@\n                         int column = i + tableau.getArtificialVariableOffset();\n                         final double entry = tableau.getEntry(row, column);\n                         if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n                         }\n                     }\n                 }\n@@ -143,7 +142,7 @@\n                         if (row == tableau.getBasicRow(i)) {\n                             if (i < minIndex) {\n                                 minIndex = i;\n-                                minRow = row;\n+                                return minRatioPositions.get(0);\n                             }\n                         }\n                     }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 124, 
          "faulty": "return row;", 
          "type": "Delete", 
          "seed": "return minRatioPositions.get(0);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 146, 
          "faulty": "minRow=row;", 
          "type": "Replace", 
          "seed": "return minRatioPositions.get(0);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_392/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:00:14.933102922 -0500\n@@ -101,7 +101,6 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n@@ -117,13 +116,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Delete", 
          "seed": "if (!Precision.equals(entry,0d,maxUlps)) {\n  return null;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "incrementIterationsCounter();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 123, 
          "faulty": "if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n  return row;\n}", 
          "type": "Delete", 
          "seed": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_840/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:05:11.003920065 -0500\n@@ -115,17 +115,6 @@\n         } else if (minRatioPositions.size() > 1) {\n             // there's a degeneracy as indicated by a tie in the minimum ratio test\n \n-            // 1. check if there's an artificial variable that can be forced out of the basis\n-                for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n-                }\n-\n             // 2. apply Bland's rule to prevent cycling:\n             //    take the row for which the corresponding basic variable has the smallest index\n             //\n@@ -148,7 +137,6 @@\n                         }\n                     }\n                 }\n-                return minRow;\n         }\n         return minRatioPositions.get(0);\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 122, 
          "faulty": "final double entry=tableau.getEntry(row,column);", 
          "type": "InsertBefore", 
          "seed": "setMaxIterations(DEFAULT_MAX_ITERATIONS);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 151, 
          "faulty": "return minRow;", 
          "type": "Delete", 
          "seed": "minRatioPositions=new ArrayList<Integer>();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 119, 
          "faulty": "for (Integer row : minRatioPositions) {\n  for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n    int column=i + tableau.getArtificialVariableOffset();\n    final double entry=tableau.getEntry(row,column);\n    if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n      return row;\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "setMaxIterations(DEFAULT_MAX_ITERATIONS);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_973/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:06:34.515577486 -0500\n@@ -101,7 +101,7 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n+                    return minRatioPositions.get(0);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 06:29:45.307620212 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_973/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 07:06:34.519577469 -0500\n@@ -125,7 +125,8 @@\n      * @return the message.\n      */\n     public String getMessage() {\n-        return getMessage(Locale.US);\n+        context = new HashMap<String, Object>();\n+\t\treturn getMessage(Locale.US);\n     }\n \n     /**\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java", 
          "line": 128, 
          "faulty": "return getMessage(Locale.US);", 
          "type": "InsertBefore", 
          "seed": "context=new HashMap<String,Object>();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Replace", 
          "seed": "return minRatioPositions.get(0);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_770/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:04:23.432113419 -0500\n@@ -101,7 +101,6 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n@@ -121,7 +120,6 @@\n                         int column = i + tableau.getArtificialVariableOffset();\n                         final double entry = tableau.getEntry(row, column);\n                         if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n                         }\n                     }\n                 }\n@@ -141,10 +139,6 @@\n                     int i = tableau.getNumObjectiveFunctions();\n                     for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n                         if (row == tableau.getBasicRow(i)) {\n-                            if (i < minIndex) {\n-                                minIndex = i;\n-                                minRow = row;\n-                            }\n                         }\n                     }\n                 }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Delete", 
          "seed": "if (!Precision.equals(entry,0d,maxUlps)) {\n  return null;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 144, 
          "faulty": "if (i < minIndex) {\n  minIndex=i;\n  minRow=row;\n}", 
          "type": "Delete", 
          "seed": "row=i;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 124, 
          "faulty": "return row;", 
          "type": "Delete", 
          "seed": "incrementIterationsCounter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_222/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:58:19.537576100 -0500\n@@ -115,17 +115,6 @@\n         } else if (minRatioPositions.size() > 1) {\n             // there's a degeneracy as indicated by a tie in the minimum ratio test\n \n-            // 1. check if there's an artificial variable that can be forced out of the basis\n-                for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n-                }\n-\n             // 2. apply Bland's rule to prevent cycling:\n             //    take the row for which the corresponding basic variable has the smallest index\n             //\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 119, 
          "faulty": "for (Integer row : minRatioPositions) {\n  for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n    int column=i + tableau.getArtificialVariableOffset();\n    final double entry=tableau.getEntry(row,column);\n    if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n      return row;\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "setMaxIterations(DEFAULT_MAX_ITERATIONS);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1386/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:11:16.450469475 -0500\n@@ -101,7 +101,6 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n@@ -117,13 +116,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Delete", 
          "seed": "if (!Precision.equals(entry,0d,maxUlps)) {\n  return null;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "incrementIterationsCounter();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 123, 
          "faulty": "if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n  return row;\n}", 
          "type": "InsertBefore", 
          "seed": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1038/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:07:29.635355507 -0500\n@@ -119,7 +119,7 @@\n                 for (Integer row : minRatioPositions) {\n                     for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                         int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n+                        final double entry = tableau.getEntry(i, col);\n                         if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n                             return row;\n                         }\n\n\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java", 
          "line": 128, 
          "faulty": "return getMessage(Locale.US);", 
          "type": "Replace", 
          "seed": "return getMessage(Locale.US);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 122, 
          "faulty": "final double entry=tableau.getEntry(row,column);", 
          "type": "Replace", 
          "seed": "final double entry=tableau.getEntry(i,col);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1329/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:10:42.822598477 -0500\n@@ -115,17 +115,6 @@\n         } else if (minRatioPositions.size() > 1) {\n             // there's a degeneracy as indicated by a tie in the minimum ratio test\n \n-            // 1. check if there's an artificial variable that can be forced out of the basis\n-                for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n-                }\n-\n             // 2. apply Bland's rule to prevent cycling:\n             //    take the row for which the corresponding basic variable has the smallest index\n             //\n@@ -140,7 +129,8 @@\n                 for (Integer row : minRatioPositions) {\n                     int i = tableau.getNumObjectiveFunctions();\n                     for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n-                        if (row == tableau.getBasicRow(i)) {\n+                        setMaxIterations(DEFAULT_MAX_ITERATIONS);\n+\t\t\t\t\t\tif (row == tableau.getBasicRow(i)) {\n                             if (i < minIndex) {\n                                 minIndex = i;\n                                 minRow = row;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 119, 
          "faulty": "for (Integer row : minRatioPositions) {\n  for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n    int column=i + tableau.getArtificialVariableOffset();\n    final double entry=tableau.getEntry(row,column);\n    if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n      return row;\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "if (minRatioPositions.size() == 0) {\n  return null;\n}\n else if (minRatioPositions.size() > 1) {\n  for (  Integer row : minRatioPositions) {\n    for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n      int column=i + tableau.getArtificialVariableOffset();\n      final double entry=tableau.getEntry(row,column);\n      if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n        return row;\n      }\n    }\n  }\n  Integer minRow=null;\n  int minIndex=tableau.getWidth();\n  for (  Integer row : minRatioPositions) {\n    int i=tableau.getNumObjectiveFunctions();\n    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n      if (row == tableau.getBasicRow(i)) {\n        if (i < minIndex) {\n          minIndex=i;\n          minRow=row;\n        }\n      }\n    }\n  }\n  return minRow;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "doIteration(tableau);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 143, 
          "faulty": "if (row == tableau.getBasicRow(i)) {\n  if (i < minIndex) {\n    minIndex=i;\n    minRow=row;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "setMaxIterations(DEFAULT_MAX_ITERATIONS);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_704/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:03:29.484323373 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/AbstractLinearOptimizer.java\t2018-12-01 06:29:45.579618752 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_704/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/AbstractLinearOptimizer.java\t2018-12-01 07:03:29.484323373 -0500\n@@ -125,7 +125,10 @@\n     protected void incrementIterationsCounter()\n         throws MaxCountExceededException {\n         if (++iterations > maxIterations) {\n-            throw new MaxCountExceededException(maxIterations);\n+            if (++iterations > maxIterations) {\n+\t\t\t\tthrow new MaxCountExceededException(maxIterations);\n+\t\t\t}\n+\t\t\tthrow new MaxCountExceededException(maxIterations);\n         }\n     }\n \n\n\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 122, 
          "faulty": "final double entry=tableau.getEntry(row,column);", 
          "type": "Replace", 
          "seed": "final double entry=tableau.getEntry(i,col);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/AbstractLinearOptimizer.java", 
          "line": 128, 
          "faulty": "throw new MaxCountExceededException(maxIterations);", 
          "type": "InsertBefore", 
          "seed": "if (++iterations > maxIterations) {\n  throw new MaxCountExceededException(maxIterations);\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "incrementIterationsCounter();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java", 
          "line": 147, 
          "faulty": "return buildMessage(locale,\": \");", 
          "type": "Replace", 
          "seed": "return buildMessage(locale,\": \");"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_562/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:01:50.500715163 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "doIteration(tableau);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 124, 
          "faulty": "return row;", 
          "type": "Replace", 
          "seed": "doIteration(tableau);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/LocalizedFormats.java\t2018-12-01 06:29:45.555618881 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1287/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/LocalizedFormats.java\t2018-12-01 07:10:15.870702399 -0500\n@@ -387,8 +387,6 @@\n             // do nothing here\n         }\n \n-        // either the locale is not supported or the resource is unknown\n-        // don't translate and fall back to using the source format\n         return sourceFormat;\n \n     }\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1287/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:10:15.874702384 -0500\n@@ -119,7 +119,7 @@\n                 for (Integer row : minRatioPositions) {\n                     for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                         int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n+                        final double entry = tableau.getEntry(i, col);\n                         if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n                             return row;\n                         }\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/AbstractLinearOptimizer.java\t2018-12-01 06:29:45.579618752 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1287/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/AbstractLinearOptimizer.java\t2018-12-01 07:10:15.874702384 -0500\n@@ -125,7 +125,7 @@\n     protected void incrementIterationsCounter()\n         throws MaxCountExceededException {\n         if (++iterations > maxIterations) {\n-            throw new MaxCountExceededException(maxIterations);\n+            throw new UnboundedSolutionException();\n         }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 122, 
          "faulty": "final double entry=tableau.getEntry(row,column);", 
          "type": "Replace", 
          "seed": "final double entry=tableau.getEntry(i,col);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/AbstractLinearOptimizer.java", 
          "line": 128, 
          "faulty": "throw new MaxCountExceededException(maxIterations);", 
          "type": "Replace", 
          "seed": "throw new UnboundedSolutionException();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/util/LocalizedFormats.java", 
          "line": 392, 
          "faulty": "return sourceFormat;", 
          "type": "Replace", 
          "seed": "return sourceFormat;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1654/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:14:10.781771764 -0500\n@@ -115,17 +115,6 @@\n         } else if (minRatioPositions.size() > 1) {\n             // there's a degeneracy as indicated by a tie in the minimum ratio test\n \n-            // 1. check if there's an artificial variable that can be forced out of the basis\n-                for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n-                }\n-\n             // 2. apply Bland's rule to prevent cycling:\n             //    take the row for which the corresponding basic variable has the smallest index\n             //\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java\t2018-12-01 06:29:45.303620234 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1654/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java\t2018-12-01 07:14:10.781771764 -0500\n@@ -77,7 +77,7 @@\n     /** {@inheritDoc} */\n     @Override\n     public String getMessage() {\n-        return context.getMessage();\n+        return context.getLocalizedMessage();\n     }\n \n     /** {@inheritDoc} */\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 119, 
          "faulty": "for (Integer row : minRatioPositions) {\n  for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n    int column=i + tableau.getArtificialVariableOffset();\n    final double entry=tableau.getEntry(row,column);\n    if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n      return row;\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "setMaxIterations(DEFAULT_MAX_ITERATIONS);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 124, 
          "faulty": "return row;", 
          "type": "InsertBefore", 
          "seed": "if (minRatioPositions.size() == 0) {\n  return null;\n}\n else if (minRatioPositions.size() > 1) {\n  for (  Integer row : minRatioPositions) {\n    for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n      int column=i + tableau.getArtificialVariableOffset();\n      final double entry=tableau.getEntry(row,column);\n      if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n        return row;\n      }\n    }\n  }\n  Integer minRow=null;\n  int minIndex=tableau.getWidth();\n  for (  Integer row : minRatioPositions) {\n    int i=tableau.getNumObjectiveFunctions();\n    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n      if (row == tableau.getBasicRow(i)) {\n        if (i < minIndex) {\n          minIndex=i;\n          minRow=row;\n        }\n      }\n    }\n  }\n  return minRow;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java", 
          "line": 80, 
          "faulty": "return context.getMessage();", 
          "type": "Replace", 
          "seed": "return context.getLocalizedMessage();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_504/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:01:18.368844405 -0500\n@@ -142,7 +142,7 @@\n                     for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n                         if (row == tableau.getBasicRow(i)) {\n                             if (i < minIndex) {\n-                                minIndex = i;\n+                                incrementIterationsCounter();\n                                 minRow = row;\n                             }\n                         }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 145, 
          "faulty": "minIndex=i;", 
          "type": "Replace", 
          "seed": "incrementIterationsCounter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_144/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:57:31.165763413 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "incrementIterationsCounter();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 123, 
          "faulty": "if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n  return row;\n}", 
          "type": "InsertBefore", 
          "seed": "minRatioPositions=new ArrayList<Integer>();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_29/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:56:01.758121368 -0500\n@@ -120,9 +120,6 @@\n                     for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                         int column = i + tableau.getArtificialVariableOffset();\n                         final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n                     }\n                 }\n \n@@ -141,10 +138,14 @@\n                     int i = tableau.getNumObjectiveFunctions();\n                     for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n                         if (row == tableau.getBasicRow(i)) {\n-                            if (i < minIndex) {\n-                                minIndex = i;\n-                                minRow = row;\n-                            }\n+                            for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n+\t\t\t\t\t\t\t\tif (row == tableau.getBasicRow(i)) {\n+\t\t\t\t\t\t\t\t\tif (i < minIndex) {\n+\t\t\t\t\t\t\t\t\t\tminIndex = i;\n+\t\t\t\t\t\t\t\t\t\tminRow = row;\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n                         }\n                     }\n                 }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 144, 
          "faulty": "if (i < minIndex) {\n  minIndex=i;\n  minRow=row;\n}", 
          "type": "Replace", 
          "seed": "for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n  if (row == tableau.getBasicRow(i)) {\n    if (i < minIndex) {\n      minIndex=i;\n      minRow=row;\n    }\n  }\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 123, 
          "faulty": "if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n  return row;\n}", 
          "type": "Delete", 
          "seed": "tableau.dropPhase1Objective();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/LocalizedFormats.java\t2018-12-01 06:29:45.555618881 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1378/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/LocalizedFormats.java\t2018-12-01 07:11:12.498484599 -0500\n@@ -387,8 +387,6 @@\n             // do nothing here\n         }\n \n-        // either the locale is not supported or the resource is unknown\n-        // don't translate and fall back to using the source format\n         return sourceFormat;\n \n     }\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1378/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:11:12.498484599 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "doIteration(tableau);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 124, 
          "faulty": "return row;", 
          "type": "InsertBefore", 
          "seed": "if (minRatioPositions.size() == 0) {\n  return null;\n}\n else if (minRatioPositions.size() > 1) {\n  for (  Integer row : minRatioPositions) {\n    for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n      int column=i + tableau.getArtificialVariableOffset();\n      final double entry=tableau.getEntry(row,column);\n      if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n        return row;\n      }\n    }\n  }\n  Integer minRow=null;\n  int minIndex=tableau.getWidth();\n  for (  Integer row : minRatioPositions) {\n    int i=tableau.getNumObjectiveFunctions();\n    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n      if (row == tableau.getBasicRow(i)) {\n        if (i < minIndex) {\n          minIndex=i;\n          minRow=row;\n        }\n      }\n    }\n  }\n  return minRow;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/util/LocalizedFormats.java", 
          "line": 392, 
          "faulty": "return sourceFormat;", 
          "type": "Replace", 
          "seed": "return sourceFormat;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_420/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:00:29.609042695 -0500\n@@ -121,7 +121,7 @@\n                         int column = i + tableau.getArtificialVariableOffset();\n                         final double entry = tableau.getEntry(row, column);\n                         if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n+                            return minRatioPositions.get(0);\n                         }\n                     }\n                 }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 124, 
          "faulty": "return row;", 
          "type": "Replace", 
          "seed": "return minRatioPositions.get(0);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_925/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:06:06.271692457 -0500\n@@ -101,7 +101,6 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n@@ -115,16 +114,7 @@\n         } else if (minRatioPositions.size() > 1) {\n             // there's a degeneracy as indicated by a tie in the minimum ratio test\n \n-            // 1. check if there's an artificial variable that can be forced out of the basis\n-                for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n-                }\n+            setMaxIterations(DEFAULT_MAX_ITERATIONS);\n \n             // 2. apply Bland's rule to prevent cycling:\n             //    take the row for which the corresponding basic variable has the smallest index\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 119, 
          "faulty": "for (Integer row : minRatioPositions) {\n  for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n    int column=i + tableau.getArtificialVariableOffset();\n    final double entry=tableau.getEntry(row,column);\n    if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n      return row;\n    }\n  }\n}", 
          "type": "Replace", 
          "seed": "setMaxIterations(DEFAULT_MAX_ITERATIONS);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Delete", 
          "seed": "incrementIterationsCounter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_339/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:59:39.505249418 -0500\n@@ -101,7 +101,6 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n@@ -138,7 +137,8 @@\n                 Integer minRow = null;\n                 int minIndex = tableau.getWidth();\n                 for (Integer row : minRatioPositions) {\n-                    int i = tableau.getNumObjectiveFunctions();\n+                    doIteration(tableau);\n+\t\t\t\t\tint i = tableau.getNumObjectiveFunctions();\n                     for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n                         if (row == tableau.getBasicRow(i)) {\n                             if (i < minIndex) {\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Delete", 
          "seed": "return minRatioPositions.get(0);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 141, 
          "faulty": "int i=tableau.getNumObjectiveFunctions();", 
          "type": "InsertBefore", 
          "seed": "doIteration(tableau);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_756/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:04:11.628159161 -0500\n@@ -101,7 +101,7 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n+                    return minRatioPositions.get(0);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Replace", 
          "seed": "return minRatioPositions.get(0);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "continue;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_371/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:00:04.649145283 -0500\n@@ -101,7 +101,6 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n@@ -115,16 +114,35 @@\n         } else if (minRatioPositions.size() > 1) {\n             // there's a degeneracy as indicated by a tie in the minimum ratio test\n \n-            // 1. check if there's an artificial variable that can be forced out of the basis\n-                for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n-                }\n+            if (minRatioPositions.size() == 0) {\n+\t\t\t\t\treturn null;\n+\t\t\t\t} else if (minRatioPositions.size() > 1) {\n+\t\t\t\t\tfor (Integer row : minRatioPositions) {\n+\t\t\t\t\t\tfor (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n+\t\t\t\t\t\t\tint column = i\n+\t\t\t\t\t\t\t\t\t+ tableau.getArtificialVariableOffset();\n+\t\t\t\t\t\t\tfinal double entry = tableau.getEntry(row, column);\n+\t\t\t\t\t\t\tif (Precision.equals(entry, 1d, maxUlps)\n+\t\t\t\t\t\t\t\t\t&& row.equals(tableau.getBasicRow(column))) {\n+\t\t\t\t\t\t\t\treturn row;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tInteger minRow = null;\n+\t\t\t\t\tint minIndex = tableau.getWidth();\n+\t\t\t\t\tfor (Integer row : minRatioPositions) {\n+\t\t\t\t\t\tint i = tableau.getNumObjectiveFunctions();\n+\t\t\t\t\t\tfor (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n+\t\t\t\t\t\t\tif (row == tableau.getBasicRow(i)) {\n+\t\t\t\t\t\t\t\tif (i < minIndex) {\n+\t\t\t\t\t\t\t\t\tminIndex = i;\n+\t\t\t\t\t\t\t\t\tminRow = row;\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\treturn minRow;\n+\t\t\t\t}\n \n             // 2. apply Bland's rule to prevent cycling:\n             //    take the row for which the corresponding basic variable has the smallest index\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 119, 
          "faulty": "for (Integer row : minRatioPositions) {\n  for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n    int column=i + tableau.getArtificialVariableOffset();\n    final double entry=tableau.getEntry(row,column);\n    if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n      return row;\n    }\n  }\n}", 
          "type": "Replace", 
          "seed": "if (minRatioPositions.size() == 0) {\n  return null;\n}\n else if (minRatioPositions.size() > 1) {\n  for (  Integer row : minRatioPositions) {\n    for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n      int column=i + tableau.getArtificialVariableOffset();\n      final double entry=tableau.getEntry(row,column);\n      if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n        return row;\n      }\n    }\n  }\n  Integer minRow=null;\n  int minIndex=tableau.getWidth();\n  for (  Integer row : minRatioPositions) {\n    int i=tableau.getNumObjectiveFunctions();\n    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n      if (row == tableau.getBasicRow(i)) {\n        if (i < minIndex) {\n          minIndex=i;\n          minRow=row;\n        }\n      }\n    }\n  }\n  return minRow;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Delete", 
          "seed": "return minRatioPositions.get(0);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 123, 
          "faulty": "if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n  return row;\n}", 
          "type": "Delete", 
          "seed": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_921/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:06:04.351700304 -0500\n@@ -115,17 +115,6 @@\n         } else if (minRatioPositions.size() > 1) {\n             // there's a degeneracy as indicated by a tie in the minimum ratio test\n \n-            // 1. check if there's an artificial variable that can be forced out of the basis\n-                for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n-                }\n-\n             // 2. apply Bland's rule to prevent cycling:\n             //    take the row for which the corresponding basic variable has the smallest index\n             //\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 06:29:45.307620212 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_921/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 07:06:04.351700304 -0500\n@@ -170,7 +170,8 @@\n                                 String separator) {\n         final StringBuilder sb = new StringBuilder();\n         int count = 0;\n-        final int len = msgPatterns.size();\n+        this.throwable = throwable;\n+\t\tfinal int len = msgPatterns.size();\n         for (int i = 0; i < len; i++) {\n             final Localizable pat = msgPatterns.get(i);\n             final Object[] args = msgArguments.get(i);\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 119, 
          "faulty": "for (Integer row : minRatioPositions) {\n  for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n    int column=i + tableau.getArtificialVariableOffset();\n    final double entry=tableau.getEntry(row,column);\n    if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n      return row;\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "setMaxIterations(DEFAULT_MAX_ITERATIONS);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java", 
          "line": 173, 
          "faulty": "final int len=msgPatterns.size();", 
          "type": "InsertBefore", 
          "seed": "this.throwable=throwable;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_407/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:00:23.141069207 -0500\n@@ -101,7 +101,6 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n@@ -115,17 +114,6 @@\n         } else if (minRatioPositions.size() > 1) {\n             // there's a degeneracy as indicated by a tie in the minimum ratio test\n \n-            // 1. check if there's an artificial variable that can be forced out of the basis\n-                for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n-                }\n-\n             // 2. apply Bland's rule to prevent cycling:\n             //    take the row for which the corresponding basic variable has the smallest index\n             //\n\n\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 119, 
          "faulty": "for (Integer row : minRatioPositions) {\n  for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n    int column=i + tableau.getArtificialVariableOffset();\n    final double entry=tableau.getEntry(row,column);\n    if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n      return row;\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "setMaxIterations(DEFAULT_MAX_ITERATIONS);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Delete", 
          "seed": "throw new NoFeasibleSolutionException();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java", 
          "line": 186, 
          "faulty": "return sb.toString();", 
          "type": "Replace", 
          "seed": "return sb.toString();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_866/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:05:31.283836125 -0500\n@@ -115,17 +115,6 @@\n         } else if (minRatioPositions.size() > 1) {\n             // there's a degeneracy as indicated by a tie in the minimum ratio test\n \n-            // 1. check if there's an artificial variable that can be forced out of the basis\n-                for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n-                }\n-\n             // 2. apply Bland's rule to prevent cycling:\n             //    take the row for which the corresponding basic variable has the smallest index\n             //\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\t2018-12-01 06:29:45.583618730 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_866/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\t2018-12-01 07:05:31.287836108 -0500\n@@ -228,7 +228,9 @@\n             if (constraint.getRelationship() == Relationship.LEQ) {\n                 matrix.setEntry(row, getSlackVariableOffset() + slackVar++, 1);  // slack\n             } else if (constraint.getRelationship() == Relationship.GEQ) {\n-                matrix.setEntry(row, getSlackVariableOffset() + slackVar++, -1); // excess\n+                matrix.setEntry(0, getArtificialVariableOffset()\n+\t\t\t\t\t\t+ artificialVar, 1);\n+\t\t\t\tmatrix.setEntry(row, getSlackVariableOffset() + slackVar++, -1); // excess\n             }\n \n             // artificial variables\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java", 
          "line": 231, 
          "faulty": "matrix.setEntry(row,getSlackVariableOffset() + slackVar++,-1);", 
          "type": "InsertBefore", 
          "seed": "matrix.setEntry(0,getArtificialVariableOffset() + artificialVar,1);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 119, 
          "faulty": "for (Integer row : minRatioPositions) {\n  for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n    int column=i + tableau.getArtificialVariableOffset();\n    final double entry=tableau.getEntry(row,column);\n    if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n      return row;\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "setMaxIterations(DEFAULT_MAX_ITERATIONS);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_506/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:01:19.008841820 -0500\n@@ -101,7 +101,6 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n@@ -117,13 +116,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n@@ -140,12 +132,6 @@\n                 for (Integer row : minRatioPositions) {\n                     int i = tableau.getNumObjectiveFunctions();\n                     for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n-                        if (row == tableau.getBasicRow(i)) {\n-                            if (i < minIndex) {\n-                                minIndex = i;\n-                                minRow = row;\n-                            }\n-                        }\n                     }\n                 }\n                 return minRow;\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 06:29:45.307620212 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_506/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 07:01:19.008841820 -0500\n@@ -134,7 +134,7 @@\n      * @return the localized message.\n      */\n     public String getLocalizedMessage() {\n-        return getMessage(Locale.getDefault());\n+        return getMessage(Locale.US);\n     }\n \n     /**\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Delete", 
          "seed": "if (!Precision.equals(entry,0d,maxUlps)) {\n  return null;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "continue;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java", 
          "line": 137, 
          "faulty": "return getMessage(Locale.getDefault());", 
          "type": "Replace", 
          "seed": "return getMessage(Locale.US);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 143, 
          "faulty": "if (row == tableau.getBasicRow(i)) {\n  if (i < minIndex) {\n    minIndex=i;\n    minRow=row;\n  }\n}", 
          "type": "Delete", 
          "seed": "this.epsilon=epsilon;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_135/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:57:20.393805671 -0500\n@@ -120,9 +120,6 @@\n                     for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                         int column = i + tableau.getArtificialVariableOffset();\n                         final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n                     }\n                 }\n \n@@ -139,14 +136,7 @@\n                 int minIndex = tableau.getWidth();\n                 for (Integer row : minRatioPositions) {\n                     int i = tableau.getNumObjectiveFunctions();\n-                    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n-                        if (row == tableau.getBasicRow(i)) {\n-                            if (i < minIndex) {\n-                                minIndex = i;\n-                                minRow = row;\n-                            }\n-                        }\n-                    }\n+                    return minRatioPositions.get(0);\n                 }\n                 return minRow;\n         }\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 06:29:45.307620212 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_135/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 06:57:20.393805671 -0500\n@@ -134,7 +134,7 @@\n      * @return the localized message.\n      */\n     public String getLocalizedMessage() {\n-        return getMessage(Locale.getDefault());\n+        return getMessage(Locale.US);\n     }\n \n     /**\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 144, 
          "faulty": "if (i < minIndex) {\n  minIndex=i;\n  minRow=row;\n}", 
          "type": "Replace", 
          "seed": "for (Integer row : minRatioPositions) {\n  int i=tableau.getNumObjectiveFunctions();\n  for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n    if (row == tableau.getBasicRow(i)) {\n      if (i < minIndex) {\n        minIndex=i;\n        minRow=row;\n      }\n    }\n  }\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java", 
          "line": 137, 
          "faulty": "return getMessage(Locale.getDefault());", 
          "type": "Replace", 
          "seed": "return getMessage(Locale.US);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 142, 
          "faulty": "for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n  if (row == tableau.getBasicRow(i)) {\n    if (i < minIndex) {\n      minIndex=i;\n      minRow=row;\n    }\n  }\n}", 
          "type": "Replace", 
          "seed": "return minRatioPositions.get(0);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 123, 
          "faulty": "if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n  return row;\n}", 
          "type": "Delete", 
          "seed": "incrementIterationsCounter();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 146, 
          "faulty": "minRow=row;", 
          "type": "Replace", 
          "seed": "minRatioPositions.add(i);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1314/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:10:34.346631106 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\t2018-12-01 06:29:45.583618730 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1314/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\t2018-12-01 07:10:34.350631091 -0500\n@@ -228,7 +228,10 @@\n             if (constraint.getRelationship() == Relationship.LEQ) {\n                 matrix.setEntry(row, getSlackVariableOffset() + slackVar++, 1);  // slack\n             } else if (constraint.getRelationship() == Relationship.GEQ) {\n-                matrix.setEntry(row, getSlackVariableOffset() + slackVar++, -1); // excess\n+                if (constraint.getRelationship() == Relationship.GEQ) {\n+\t\t\t\t\tmatrix.setEntry(row, getSlackVariableOffset() + slackVar++,\n+\t\t\t\t\t\t\t-1);\n+\t\t\t\t}\n             }\n \n             // artificial variables\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java", 
          "line": 231, 
          "faulty": "matrix.setEntry(row,getSlackVariableOffset() + slackVar++,-1);", 
          "type": "Replace", 
          "seed": "if (constraint.getRelationship() == Relationship.GEQ) {\n  matrix.setEntry(row,getSlackVariableOffset() + slackVar++,-1);\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "continue;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 124, 
          "faulty": "return row;", 
          "type": "InsertBefore", 
          "seed": "solvePhase1(tableau);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1325/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:10:40.906605849 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 06:29:45.307620212 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1325/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 07:10:40.910605833 -0500\n@@ -174,7 +174,8 @@\n         for (int i = 0; i < len; i++) {\n             final Localizable pat = msgPatterns.get(i);\n             final Object[] args = msgArguments.get(i);\n-            final MessageFormat fmt = new MessageFormat(pat.getLocalizedString(locale),\n+            msgPatterns.add(pat);\n+\t\t\tfinal MessageFormat fmt = new MessageFormat(pat.getLocalizedString(locale),\n                                                         locale);\n             sb.append(fmt.format(args));\n             if (++count < len) {\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java", 
          "line": 177, 
          "faulty": "final MessageFormat fmt=new MessageFormat(pat.getLocalizedString(locale),locale);", 
          "type": "InsertBefore", 
          "seed": "msgPatterns.add(pat);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "continue;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_662/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:03:04.336422064 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "incrementIterationsCounter();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 121, 
          "faulty": "int column=i + tableau.getArtificialVariableOffset();", 
          "type": "InsertBefore", 
          "seed": "solvePhase1(tableau);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1148/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:08:50.591034644 -0500\n@@ -119,7 +119,7 @@\n                 for (Integer row : minRatioPositions) {\n                     for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                         int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n+                        final double entry = tableau.getEntry(i, col);\n                         if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n                             return row;\n                         }\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 06:29:45.307620212 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1148/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 07:08:50.595034629 -0500\n@@ -174,7 +174,8 @@\n         for (int i = 0; i < len; i++) {\n             final Localizable pat = msgPatterns.get(i);\n             final Object[] args = msgArguments.get(i);\n-            final MessageFormat fmt = new MessageFormat(pat.getLocalizedString(locale),\n+            msgPatterns.add(pat);\n+\t\t\tfinal MessageFormat fmt = new MessageFormat(pat.getLocalizedString(locale),\n                                                         locale);\n             sb.append(fmt.format(args));\n             if (++count < len) {\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 122, 
          "faulty": "final double entry=tableau.getEntry(row,column);", 
          "type": "Replace", 
          "seed": "final double entry=tableau.getEntry(i,col);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java", 
          "line": 177, 
          "faulty": "final MessageFormat fmt=new MessageFormat(pat.getLocalizedString(locale),locale);", 
          "type": "InsertBefore", 
          "seed": "msgPatterns.add(pat);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1252/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:09:50.750799706 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 06:29:45.307620212 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1252/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 07:09:50.750799706 -0500\n@@ -174,7 +174,8 @@\n         for (int i = 0; i < len; i++) {\n             final Localizable pat = msgPatterns.get(i);\n             final Object[] args = msgArguments.get(i);\n-            final MessageFormat fmt = new MessageFormat(pat.getLocalizedString(locale),\n+            this.throwable = throwable;\n+\t\t\tfinal MessageFormat fmt = new MessageFormat(pat.getLocalizedString(locale),\n                                                         locale);\n             sb.append(fmt.format(args));\n             if (++count < len) {\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 122, 
          "faulty": "final double entry=tableau.getEntry(row,column);", 
          "type": "InsertBefore", 
          "seed": "continue;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java", 
          "line": 177, 
          "faulty": "final MessageFormat fmt=new MessageFormat(pat.getLocalizedString(locale),locale);", 
          "type": "InsertBefore", 
          "seed": "this.throwable=throwable;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "if (minRatioPositions.size() > 1) {\n  for (  Integer row : minRatioPositions) {\n    for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n      int column=i + tableau.getArtificialVariableOffset();\n      final double entry=tableau.getEntry(row,column);\n      if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n        return row;\n      }\n    }\n  }\n  Integer minRow=null;\n  int minIndex=tableau.getWidth();\n  for (  Integer row : minRatioPositions) {\n    int i=tableau.getNumObjectiveFunctions();\n    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n      if (row == tableau.getBasicRow(i)) {\n        if (i < minIndex) {\n          minIndex=i;\n          minRow=row;\n        }\n      }\n    }\n  }\n  return minRow;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/LocalizedFormats.java\t2018-12-01 06:29:45.555618881 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_550/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/LocalizedFormats.java\t2018-12-01 07:01:44.584738877 -0500\n@@ -387,8 +387,6 @@\n             // do nothing here\n         }\n \n-        // either the locale is not supported or the resource is unknown\n-        // don't translate and fall back to using the source format\n         return sourceFormat;\n \n     }\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_550/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:01:44.584738877 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "incrementIterationsCounter();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/util/LocalizedFormats.java", 
          "line": 392, 
          "faulty": "return sourceFormat;", 
          "type": "Replace", 
          "seed": "return sourceFormat;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_761/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:04:14.184149247 -0500\n@@ -101,7 +101,6 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n@@ -117,13 +116,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java\t2018-12-01 06:29:45.303620234 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_761/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java\t2018-12-01 07:04:14.184149247 -0500\n@@ -83,6 +83,7 @@\n     /** {@inheritDoc} */\n     @Override\n     public String getLocalizedMessage() {\n-        return context.getLocalizedMessage();\n+        getContext().addMessage(LocalizedFormats.EVALUATIONS);\n+\t\treturn context.getLocalizedMessage();\n     }\n }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 122, 
          "faulty": "final double entry=tableau.getEntry(row,column);", 
          "type": "Replace", 
          "seed": "final double entry=tableau.getEntry(i,col);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Delete", 
          "seed": "throw new NoFeasibleSolutionException();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "incrementIterationsCounter();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java", 
          "line": 86, 
          "faulty": "return context.getLocalizedMessage();", 
          "type": "InsertBefore", 
          "seed": "getContext().addMessage(LocalizedFormats.EVALUATIONS);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1301/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:10:23.078674558 -0500\n@@ -101,7 +101,6 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java\t2018-12-01 06:29:45.303620234 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1301/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java\t2018-12-01 07:10:23.078674558 -0500\n@@ -83,6 +83,6 @@\n     /** {@inheritDoc} */\n     @Override\n     public String getLocalizedMessage() {\n-        return context.getLocalizedMessage();\n+        return context.getMessage();\n     }\n }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Delete", 
          "seed": "incrementIterationsCounter();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java", 
          "line": 86, 
          "faulty": "return context.getLocalizedMessage();", 
          "type": "Replace", 
          "seed": "return context.getMessage();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_718/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:03:42.692271753 -0500\n@@ -115,17 +115,6 @@\n         } else if (minRatioPositions.size() > 1) {\n             // there's a degeneracy as indicated by a tie in the minimum ratio test\n \n-            // 1. check if there's an artificial variable that can be forced out of the basis\n-                for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n-                }\n-\n             // 2. apply Bland's rule to prevent cycling:\n             //    take the row for which the corresponding basic variable has the smallest index\n             //\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/AbstractLinearOptimizer.java\t2018-12-01 06:29:45.579618752 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_718/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/AbstractLinearOptimizer.java\t2018-12-01 07:03:42.696271738 -0500\n@@ -125,7 +125,7 @@\n     protected void incrementIterationsCounter()\n         throws MaxCountExceededException {\n         if (++iterations > maxIterations) {\n-            throw new MaxCountExceededException(maxIterations);\n+            throw new UnboundedSolutionException();\n         }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/AbstractLinearOptimizer.java", 
          "line": 128, 
          "faulty": "throw new MaxCountExceededException(maxIterations);", 
          "type": "Replace", 
          "seed": "throw new UnboundedSolutionException();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 119, 
          "faulty": "for (Integer row : minRatioPositions) {\n  for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n    int column=i + tableau.getArtificialVariableOffset();\n    final double entry=tableau.getEntry(row,column);\n    if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n      return row;\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "setMaxIterations(DEFAULT_MAX_ITERATIONS);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_820/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:05:00.475963842 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n@@ -140,7 +133,8 @@\n                 for (Integer row : minRatioPositions) {\n                     int i = tableau.getNumObjectiveFunctions();\n                     for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n-                        if (row == tableau.getBasicRow(i)) {\n+                        setMaxIterations(DEFAULT_MAX_ITERATIONS);\n+\t\t\t\t\t\tif (row == tableau.getBasicRow(i)) {\n                             if (i < minIndex) {\n                                 minIndex = i;\n                                 minRow = row;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "if (minRatioPositions.size() > 1) {\n  for (  Integer row : minRatioPositions) {\n    for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n      int column=i + tableau.getArtificialVariableOffset();\n      final double entry=tableau.getEntry(row,column);\n      if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n        return row;\n      }\n    }\n  }\n  Integer minRow=null;\n  int minIndex=tableau.getWidth();\n  for (  Integer row : minRatioPositions) {\n    int i=tableau.getNumObjectiveFunctions();\n    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n      if (row == tableau.getBasicRow(i)) {\n        if (i < minIndex) {\n          minIndex=i;\n          minRow=row;\n        }\n      }\n    }\n  }\n  return minRow;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 143, 
          "faulty": "if (row == tableau.getBasicRow(i)) {\n  if (i < minIndex) {\n    minIndex=i;\n    minRow=row;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "setMaxIterations(DEFAULT_MAX_ITERATIONS);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1619/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:13:50.745852903 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "incrementIterationsCounter();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 124, 
          "faulty": "return row;", 
          "type": "Replace", 
          "seed": "return minRatioPositions.get(0);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1106/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:08:27.307126345 -0500\n@@ -101,7 +101,6 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n@@ -117,13 +116,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 06:29:45.307620212 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1106/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 07:08:27.311126329 -0500\n@@ -174,7 +174,8 @@\n         for (int i = 0; i < len; i++) {\n             final Localizable pat = msgPatterns.get(i);\n             final Object[] args = msgArguments.get(i);\n-            final MessageFormat fmt = new MessageFormat(pat.getLocalizedString(locale),\n+            msgPatterns.add(pat);\n+\t\t\tfinal MessageFormat fmt = new MessageFormat(pat.getLocalizedString(locale),\n                                                         locale);\n             sb.append(fmt.format(args));\n             if (++count < len) {\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Delete", 
          "seed": "if (!Precision.equals(entry,0d,maxUlps)) {\n  return null;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java", 
          "line": 177, 
          "faulty": "final MessageFormat fmt=new MessageFormat(pat.getLocalizedString(locale),locale);", 
          "type": "InsertBefore", 
          "seed": "msgPatterns.add(pat);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "incrementIterationsCounter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_102/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:57:03.553872172 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/AbstractLinearOptimizer.java\t2018-12-01 06:29:45.579618752 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_102/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/AbstractLinearOptimizer.java\t2018-12-01 06:57:03.557872156 -0500\n@@ -125,7 +125,10 @@\n     protected void incrementIterationsCounter()\n         throws MaxCountExceededException {\n         if (++iterations > maxIterations) {\n-            throw new MaxCountExceededException(maxIterations);\n+            if (++iterations > maxIterations) {\n+\t\t\t\tthrow new MaxCountExceededException(maxIterations);\n+\t\t\t}\n+\t\t\tthrow new MaxCountExceededException(maxIterations);\n         }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/AbstractLinearOptimizer.java", 
          "line": 128, 
          "faulty": "throw new MaxCountExceededException(maxIterations);", 
          "type": "InsertBefore", 
          "seed": "if (++iterations > maxIterations) {\n  throw new MaxCountExceededException(maxIterations);\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "doIteration(tableau);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 124, 
          "faulty": "return row;", 
          "type": "InsertBefore", 
          "seed": "this.maxUlps=maxUlps;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 121, 
          "faulty": "int column=i + tableau.getArtificialVariableOffset();", 
          "type": "InsertBefore", 
          "seed": "tableau.dropPhase1Objective();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_509/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:01:20.284836668 -0500\n@@ -101,7 +101,6 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n@@ -120,9 +119,6 @@\n                     for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                         int column = i + tableau.getArtificialVariableOffset();\n                         final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n                     }\n                 }\n \n@@ -141,10 +137,6 @@\n                     int i = tableau.getNumObjectiveFunctions();\n                     for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n                         if (row == tableau.getBasicRow(i)) {\n-                            if (i < minIndex) {\n-                                minIndex = i;\n-                                minRow = row;\n-                            }\n                         }\n                     }\n                 }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Delete", 
          "seed": "throw new NoFeasibleSolutionException();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 144, 
          "faulty": "if (i < minIndex) {\n  minIndex=i;\n  minRow=row;\n}", 
          "type": "Delete", 
          "seed": "while (!tableau.isOptimal()) {\n  doIteration(tableau);\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 123, 
          "faulty": "if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n  return row;\n}", 
          "type": "Delete", 
          "seed": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 124, 
          "faulty": "return row;", 
          "type": "InsertBefore", 
          "seed": "incrementIterationsCounter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_466/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:00:55.796935861 -0500\n@@ -101,7 +101,6 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n@@ -121,7 +120,6 @@\n                         int column = i + tableau.getArtificialVariableOffset();\n                         final double entry = tableau.getEntry(row, column);\n                         if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n                         }\n                     }\n                 }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Delete", 
          "seed": "if (!Precision.equals(entry,0d,maxUlps)) {\n  return null;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 124, 
          "faulty": "return row;", 
          "type": "Delete", 
          "seed": "incrementIterationsCounter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1583/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:13:31.413931572 -0500\n@@ -115,17 +115,6 @@\n         } else if (minRatioPositions.size() > 1) {\n             // there's a degeneracy as indicated by a tie in the minimum ratio test\n \n-            // 1. check if there's an artificial variable that can be forced out of the basis\n-                for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n-                }\n-\n             // 2. apply Bland's rule to prevent cycling:\n             //    take the row for which the corresponding basic variable has the smallest index\n             //\n\n\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 119, 
          "faulty": "for (Integer row : minRatioPositions) {\n  for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n    int column=i + tableau.getArtificialVariableOffset();\n    final double entry=tableau.getEntry(row,column);\n    if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n      return row;\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "minRatioPositions=new ArrayList<Integer>();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java", 
          "line": 147, 
          "faulty": "return buildMessage(locale,\": \");", 
          "type": "Replace", 
          "seed": "return buildMessage(locale,\": \");"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_498/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:01:15.744855008 -0500\n@@ -115,17 +115,6 @@\n         } else if (minRatioPositions.size() > 1) {\n             // there's a degeneracy as indicated by a tie in the minimum ratio test\n \n-            // 1. check if there's an artificial variable that can be forced out of the basis\n-                for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n-                }\n-\n             // 2. apply Bland's rule to prevent cycling:\n             //    take the row for which the corresponding basic variable has the smallest index\n             //\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 119, 
          "faulty": "for (Integer row : minRatioPositions) {\n  for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n    int column=i + tableau.getArtificialVariableOffset();\n    final double entry=tableau.getEntry(row,column);\n    if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n      return row;\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "for (Integer row : minRatioPositions) {\n  for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n    int column=i + tableau.getArtificialVariableOffset();\n    final double entry=tableau.getEntry(row,column);\n    if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n      return row;\n    }\n  }\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 123, 
          "faulty": "if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n  return row;\n}", 
          "type": "Delete", 
          "seed": "minRatioPositions=new ArrayList<Integer>();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_201/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:58:03.093639352 -0500\n@@ -115,16 +115,7 @@\n         } else if (minRatioPositions.size() > 1) {\n             // there's a degeneracy as indicated by a tie in the minimum ratio test\n \n-            // 1. check if there's an artificial variable that can be forced out of the basis\n-                for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n-                }\n+            setMaxIterations(DEFAULT_MAX_ITERATIONS);\n \n             // 2. apply Bland's rule to prevent cycling:\n             //    take the row for which the corresponding basic variable has the smallest index\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 122, 
          "faulty": "final double entry=tableau.getEntry(row,column);", 
          "type": "InsertBefore", 
          "seed": "if (minRatioPositions.size() == 0) {\n  return null;\n}\n else if (minRatioPositions.size() > 1) {\n  for (  Integer row : minRatioPositions) {\n    for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n      int column=i + tableau.getArtificialVariableOffset();\n      final double entry=tableau.getEntry(row,column);\n      if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n        return row;\n      }\n    }\n  }\n  Integer minRow=null;\n  int minIndex=tableau.getWidth();\n  for (  Integer row : minRatioPositions) {\n    int i=tableau.getNumObjectiveFunctions();\n    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n      if (row == tableau.getBasicRow(i)) {\n        if (i < minIndex) {\n          minIndex=i;\n          minRow=row;\n        }\n      }\n    }\n  }\n  return minRow;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 119, 
          "faulty": "for (Integer row : minRatioPositions) {\n  for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n    int column=i + tableau.getArtificialVariableOffset();\n    final double entry=tableau.getEntry(row,column);\n    if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n      return row;\n    }\n  }\n}", 
          "type": "Replace", 
          "seed": "setMaxIterations(DEFAULT_MAX_ITERATIONS);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_217/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:58:16.965585966 -0500\n@@ -119,7 +119,7 @@\n                 for (Integer row : minRatioPositions) {\n                     for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                         int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n+                        final double entry = tableau.getEntry(i, col);\n                         if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n                             return row;\n                         }\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 06:29:45.307620212 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_217/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 06:58:16.965585966 -0500\n@@ -134,7 +134,8 @@\n      * @return the localized message.\n      */\n     public String getLocalizedMessage() {\n-        return getMessage(Locale.getDefault());\n+        context = new HashMap<String, Object>();\n+\t\treturn getMessage(Locale.getDefault());\n     }\n \n     /**\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 122, 
          "faulty": "final double entry=tableau.getEntry(row,column);", 
          "type": "Replace", 
          "seed": "final double entry=tableau.getEntry(i,col);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java", 
          "line": 137, 
          "faulty": "return getMessage(Locale.getDefault());", 
          "type": "InsertBefore", 
          "seed": "context=new HashMap<String,Object>();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_775/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:04:25.964103621 -0500\n@@ -119,7 +119,7 @@\n                 for (Integer row : minRatioPositions) {\n                     for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                         int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n+                        final double entry = tableau.getEntry(i, col);\n                         if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n                             return row;\n                         }\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/AbstractLinearOptimizer.java\t2018-12-01 06:29:45.579618752 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_775/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/AbstractLinearOptimizer.java\t2018-12-01 07:04:25.968103605 -0500\n@@ -125,7 +125,10 @@\n     protected void incrementIterationsCounter()\n         throws MaxCountExceededException {\n         if (++iterations > maxIterations) {\n-            throw new MaxCountExceededException(maxIterations);\n+            if (++iterations > maxIterations) {\n+\t\t\t\tthrow new MaxCountExceededException(maxIterations);\n+\t\t\t}\n+\t\t\tthrow new MaxCountExceededException(maxIterations);\n         }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 122, 
          "faulty": "final double entry=tableau.getEntry(row,column);", 
          "type": "Replace", 
          "seed": "final double entry=tableau.getEntry(i,col);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/AbstractLinearOptimizer.java", 
          "line": 128, 
          "faulty": "throw new MaxCountExceededException(maxIterations);", 
          "type": "InsertBefore", 
          "seed": "if (++iterations > maxIterations) {\n  throw new MaxCountExceededException(maxIterations);\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_781/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:04:29.260090874 -0500\n@@ -115,17 +115,6 @@\n         } else if (minRatioPositions.size() > 1) {\n             // there's a degeneracy as indicated by a tie in the minimum ratio test\n \n-            // 1. check if there's an artificial variable that can be forced out of the basis\n-                for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n-                }\n-\n             // 2. apply Bland's rule to prevent cycling:\n             //    take the row for which the corresponding basic variable has the smallest index\n             //\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 06:29:45.307620212 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_781/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 07:04:29.260090874 -0500\n@@ -125,7 +125,8 @@\n      * @return the message.\n      */\n     public String getMessage() {\n-        return getMessage(Locale.US);\n+        context = new HashMap<String, Object>();\n+\t\treturn getMessage(Locale.US);\n     }\n \n     /**\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java", 
          "line": 128, 
          "faulty": "return getMessage(Locale.US);", 
          "type": "InsertBefore", 
          "seed": "context=new HashMap<String,Object>();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 119, 
          "faulty": "for (Integer row : minRatioPositions) {\n  for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n    int column=i + tableau.getArtificialVariableOffset();\n    final double entry=tableau.getEntry(row,column);\n    if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n      return row;\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "if (minRatioPositions.size() == 0) {\n  return null;\n}\n else if (minRatioPositions.size() > 1) {\n  for (  Integer row : minRatioPositions) {\n    for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n      int column=i + tableau.getArtificialVariableOffset();\n      final double entry=tableau.getEntry(row,column);\n      if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n        return row;\n      }\n    }\n  }\n  Integer minRow=null;\n  int minIndex=tableau.getWidth();\n  for (  Integer row : minRatioPositions) {\n    int i=tableau.getNumObjectiveFunctions();\n    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n      if (row == tableau.getBasicRow(i)) {\n        if (i < minIndex) {\n          minIndex=i;\n          minRow=row;\n        }\n      }\n    }\n  }\n  return minRow;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "continue;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/LocalizedFormats.java\t2018-12-01 06:29:45.555618881 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_318/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/LocalizedFormats.java\t2018-12-01 06:59:28.221296418 -0500\n@@ -387,8 +387,6 @@\n             // do nothing here\n         }\n \n-        // either the locale is not supported or the resource is unknown\n-        // don't translate and fall back to using the source format\n         return sourceFormat;\n \n     }\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_318/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:59:28.221296418 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 122, 
          "faulty": "final double entry=tableau.getEntry(row,column);", 
          "type": "Replace", 
          "seed": "final double entry=tableau.getEntry(i,col);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "continue;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/util/LocalizedFormats.java", 
          "line": 392, 
          "faulty": "return sourceFormat;", 
          "type": "Replace", 
          "seed": "return sourceFormat;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1580/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:13:30.185936583 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/AbstractLinearOptimizer.java\t2018-12-01 06:29:45.579618752 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1580/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/AbstractLinearOptimizer.java\t2018-12-01 07:13:30.185936583 -0500\n@@ -125,7 +125,8 @@\n     protected void incrementIterationsCounter()\n         throws MaxCountExceededException {\n         if (++iterations > maxIterations) {\n-            throw new MaxCountExceededException(maxIterations);\n+            setMaxIterations(DEFAULT_MAX_ITERATIONS);\n+\t\t\tthrow new MaxCountExceededException(maxIterations);\n         }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 122, 
          "faulty": "final double entry=tableau.getEntry(row,column);", 
          "type": "Replace", 
          "seed": "final double entry=tableau.getEntry(i,col);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/AbstractLinearOptimizer.java", 
          "line": 128, 
          "faulty": "throw new MaxCountExceededException(maxIterations);", 
          "type": "InsertBefore", 
          "seed": "setMaxIterations(DEFAULT_MAX_ITERATIONS);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "continue;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_390/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:00:14.273105637 -0500\n@@ -101,7 +101,6 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n@@ -140,12 +139,6 @@\n                 for (Integer row : minRatioPositions) {\n                     int i = tableau.getNumObjectiveFunctions();\n                     for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n-                        if (row == tableau.getBasicRow(i)) {\n-                            if (i < minIndex) {\n-                                minIndex = i;\n-                                minRow = row;\n-                            }\n-                        }\n                     }\n                 }\n                 return minRow;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Delete", 
          "seed": "throw new NoFeasibleSolutionException();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 143, 
          "faulty": "if (row == tableau.getBasicRow(i)) {\n  if (i < minIndex) {\n    minIndex=i;\n    minRow=row;\n  }\n}", 
          "type": "Delete", 
          "seed": "this.epsilon=epsilon;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_249/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:58:40.513495995 -0500\n@@ -121,7 +121,6 @@\n                         int column = i + tableau.getArtificialVariableOffset();\n                         final double entry = tableau.getEntry(row, column);\n                         if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n                         }\n                     }\n                 }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 124, 
          "faulty": "return row;", 
          "type": "Delete", 
          "seed": "doIteration(tableau);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_879/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:05:39.083803972 -0500\n@@ -101,7 +101,6 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n@@ -115,17 +114,6 @@\n         } else if (minRatioPositions.size() > 1) {\n             // there's a degeneracy as indicated by a tie in the minimum ratio test\n \n-            // 1. check if there's an artificial variable that can be forced out of the basis\n-                for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n-                }\n-\n             // 2. apply Bland's rule to prevent cycling:\n             //    take the row for which the corresponding basic variable has the smallest index\n             //\n@@ -139,14 +127,6 @@\n                 int minIndex = tableau.getWidth();\n                 for (Integer row : minRatioPositions) {\n                     int i = tableau.getNumObjectiveFunctions();\n-                    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n-                        if (row == tableau.getBasicRow(i)) {\n-                            if (i < minIndex) {\n-                                minIndex = i;\n-                                minRow = row;\n-                            }\n-                        }\n-                    }\n                 }\n                 return minRow;\n         }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 119, 
          "faulty": "for (Integer row : minRatioPositions) {\n  for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n    int column=i + tableau.getArtificialVariableOffset();\n    final double entry=tableau.getEntry(row,column);\n    if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n      return row;\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "tableau.dropPhase1Objective();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Delete", 
          "seed": "incrementIterationsCounter();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 142, 
          "faulty": "for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n  if (row == tableau.getBasicRow(i)) {\n    if (i < minIndex) {\n      minIndex=i;\n      minRow=row;\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return minRow;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1236/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:09:41.722834788 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "doIteration(tableau);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java", 
          "line": 86, 
          "faulty": "return context.getLocalizedMessage();", 
          "type": "Replace", 
          "seed": "return context.getLocalizedMessage();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1072/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:08:07.235205764 -0500\n@@ -119,9 +119,9 @@\n                 for (Integer row : minRatioPositions) {\n                     for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                         int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n+                        final double entry = tableau.getEntry(i, col);\n                         if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n+                            return minRatioPositions.get(0);\n                         }\n                     }\n                 }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 122, 
          "faulty": "final double entry=tableau.getEntry(row,column);", 
          "type": "Replace", 
          "seed": "final double entry=tableau.getEntry(i,col);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 124, 
          "faulty": "return row;", 
          "type": "Replace", 
          "seed": "return minRatioPositions.get(0);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_279/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:58:55.897432020 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 06:29:45.307620212 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_279/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 06:58:55.901432003 -0500\n@@ -176,7 +176,8 @@\n             final Object[] args = msgArguments.get(i);\n             final MessageFormat fmt = new MessageFormat(pat.getLocalizedString(locale),\n                                                         locale);\n-            sb.append(fmt.format(args));\n+            this.throwable = throwable;\n+\t\t\tsb.append(fmt.format(args));\n             if (++count < len) {\n                 // Add a separator if there are other messages.\n                 sb.append(separator);\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "continue;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java", 
          "line": 179, 
          "faulty": "sb.append(fmt.format(args));", 
          "type": "InsertBefore", 
          "seed": "this.throwable=throwable;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_791/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:04:34.300071397 -0500\n@@ -101,7 +101,6 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n@@ -137,7 +136,24 @@\n             // This heuristic is based on empirical data gathered while investigating MATH-828.\n                 Integer minRow = null;\n                 int minIndex = tableau.getWidth();\n-                for (Integer row : minRatioPositions) {\n+                for (int i = tableau.getNumObjectiveFunctions(); i < tableau\n+\t\t\t\t\t\t.getHeight(); i++) {\n+\t\t\t\t\tfinal double rhs = tableau.getEntry(i,\n+\t\t\t\t\t\t\ttableau.getWidth() - 1);\n+\t\t\t\t\tfinal double entry = tableau.getEntry(i, col);\n+\t\t\t\t\tif (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n+\t\t\t\t\t\tfinal double ratio = rhs / entry;\n+\t\t\t\t\t\tfinal int cmp = Double.compare(ratio, minRatio);\n+\t\t\t\t\t\tif (cmp == 0) {\n+\t\t\t\t\t\t\tminRatioPositions.add(i);\n+\t\t\t\t\t\t} else if (cmp < 0) {\n+\t\t\t\t\t\t\tminRatio = ratio;\n+\t\t\t\t\t\t\tminRatioPositions = new ArrayList<Integer>();\n+\t\t\t\t\t\t\tminRatioPositions.add(i);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tfor (Integer row : minRatioPositions) {\n                     int i = tableau.getNumObjectiveFunctions();\n                     for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n                         if (row == tableau.getBasicRow(i)) {\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Delete", 
          "seed": "incrementIterationsCounter();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 140, 
          "faulty": "for (Integer row : minRatioPositions) {\n  int i=tableau.getNumObjectiveFunctions();\n  for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n    if (row == tableau.getBasicRow(i)) {\n      if (i < minIndex) {\n        minIndex=i;\n        minRow=row;\n      }\n    }\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "for (int i=tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n  final double rhs=tableau.getEntry(i,tableau.getWidth() - 1);\n  final double entry=tableau.getEntry(i,col);\n  if (Precision.compareTo(entry,0d,maxUlps) > 0) {\n    final double ratio=rhs / entry;\n    final int cmp=Double.compare(ratio,minRatio);\n    if (cmp == 0) {\n      minRatioPositions.add(i);\n    }\n else     if (cmp < 0) {\n      minRatio=ratio;\n      minRatioPositions=new ArrayList<Integer>();\n      minRatioPositions.add(i);\n    }\n  }\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_208/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:58:06.333626857 -0500\n@@ -101,7 +101,6 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n@@ -143,7 +142,6 @@\n                         if (row == tableau.getBasicRow(i)) {\n                             if (i < minIndex) {\n                                 minIndex = i;\n-                                minRow = row;\n                             }\n                         }\n                     }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Delete", 
          "seed": "incrementIterationsCounter();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 146, 
          "faulty": "minRow=row;", 
          "type": "Delete", 
          "seed": "throw new NoFeasibleSolutionException();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_375/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:00:06.589137282 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 122, 
          "faulty": "final double entry=tableau.getEntry(row,column);", 
          "type": "InsertBefore", 
          "seed": "if (minRatioPositions.size() > 1) {\n  for (  Integer row : minRatioPositions) {\n    for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n      int column=i + tableau.getArtificialVariableOffset();\n      final double entry=tableau.getEntry(row,column);\n      if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n        return row;\n      }\n    }\n  }\n  Integer minRow=null;\n  int minIndex=tableau.getWidth();\n  for (  Integer row : minRatioPositions) {\n    int i=tableau.getNumObjectiveFunctions();\n    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n      if (row == tableau.getBasicRow(i)) {\n        if (i < minIndex) {\n          minIndex=i;\n          minRow=row;\n        }\n      }\n    }\n  }\n  return minRow;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "continue;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_409/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:00:23.817066433 -0500\n@@ -115,17 +115,6 @@\n         } else if (minRatioPositions.size() > 1) {\n             // there's a degeneracy as indicated by a tie in the minimum ratio test\n \n-            // 1. check if there's an artificial variable that can be forced out of the basis\n-                for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n-                }\n-\n             // 2. apply Bland's rule to prevent cycling:\n             //    take the row for which the corresponding basic variable has the smallest index\n             //\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 122, 
          "faulty": "final double entry=tableau.getEntry(row,column);", 
          "type": "Replace", 
          "seed": "final double entry=tableau.getEntry(i,col);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 119, 
          "faulty": "for (Integer row : minRatioPositions) {\n  for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n    int column=i + tableau.getArtificialVariableOffset();\n    final double entry=tableau.getEntry(row,column);\n    if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n      return row;\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "setMaxIterations(DEFAULT_MAX_ITERATIONS);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "incrementIterationsCounter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_301/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:59:13.697357169 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java", 
          "line": 128, 
          "faulty": "return getMessage(Locale.US);", 
          "type": "Replace", 
          "seed": "return getMessage(Locale.US);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "tableau.dropPhase1Objective();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_298/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:59:12.341362855 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "if (minRatioPositions.size() > 1) {\n  for (  Integer row : minRatioPositions) {\n    for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n      int column=i + tableau.getArtificialVariableOffset();\n      final double entry=tableau.getEntry(row,column);\n      if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n        return row;\n      }\n    }\n  }\n  Integer minRow=null;\n  int minIndex=tableau.getWidth();\n  for (  Integer row : minRatioPositions) {\n    int i=tableau.getNumObjectiveFunctions();\n    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n      if (row == tableau.getBasicRow(i)) {\n        if (i < minIndex) {\n          minIndex=i;\n          minRow=row;\n        }\n      }\n    }\n  }\n  return minRow;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 124, 
          "faulty": "return row;", 
          "type": "InsertBefore", 
          "seed": "doIteration(tableau);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1489/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:12:29.150183180 -0500\n@@ -101,7 +101,6 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n@@ -117,13 +116,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 06:29:45.307620212 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1489/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 07:12:29.154183164 -0500\n@@ -134,7 +134,8 @@\n      * @return the localized message.\n      */\n     public String getLocalizedMessage() {\n-        return getMessage(Locale.getDefault());\n+        context = new HashMap<String, Object>();\n+\t\treturn getMessage(Locale.getDefault());\n     }\n \n     /**\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Delete", 
          "seed": "if (!Precision.equals(entry,0d,maxUlps)) {\n  return null;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "tableau.dropPhase1Objective();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java", 
          "line": 137, 
          "faulty": "return getMessage(Locale.getDefault());", 
          "type": "InsertBefore", 
          "seed": "context=new HashMap<String,Object>();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_440/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:00:40.608997723 -0500\n@@ -115,17 +115,6 @@\n         } else if (minRatioPositions.size() > 1) {\n             // there's a degeneracy as indicated by a tie in the minimum ratio test\n \n-            // 1. check if there's an artificial variable that can be forced out of the basis\n-                for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n-                }\n-\n             // 2. apply Bland's rule to prevent cycling:\n             //    take the row for which the corresponding basic variable has the smallest index\n             //\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 119, 
          "faulty": "for (Integer row : minRatioPositions) {\n  for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n    int column=i + tableau.getArtificialVariableOffset();\n    final double entry=tableau.getEntry(row,column);\n    if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n      return row;\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "setMaxIterations(DEFAULT_MAX_ITERATIONS);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 124, 
          "faulty": "return row;", 
          "type": "Delete", 
          "seed": "incrementIterationsCounter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_121/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:57:13.905831227 -0500\n@@ -119,7 +119,7 @@\n                 for (Integer row : minRatioPositions) {\n                     for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                         int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n+                        final double entry = tableau.getEntry(i, col);\n                         if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n                             return row;\n                         }\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 06:29:45.307620212 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_121/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 06:57:13.905831227 -0500\n@@ -134,7 +134,7 @@\n      * @return the localized message.\n      */\n     public String getLocalizedMessage() {\n-        return getMessage(Locale.getDefault());\n+        return getMessage(Locale.US);\n     }\n \n     /**\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 122, 
          "faulty": "final double entry=tableau.getEntry(row,column);", 
          "type": "Replace", 
          "seed": "final double entry=tableau.getEntry(i,col);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java", 
          "line": 137, 
          "faulty": "return getMessage(Locale.getDefault());", 
          "type": "Replace", 
          "seed": "return getMessage(Locale.US);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_16/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:55:53.638154789 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/AbstractLinearOptimizer.java", 
          "line": 128, 
          "faulty": "throw new MaxCountExceededException(maxIterations);", 
          "type": "Replace", 
          "seed": "throw new MaxCountExceededException(maxIterations);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "incrementIterationsCounter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1114/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:08:31.123111285 -0500\n@@ -115,17 +115,6 @@\n         } else if (minRatioPositions.size() > 1) {\n             // there's a degeneracy as indicated by a tie in the minimum ratio test\n \n-            // 1. check if there's an artificial variable that can be forced out of the basis\n-                for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n-                }\n-\n             // 2. apply Bland's rule to prevent cycling:\n             //    take the row for which the corresponding basic variable has the smallest index\n             //\n\n\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java", 
          "line": 128, 
          "faulty": "return getMessage(Locale.US);", 
          "type": "Replace", 
          "seed": "return getMessage(Locale.US);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 119, 
          "faulty": "for (Integer row : minRatioPositions) {\n  for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n    int column=i + tableau.getArtificialVariableOffset();\n    final double entry=tableau.getEntry(row,column);\n    if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n      return row;\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "setMaxIterations(DEFAULT_MAX_ITERATIONS);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 124, 
          "faulty": "return row;", 
          "type": "Replace", 
          "seed": "return minRatioPositions.get(0);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1143/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:08:47.915045160 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n@@ -224,7 +217,8 @@\n         tableau.dropPhase1Objective();\n \n         while (!tableau.isOptimal()) {\n-            doIteration(tableau);\n+            incrementIterationsCounter();\n+\t\t\tdoIteration(tableau);\n         }\n         return tableau.getSolution();\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 122, 
          "faulty": "final double entry=tableau.getEntry(row,column);", 
          "type": "Replace", 
          "seed": "final double entry=tableau.getEntry(i,col);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "incrementIterationsCounter();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 227, 
          "faulty": "doIteration(tableau);", 
          "type": "InsertBefore", 
          "seed": "incrementIterationsCounter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1586/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:13:32.649926531 -0500\n@@ -101,7 +101,6 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n@@ -117,13 +116,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n@@ -141,10 +133,6 @@\n                     int i = tableau.getNumObjectiveFunctions();\n                     for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n                         if (row == tableau.getBasicRow(i)) {\n-                            if (i < minIndex) {\n-                                minIndex = i;\n-                                minRow = row;\n-                            }\n                         }\n                     }\n                 }\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 06:29:45.307620212 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1586/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 07:13:32.653926515 -0500\n@@ -174,7 +174,8 @@\n         for (int i = 0; i < len; i++) {\n             final Localizable pat = msgPatterns.get(i);\n             final Object[] args = msgArguments.get(i);\n-            final MessageFormat fmt = new MessageFormat(pat.getLocalizedString(locale),\n+            msgPatterns.add(pat);\n+\t\t\tfinal MessageFormat fmt = new MessageFormat(pat.getLocalizedString(locale),\n                                                         locale);\n             sb.append(fmt.format(args));\n             if (++count < len) {\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Delete", 
          "seed": "throw new NoFeasibleSolutionException();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java", 
          "line": 177, 
          "faulty": "final MessageFormat fmt=new MessageFormat(pat.getLocalizedString(locale),locale);", 
          "type": "InsertBefore", 
          "seed": "msgPatterns.add(pat);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 144, 
          "faulty": "if (i < minIndex) {\n  minIndex=i;\n  minRow=row;\n}", 
          "type": "Delete", 
          "seed": "row=i;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "continue;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_984/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:06:40.323553950 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "if (minRatioPositions.size() > 1) {\n  for (  Integer row : minRatioPositions) {\n    for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n      int column=i + tableau.getArtificialVariableOffset();\n      final double entry=tableau.getEntry(row,column);\n      if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n        return row;\n      }\n    }\n  }\n  Integer minRow=null;\n  int minIndex=tableau.getWidth();\n  for (  Integer row : minRatioPositions) {\n    int i=tableau.getNumObjectiveFunctions();\n    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n      if (row == tableau.getBasicRow(i)) {\n        if (i < minIndex) {\n          minIndex=i;\n          minRow=row;\n        }\n      }\n    }\n  }\n  return minRow;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 123, 
          "faulty": "if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n  return row;\n}", 
          "type": "InsertBefore", 
          "seed": "this.epsilon=epsilon;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1265/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:09:57.722772654 -0500\n@@ -101,7 +101,6 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n@@ -148,7 +147,6 @@\n                         }\n                     }\n                 }\n-                return minRow;\n         }\n         return minRatioPositions.get(0);\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 151, 
          "faulty": "return minRow;", 
          "type": "Delete", 
          "seed": "incrementIterationsCounter();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Delete", 
          "seed": "if (!Precision.equals(entry,0d,maxUlps)) {\n  return null;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_589/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:02:03.988661228 -0500\n@@ -142,7 +142,6 @@\n                     for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n                         if (row == tableau.getBasicRow(i)) {\n                             if (i < minIndex) {\n-                                minIndex = i;\n                                 minRow = row;\n                             }\n                         }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 145, 
          "faulty": "minIndex=i;", 
          "type": "Delete", 
          "seed": "this.epsilon=epsilon;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1499/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:12:40.274138166 -0500\n@@ -101,7 +101,6 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n@@ -119,7 +118,7 @@\n                 for (Integer row : minRatioPositions) {\n                     for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                         int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n+                        final double entry = tableau.getEntry(i, col);\n                         if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n                             return row;\n                         }\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 06:29:45.307620212 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1499/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 07:12:40.274138166 -0500\n@@ -170,7 +170,8 @@\n                                 String separator) {\n         final StringBuilder sb = new StringBuilder();\n         int count = 0;\n-        final int len = msgPatterns.size();\n+        context = new HashMap<String, Object>();\n+\t\tfinal int len = msgPatterns.size();\n         for (int i = 0; i < len; i++) {\n             final Localizable pat = msgPatterns.get(i);\n             final Object[] args = msgArguments.get(i);\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 122, 
          "faulty": "final double entry=tableau.getEntry(row,column);", 
          "type": "Replace", 
          "seed": "final double entry=tableau.getEntry(i,col);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Delete", 
          "seed": "if (!Precision.equals(entry,0d,maxUlps)) {\n  return null;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java", 
          "line": 173, 
          "faulty": "final int len=msgPatterns.size();", 
          "type": "InsertBefore", 
          "seed": "context=new HashMap<String,Object>();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_632/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:02:40.700515330 -0500\n@@ -115,17 +115,6 @@\n         } else if (minRatioPositions.size() > 1) {\n             // there's a degeneracy as indicated by a tie in the minimum ratio test\n \n-            // 1. check if there's an artificial variable that can be forced out of the basis\n-                for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n-                }\n-\n             // 2. apply Bland's rule to prevent cycling:\n             //    take the row for which the corresponding basic variable has the smallest index\n             //\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 119, 
          "faulty": "for (Integer row : minRatioPositions) {\n  for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n    int column=i + tableau.getArtificialVariableOffset();\n    final double entry=tableau.getEntry(row,column);\n    if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n      return row;\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "for (int i=tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n  final double rhs=tableau.getEntry(i,tableau.getWidth() - 1);\n  final double entry=tableau.getEntry(i,col);\n  if (Precision.compareTo(entry,0d,maxUlps) > 0) {\n    final double ratio=rhs / entry;\n    final int cmp=Double.compare(ratio,minRatio);\n    if (cmp == 0) {\n      minRatioPositions.add(i);\n    }\n else     if (cmp < 0) {\n      minRatio=ratio;\n      minRatioPositions=new ArrayList<Integer>();\n      minRatioPositions.add(i);\n    }\n  }\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 124, 
          "faulty": "return row;", 
          "type": "Replace", 
          "seed": "doIteration(tableau);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_857/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:05:20.679879953 -0500\n@@ -115,17 +115,6 @@\n         } else if (minRatioPositions.size() > 1) {\n             // there's a degeneracy as indicated by a tie in the minimum ratio test\n \n-            // 1. check if there's an artificial variable that can be forced out of the basis\n-                for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n-                }\n-\n             // 2. apply Bland's rule to prevent cycling:\n             //    take the row for which the corresponding basic variable has the smallest index\n             //\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 119, 
          "faulty": "for (Integer row : minRatioPositions) {\n  for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n    int column=i + tableau.getArtificialVariableOffset();\n    final double entry=tableau.getEntry(row,column);\n    if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n      return row;\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "setMaxIterations(DEFAULT_MAX_ITERATIONS);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 123, 
          "faulty": "if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n  return row;\n}", 
          "type": "InsertBefore", 
          "seed": "if (!Precision.equals(tableau.getEntry(0,tableau.getRhsOffset()),0d,epsilon)) {\n  throw new NoFeasibleSolutionException();\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 124, 
          "faulty": "return row;", 
          "type": "Delete", 
          "seed": "return minRatioPositions.get(0);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_46/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:56:12.866075922 -0500\n@@ -120,9 +120,6 @@\n                     for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                         int column = i + tableau.getArtificialVariableOffset();\n                         final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n                     }\n                 }\n \n@@ -139,14 +136,10 @@\n                 int minIndex = tableau.getWidth();\n                 for (Integer row : minRatioPositions) {\n                     int i = tableau.getNumObjectiveFunctions();\n-                    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n-                        if (row == tableau.getBasicRow(i)) {\n-                            if (i < minIndex) {\n-                                minIndex = i;\n-                                minRow = row;\n-                            }\n-                        }\n-                    }\n+                    if (i < minIndex) {\n+\t\t\t\t\t\tminIndex = i;\n+\t\t\t\t\t\tminRow = row;\n+\t\t\t\t\t}\n                 }\n                 return minRow;\n         }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 144, 
          "faulty": "if (i < minIndex) {\n  minIndex=i;\n  minRow=row;\n}", 
          "type": "Replace", 
          "seed": "doIteration(tableau);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 142, 
          "faulty": "for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n  if (row == tableau.getBasicRow(i)) {\n    if (i < minIndex) {\n      minIndex=i;\n      minRow=row;\n    }\n  }\n}", 
          "type": "Replace", 
          "seed": "if (i < minIndex) {\n  minIndex=i;\n  minRow=row;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 123, 
          "faulty": "if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n  return row;\n}", 
          "type": "Delete", 
          "seed": "incrementIterationsCounter();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 146, 
          "faulty": "minRow=row;", 
          "type": "Replace", 
          "seed": "for (Integer row : minRatioPositions) {\n  int i=tableau.getNumObjectiveFunctions();\n  for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n    if (row == tableau.getBasicRow(i)) {\n      if (i < minIndex) {\n        minIndex=i;\n        minRow=row;\n      }\n    }\n  }\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1468/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:12:12.046252634 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 06:29:45.307620212 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1468/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 07:12:12.046252634 -0500\n@@ -169,7 +169,8 @@\n     private String buildMessage(Locale locale,\n                                 String separator) {\n         final StringBuilder sb = new StringBuilder();\n-        int count = 0;\n+        this.throwable = throwable;\n+\t\tint count = 0;\n         final int len = msgPatterns.size();\n         for (int i = 0; i < len; i++) {\n             final Localizable pat = msgPatterns.get(i);\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "continue;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java", 
          "line": 172, 
          "faulty": "int count=0;", 
          "type": "InsertBefore", 
          "seed": "this.throwable=throwable;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1617/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:13:50.097855534 -0500\n@@ -148,7 +148,6 @@\n                         }\n                     }\n                 }\n-                return minRow;\n         }\n         return minRatioPositions.get(0);\n     }\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 06:29:45.307620212 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1617/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 07:13:50.097855534 -0500\n@@ -173,7 +173,8 @@\n         final int len = msgPatterns.size();\n         for (int i = 0; i < len; i++) {\n             final Localizable pat = msgPatterns.get(i);\n-            final Object[] args = msgArguments.get(i);\n+            this.throwable = throwable;\n+\t\t\tfinal Object[] args = msgArguments.get(i);\n             final MessageFormat fmt = new MessageFormat(pat.getLocalizedString(locale),\n                                                         locale);\n             sb.append(fmt.format(args));\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java\t2018-12-01 06:29:45.303620234 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1617/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java\t2018-12-01 07:13:50.097855534 -0500\n@@ -77,7 +77,7 @@\n     /** {@inheritDoc} */\n     @Override\n     public String getMessage() {\n-        return context.getMessage();\n+        return context.getLocalizedMessage();\n     }\n \n     /** {@inheritDoc} */\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 151, 
          "faulty": "return minRow;", 
          "type": "Delete", 
          "seed": "while (!tableau.isOptimal()) {\n  doIteration(tableau);\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java", 
          "line": 176, 
          "faulty": "final Object[] args=msgArguments.get(i);", 
          "type": "InsertBefore", 
          "seed": "this.throwable=throwable;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java", 
          "line": 80, 
          "faulty": "return context.getMessage();", 
          "type": "Replace", 
          "seed": "return context.getLocalizedMessage();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1277/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:10:10.174724425 -0500\n@@ -101,7 +101,6 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n@@ -117,13 +116,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Delete", 
          "seed": "return minRatioPositions.get(0);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "return row;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java", 
          "line": 80, 
          "faulty": "return context.getMessage();", 
          "type": "Replace", 
          "seed": "return context.getMessage();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_283/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:59:03.229401133 -0500\n@@ -101,7 +101,6 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n@@ -117,13 +116,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Delete", 
          "seed": "throw new NoFeasibleSolutionException();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "doIteration(tableau);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 124, 
          "faulty": "return row;", 
          "type": "Replace", 
          "seed": "return minRatioPositions.get(0);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1355/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:10:58.810537055 -0500\n@@ -101,7 +101,6 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n@@ -115,16 +114,7 @@\n         } else if (minRatioPositions.size() > 1) {\n             // there's a degeneracy as indicated by a tie in the minimum ratio test\n \n-            // 1. check if there's an artificial variable that can be forced out of the basis\n-                for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n-                }\n+            minRatioPositions = new ArrayList<Integer>();\n \n             // 2. apply Bland's rule to prevent cycling:\n             //    take the row for which the corresponding basic variable has the smallest index\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 119, 
          "faulty": "for (Integer row : minRatioPositions) {\n  for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n    int column=i + tableau.getArtificialVariableOffset();\n    final double entry=tableau.getEntry(row,column);\n    if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n      return row;\n    }\n  }\n}", 
          "type": "Replace", 
          "seed": "minRatioPositions=new ArrayList<Integer>();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Delete", 
          "seed": "if (!Precision.equals(entry,0d,maxUlps)) {\n  return null;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_166/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:57:43.833713983 -0500\n@@ -115,17 +115,6 @@\n         } else if (minRatioPositions.size() > 1) {\n             // there's a degeneracy as indicated by a tie in the minimum ratio test\n \n-            // 1. check if there's an artificial variable that can be forced out of the basis\n-                for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n-                }\n-\n             // 2. apply Bland's rule to prevent cycling:\n             //    take the row for which the corresponding basic variable has the smallest index\n             //\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 06:29:45.307620212 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_166/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 06:57:43.837713968 -0500\n@@ -134,7 +134,7 @@\n      * @return the localized message.\n      */\n     public String getLocalizedMessage() {\n-        return getMessage(Locale.getDefault());\n+        return getMessage(Locale.US);\n     }\n \n     /**\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 119, 
          "faulty": "for (Integer row : minRatioPositions) {\n  for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n    int column=i + tableau.getArtificialVariableOffset();\n    final double entry=tableau.getEntry(row,column);\n    if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n      return row;\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "setMaxIterations(DEFAULT_MAX_ITERATIONS);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java", 
          "line": 137, 
          "faulty": "return getMessage(Locale.getDefault());", 
          "type": "Replace", 
          "seed": "return getMessage(Locale.US);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1168/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:09:01.758990818 -0500\n@@ -101,7 +101,7 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n+                    return minRatioPositions.get(0);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n@@ -119,7 +119,7 @@\n                 for (Integer row : minRatioPositions) {\n                     for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                         int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n+                        final double entry = tableau.getEntry(i, col);\n                         if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n                             return row;\n                         }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 122, 
          "faulty": "final double entry=tableau.getEntry(row,column);", 
          "type": "Replace", 
          "seed": "final double entry=tableau.getEntry(i,col);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Replace", 
          "seed": "return minRatioPositions.get(0);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_764/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:04:20.312125499 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "continue;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java", 
          "line": 86, 
          "faulty": "return context.getLocalizedMessage();", 
          "type": "Replace", 
          "seed": "return context.getLocalizedMessage();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 124, 
          "faulty": "return row;", 
          "type": "InsertBefore", 
          "seed": "if (minRatioPositions.size() == 0) {\n  return null;\n}\n else if (minRatioPositions.size() > 1) {\n  for (  Integer row : minRatioPositions) {\n    for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n      int column=i + tableau.getArtificialVariableOffset();\n      final double entry=tableau.getEntry(row,column);\n      if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n        return row;\n      }\n    }\n  }\n  Integer minRow=null;\n  int minIndex=tableau.getWidth();\n  for (  Integer row : minRatioPositions) {\n    int i=tableau.getNumObjectiveFunctions();\n    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n      if (row == tableau.getBasicRow(i)) {\n        if (i < minIndex) {\n          minIndex=i;\n          minRow=row;\n        }\n      }\n    }\n  }\n  return minRow;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_235/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:58:32.673525861 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "incrementIterationsCounter();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 123, 
          "faulty": "if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n  return row;\n}", 
          "type": "InsertBefore", 
          "seed": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_438/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:00:39.961000369 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 06:29:45.307620212 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_438/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 07:00:39.965000352 -0500\n@@ -169,7 +169,8 @@\n     private String buildMessage(Locale locale,\n                                 String separator) {\n         final StringBuilder sb = new StringBuilder();\n-        int count = 0;\n+        context = new HashMap<String, Object>();\n+\t\tint count = 0;\n         final int len = msgPatterns.size();\n         for (int i = 0; i < len; i++) {\n             final Localizable pat = msgPatterns.get(i);\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "if (minRatioPositions.size() > 1) {\n  for (  Integer row : minRatioPositions) {\n    for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n      int column=i + tableau.getArtificialVariableOffset();\n      final double entry=tableau.getEntry(row,column);\n      if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n        return row;\n      }\n    }\n  }\n  Integer minRow=null;\n  int minIndex=tableau.getWidth();\n  for (  Integer row : minRatioPositions) {\n    int i=tableau.getNumObjectiveFunctions();\n    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n      if (row == tableau.getBasicRow(i)) {\n        if (i < minIndex) {\n          minIndex=i;\n          minRow=row;\n        }\n      }\n    }\n  }\n  return minRow;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java", 
          "line": 172, 
          "faulty": "int count=0;", 
          "type": "InsertBefore", 
          "seed": "context=new HashMap<String,Object>();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_251/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:58:41.173493485 -0500\n@@ -115,16 +115,7 @@\n         } else if (minRatioPositions.size() > 1) {\n             // there's a degeneracy as indicated by a tie in the minimum ratio test\n \n-            // 1. check if there's an artificial variable that can be forced out of the basis\n-                for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n-                }\n+            setMaxIterations(DEFAULT_MAX_ITERATIONS);\n \n             // 2. apply Bland's rule to prevent cycling:\n             //    take the row for which the corresponding basic variable has the smallest index\n@@ -148,7 +139,8 @@\n                         }\n                     }\n                 }\n-                return minRow;\n+                minRatioPositions = new ArrayList<Integer>();\n+\t\t\t\treturn minRow;\n         }\n         return minRatioPositions.get(0);\n     }\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 06:29:45.307620212 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_251/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 06:58:41.177493469 -0500\n@@ -134,7 +134,7 @@\n      * @return the localized message.\n      */\n     public String getLocalizedMessage() {\n-        return getMessage(Locale.getDefault());\n+        return getMessage(Locale.US);\n     }\n \n     /**\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 151, 
          "faulty": "return minRow;", 
          "type": "InsertBefore", 
          "seed": "minRatioPositions=new ArrayList<Integer>();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 119, 
          "faulty": "for (Integer row : minRatioPositions) {\n  for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n    int column=i + tableau.getArtificialVariableOffset();\n    final double entry=tableau.getEntry(row,column);\n    if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n      return row;\n    }\n  }\n}", 
          "type": "Replace", 
          "seed": "setMaxIterations(DEFAULT_MAX_ITERATIONS);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "doIteration(tableau);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java", 
          "line": 137, 
          "faulty": "return getMessage(Locale.getDefault());", 
          "type": "Replace", 
          "seed": "return getMessage(Locale.US);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 123, 
          "faulty": "if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n  return row;\n}", 
          "type": "Delete", 
          "seed": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1484/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:12:26.502193913 -0500\n@@ -101,7 +101,6 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n@@ -137,7 +136,24 @@\n             // This heuristic is based on empirical data gathered while investigating MATH-828.\n                 Integer minRow = null;\n                 int minIndex = tableau.getWidth();\n-                for (Integer row : minRatioPositions) {\n+                for (int i = tableau.getNumObjectiveFunctions(); i < tableau\n+\t\t\t\t\t\t.getHeight(); i++) {\n+\t\t\t\t\tfinal double rhs = tableau.getEntry(i,\n+\t\t\t\t\t\t\ttableau.getWidth() - 1);\n+\t\t\t\t\tfinal double entry = tableau.getEntry(i, col);\n+\t\t\t\t\tif (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n+\t\t\t\t\t\tfinal double ratio = rhs / entry;\n+\t\t\t\t\t\tfinal int cmp = Double.compare(ratio, minRatio);\n+\t\t\t\t\t\tif (cmp == 0) {\n+\t\t\t\t\t\t\tminRatioPositions.add(i);\n+\t\t\t\t\t\t} else if (cmp < 0) {\n+\t\t\t\t\t\t\tminRatio = ratio;\n+\t\t\t\t\t\t\tminRatioPositions = new ArrayList<Integer>();\n+\t\t\t\t\t\t\tminRatioPositions.add(i);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tfor (Integer row : minRatioPositions) {\n                     int i = tableau.getNumObjectiveFunctions();\n                     for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n                         if (row == tableau.getBasicRow(i)) {\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java\t2018-12-01 06:29:45.303620234 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1484/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java\t2018-12-01 07:12:26.506193897 -0500\n@@ -83,6 +83,6 @@\n     /** {@inheritDoc} */\n     @Override\n     public String getLocalizedMessage() {\n-        return context.getLocalizedMessage();\n+        return context.getMessage();\n     }\n }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Delete", 
          "seed": "incrementIterationsCounter();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 140, 
          "faulty": "for (Integer row : minRatioPositions) {\n  int i=tableau.getNumObjectiveFunctions();\n  for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n    if (row == tableau.getBasicRow(i)) {\n      if (i < minIndex) {\n        minIndex=i;\n        minRow=row;\n      }\n    }\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "for (int i=tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n  final double rhs=tableau.getEntry(i,tableau.getWidth() - 1);\n  final double entry=tableau.getEntry(i,col);\n  if (Precision.compareTo(entry,0d,maxUlps) > 0) {\n    final double ratio=rhs / entry;\n    final int cmp=Double.compare(ratio,minRatio);\n    if (cmp == 0) {\n      minRatioPositions.add(i);\n    }\n else     if (cmp < 0) {\n      minRatio=ratio;\n      minRatioPositions=new ArrayList<Integer>();\n      minRatioPositions.add(i);\n    }\n  }\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java", 
          "line": 86, 
          "faulty": "return context.getLocalizedMessage();", 
          "type": "Replace", 
          "seed": "return context.getMessage();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_660/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:03:03.640424804 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/AbstractLinearOptimizer.java\t2018-12-01 06:29:45.579618752 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_660/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/AbstractLinearOptimizer.java\t2018-12-01 07:03:03.640424804 -0500\n@@ -125,7 +125,7 @@\n     protected void incrementIterationsCounter()\n         throws MaxCountExceededException {\n         if (++iterations > maxIterations) {\n-            throw new MaxCountExceededException(maxIterations);\n+            return;\n         }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/AbstractLinearOptimizer.java", 
          "line": 128, 
          "faulty": "throw new MaxCountExceededException(maxIterations);", 
          "type": "Replace", 
          "seed": "return;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "if (minRatioPositions.size() > 1) {\n  for (  Integer row : minRatioPositions) {\n    for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n      int column=i + tableau.getArtificialVariableOffset();\n      final double entry=tableau.getEntry(row,column);\n      if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n        return row;\n      }\n    }\n  }\n  Integer minRow=null;\n  int minIndex=tableau.getWidth();\n  for (  Integer row : minRatioPositions) {\n    int i=tableau.getNumObjectiveFunctions();\n    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n      if (row == tableau.getBasicRow(i)) {\n        if (i < minIndex) {\n          minIndex=i;\n          minRow=row;\n        }\n      }\n    }\n  }\n  return minRow;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1310/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:10:32.406638582 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 06:29:45.307620212 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1310/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 07:10:32.406638582 -0500\n@@ -134,7 +134,7 @@\n      * @return the localized message.\n      */\n     public String getLocalizedMessage() {\n-        return getMessage(Locale.getDefault());\n+        return getMessage(Locale.US);\n     }\n \n     /**\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "continue;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java", 
          "line": 137, 
          "faulty": "return getMessage(Locale.getDefault());", 
          "type": "Replace", 
          "seed": "return getMessage(Locale.US);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1606/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:13:44.357878857 -0500\n@@ -115,17 +115,6 @@\n         } else if (minRatioPositions.size() > 1) {\n             // there's a degeneracy as indicated by a tie in the minimum ratio test\n \n-            // 1. check if there's an artificial variable that can be forced out of the basis\n-                for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n-                }\n-\n             // 2. apply Bland's rule to prevent cycling:\n             //    take the row for which the corresponding basic variable has the smallest index\n             //\n@@ -142,6 +131,10 @@\n                     for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n                         if (row == tableau.getBasicRow(i)) {\n                             if (i < minIndex) {\n+\t\t\t\t\t\t\t\tminIndex = i;\n+\t\t\t\t\t\t\t\tminRow = row;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif (i < minIndex) {\n                                 minIndex = i;\n                                 minRow = row;\n                             }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 119, 
          "faulty": "for (Integer row : minRatioPositions) {\n  for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n    int column=i + tableau.getArtificialVariableOffset();\n    final double entry=tableau.getEntry(row,column);\n    if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n      return row;\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "setMaxIterations(DEFAULT_MAX_ITERATIONS);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 144, 
          "faulty": "if (i < minIndex) {\n  minIndex=i;\n  minRow=row;\n}", 
          "type": "InsertBefore", 
          "seed": "if (i < minIndex) {\n  minIndex=i;\n  minRow=row;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "continue;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_179/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:57:50.909686493 -0500\n@@ -119,7 +119,7 @@\n                 for (Integer row : minRatioPositions) {\n                     for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                         int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n+                        final double entry = tableau.getEntry(i, col);\n                         if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n                             return row;\n                         }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 122, 
          "faulty": "final double entry=tableau.getEntry(row,column);", 
          "type": "Replace", 
          "seed": "final double entry=tableau.getEntry(i,col);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_93/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:56:58.069893949 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 122, 
          "faulty": "final double entry=tableau.getEntry(row,column);", 
          "type": "Replace", 
          "seed": "final double entry=tableau.getEntry(i,col);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "continue;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1652/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:14:10.109774479 -0500\n@@ -101,7 +101,6 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n@@ -118,7 +117,8 @@\n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n                     for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n+                        row = i;\n+\t\t\t\t\t\tint column = i + tableau.getArtificialVariableOffset();\n                         final double entry = tableau.getEntry(row, column);\n                         if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n                             return row;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Delete", 
          "seed": "incrementIterationsCounter();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 121, 
          "faulty": "int column=i + tableau.getArtificialVariableOffset();", 
          "type": "InsertBefore", 
          "seed": "row=i;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_849/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:05:16.195898527 -0500\n@@ -101,7 +101,6 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n@@ -115,15 +114,9 @@\n         } else if (minRatioPositions.size() > 1) {\n             // there's a degeneracy as indicated by a tie in the minimum ratio test\n \n-            // 1. check if there's an artificial variable that can be forced out of the basis\n+            minRatioPositions = new ArrayList<Integer>();\n+\t\t\t\t// 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 119, 
          "faulty": "for (Integer row : minRatioPositions) {\n  for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n    int column=i + tableau.getArtificialVariableOffset();\n    final double entry=tableau.getEntry(row,column);\n    if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n      return row;\n    }\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "minRatioPositions=new ArrayList<Integer>();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Delete", 
          "seed": "if (!Precision.equals(entry,0d,maxUlps)) {\n  return null;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "continue;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 124, 
          "faulty": "return row;", 
          "type": "InsertBefore", 
          "seed": "incrementIterationsCounter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_681/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:03:15.332378844 -0500\n@@ -101,7 +101,6 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n@@ -142,7 +141,6 @@\n                     for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n                         if (row == tableau.getBasicRow(i)) {\n                             if (i < minIndex) {\n-                                minIndex = i;\n                                 minRow = row;\n                             }\n                         }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Delete", 
          "seed": "throw new NoFeasibleSolutionException();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 145, 
          "faulty": "minIndex=i;", 
          "type": "Delete", 
          "seed": "incrementIterationsCounter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1200/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:09:20.298918281 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 06:29:45.307620212 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1200/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 07:09:20.298918281 -0500\n@@ -183,7 +183,8 @@\n             }\n         }\n \n-        return sb.toString();\n+        msgArguments = new ArrayList<Object[]>(len);\n+\t\treturn sb.toString();\n     }\n \n     /**\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java", 
          "line": 186, 
          "faulty": "return sb.toString();", 
          "type": "InsertBefore", 
          "seed": "msgArguments=new ArrayList<Object[]>(len);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "incrementIterationsCounter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1447/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:11:59.846302359 -0500\n@@ -119,7 +119,7 @@\n                 for (Integer row : minRatioPositions) {\n                     for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                         int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n+                        final double entry = tableau.getEntry(i, col);\n                         if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n                             return row;\n                         }\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/AbstractLinearOptimizer.java\t2018-12-01 06:29:45.579618752 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1447/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/AbstractLinearOptimizer.java\t2018-12-01 07:11:59.850302343 -0500\n@@ -125,7 +125,7 @@\n     protected void incrementIterationsCounter()\n         throws MaxCountExceededException {\n         if (++iterations > maxIterations) {\n-            throw new MaxCountExceededException(maxIterations);\n+            throw new UnboundedSolutionException();\n         }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 122, 
          "faulty": "final double entry=tableau.getEntry(row,column);", 
          "type": "Replace", 
          "seed": "final double entry=tableau.getEntry(i,col);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/AbstractLinearOptimizer.java", 
          "line": 128, 
          "faulty": "throw new MaxCountExceededException(maxIterations);", 
          "type": "Replace", 
          "seed": "throw new UnboundedSolutionException();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_255/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:58:43.145485923 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 06:29:45.307620212 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_255/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 06:58:43.145485923 -0500\n@@ -176,7 +176,8 @@\n             final Object[] args = msgArguments.get(i);\n             final MessageFormat fmt = new MessageFormat(pat.getLocalizedString(locale),\n                                                         locale);\n-            sb.append(fmt.format(args));\n+            context = new HashMap<String, Object>();\n+\t\t\tsb.append(fmt.format(args));\n             if (++count < len) {\n                 // Add a separator if there are other messages.\n                 sb.append(separator);\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "throw new NoFeasibleSolutionException();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java", 
          "line": 179, 
          "faulty": "sb.append(fmt.format(args));", 
          "type": "InsertBefore", 
          "seed": "context=new HashMap<String,Object>();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_977/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:06:36.479569523 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "continue;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 124, 
          "faulty": "return row;", 
          "type": "InsertBefore", 
          "seed": "if (Precision.equals(entry,1d,maxUlps) && (row == null)) {\n  row=i;\n}\n else if (!Precision.equals(entry,0d,maxUlps)) {\n  return null;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_113/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:57:10.073846359 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "continue;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_908/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:05:56.583732097 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 06:29:45.307620212 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_908/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 07:05:56.583732097 -0500\n@@ -125,7 +125,8 @@\n      * @return the message.\n      */\n     public String getMessage() {\n-        return getMessage(Locale.US);\n+        context = new HashMap<String, Object>();\n+\t\treturn getMessage(Locale.US);\n     }\n \n     /**\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java", 
          "line": 128, 
          "faulty": "return getMessage(Locale.US);", 
          "type": "InsertBefore", 
          "seed": "context=new HashMap<String,Object>();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "incrementIterationsCounter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1157/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:08:56.683010725 -0500\n@@ -115,17 +115,6 @@\n         } else if (minRatioPositions.size() > 1) {\n             // there's a degeneracy as indicated by a tie in the minimum ratio test\n \n-            // 1. check if there's an artificial variable that can be forced out of the basis\n-                for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n-                }\n-\n             // 2. apply Bland's rule to prevent cycling:\n             //    take the row for which the corresponding basic variable has the smallest index\n             //\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 119, 
          "faulty": "for (Integer row : minRatioPositions) {\n  for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n    int column=i + tableau.getArtificialVariableOffset();\n    final double entry=tableau.getEntry(row,column);\n    if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n      return row;\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "setMaxIterations(DEFAULT_MAX_ITERATIONS);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 124, 
          "faulty": "return row;", 
          "type": "Replace", 
          "seed": "if (minRatioPositions.size() == 0) {\n  return null;\n}\n else if (minRatioPositions.size() > 1) {\n  for (  Integer row : minRatioPositions) {\n    for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n      int column=i + tableau.getArtificialVariableOffset();\n      final double entry=tableau.getEntry(row,column);\n      if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n        return row;\n      }\n    }\n  }\n  Integer minRow=null;\n  int minIndex=tableau.getWidth();\n  for (  Integer row : minRatioPositions) {\n    int i=tableau.getNumObjectiveFunctions();\n    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n      if (row == tableau.getBasicRow(i)) {\n        if (i < minIndex) {\n          minIndex=i;\n          minRow=row;\n        }\n      }\n    }\n  }\n  return minRow;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1100/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:08:24.031139284 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 06:29:45.307620212 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1100/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 07:08:24.031139284 -0500\n@@ -169,7 +169,8 @@\n     private String buildMessage(Locale locale,\n                                 String separator) {\n         final StringBuilder sb = new StringBuilder();\n-        int count = 0;\n+        this.throwable = throwable;\n+\t\tint count = 0;\n         final int len = msgPatterns.size();\n         for (int i = 0; i < len; i++) {\n             final Localizable pat = msgPatterns.get(i);\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 122, 
          "faulty": "final double entry=tableau.getEntry(row,column);", 
          "type": "Replace", 
          "seed": "final double entry=tableau.getEntry(i,col);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "continue;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java", 
          "line": 172, 
          "faulty": "int count=0;", 
          "type": "InsertBefore", 
          "seed": "this.throwable=throwable;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 124, 
          "faulty": "return row;", 
          "type": "InsertBefore", 
          "seed": "solvePhase1(tableau);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1460/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:12:07.514271088 -0500\n@@ -115,17 +115,6 @@\n         } else if (minRatioPositions.size() > 1) {\n             // there's a degeneracy as indicated by a tie in the minimum ratio test\n \n-            // 1. check if there's an artificial variable that can be forced out of the basis\n-                for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n-                }\n-\n             // 2. apply Bland's rule to prevent cycling:\n             //    take the row for which the corresponding basic variable has the smallest index\n             //\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 06:29:45.307620212 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1460/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 07:12:07.518271072 -0500\n@@ -169,7 +169,8 @@\n     private String buildMessage(Locale locale,\n                                 String separator) {\n         final StringBuilder sb = new StringBuilder();\n-        int count = 0;\n+        this.throwable = throwable;\n+\t\tint count = 0;\n         final int len = msgPatterns.size();\n         for (int i = 0; i < len; i++) {\n             final Localizable pat = msgPatterns.get(i);\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 119, 
          "faulty": "for (Integer row : minRatioPositions) {\n  for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n    int column=i + tableau.getArtificialVariableOffset();\n    final double entry=tableau.getEntry(row,column);\n    if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n      return row;\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "if (minRatioPositions.size() == 0) {\n  return null;\n}\n else if (minRatioPositions.size() > 1) {\n  for (  Integer row : minRatioPositions) {\n    for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n      int column=i + tableau.getArtificialVariableOffset();\n      final double entry=tableau.getEntry(row,column);\n      if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n        return row;\n      }\n    }\n  }\n  Integer minRow=null;\n  int minIndex=tableau.getWidth();\n  for (  Integer row : minRatioPositions) {\n    int i=tableau.getNumObjectiveFunctions();\n    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n      if (row == tableau.getBasicRow(i)) {\n        if (i < minIndex) {\n          minIndex=i;\n          minRow=row;\n        }\n      }\n    }\n  }\n  return minRow;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "if (minRatioPositions.size() > 1) {\n  for (  Integer row : minRatioPositions) {\n    for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n      int column=i + tableau.getArtificialVariableOffset();\n      final double entry=tableau.getEntry(row,column);\n      if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n        return row;\n      }\n    }\n  }\n  Integer minRow=null;\n  int minIndex=tableau.getWidth();\n  for (  Integer row : minRatioPositions) {\n    int i=tableau.getNumObjectiveFunctions();\n    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n      if (row == tableau.getBasicRow(i)) {\n        if (i < minIndex) {\n          minIndex=i;\n          minRow=row;\n        }\n      }\n    }\n  }\n  return minRow;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java", 
          "line": 172, 
          "faulty": "int count=0;", 
          "type": "InsertBefore", 
          "seed": "this.throwable=throwable;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1305/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:10:29.938648095 -0500\n@@ -101,7 +101,6 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n@@ -117,13 +116,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n@@ -143,12 +135,10 @@\n                         if (row == tableau.getBasicRow(i)) {\n                             if (i < minIndex) {\n                                 minIndex = i;\n-                                minRow = row;\n                             }\n                         }\n                     }\n                 }\n-                return minRow;\n         }\n         return minRatioPositions.get(0);\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 151, 
          "faulty": "return minRow;", 
          "type": "Delete", 
          "seed": "this.maxUlps=maxUlps;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Delete", 
          "seed": "return minRatioPositions.get(0);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "incrementIterationsCounter();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 146, 
          "faulty": "minRow=row;", 
          "type": "Delete", 
          "seed": "return minRatioPositions.get(0);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1554/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:13:14.829999090 -0500\n@@ -101,7 +101,6 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n@@ -115,17 +114,6 @@\n         } else if (minRatioPositions.size() > 1) {\n             // there's a degeneracy as indicated by a tie in the minimum ratio test\n \n-            // 1. check if there's an artificial variable that can be forced out of the basis\n-                for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n-                }\n-\n             // 2. apply Bland's rule to prevent cycling:\n             //    take the row for which the corresponding basic variable has the smallest index\n             //\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 119, 
          "faulty": "for (Integer row : minRatioPositions) {\n  for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n    int column=i + tableau.getArtificialVariableOffset();\n    final double entry=tableau.getEntry(row,column);\n    if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n      return row;\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "tableau.dropPhase1Objective();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Delete", 
          "seed": "incrementIterationsCounter();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "incrementIterationsCounter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1163/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:08:59.834998361 -0500\n@@ -115,16 +115,7 @@\n         } else if (minRatioPositions.size() > 1) {\n             // there's a degeneracy as indicated by a tie in the minimum ratio test\n \n-            // 1. check if there's an artificial variable that can be forced out of the basis\n-                for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n-                }\n+            setMaxIterations(DEFAULT_MAX_ITERATIONS);\n \n             // 2. apply Bland's rule to prevent cycling:\n             //    take the row for which the corresponding basic variable has the smallest index\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 119, 
          "faulty": "for (Integer row : minRatioPositions) {\n  for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n    int column=i + tableau.getArtificialVariableOffset();\n    final double entry=tableau.getEntry(row,column);\n    if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n      return row;\n    }\n  }\n}", 
          "type": "Replace", 
          "seed": "setMaxIterations(DEFAULT_MAX_ITERATIONS);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_196/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:58:01.113646996 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 06:29:45.307620212 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_196/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 06:58:01.113646996 -0500\n@@ -170,7 +170,8 @@\n                                 String separator) {\n         final StringBuilder sb = new StringBuilder();\n         int count = 0;\n-        final int len = msgPatterns.size();\n+        context = new HashMap<String, Object>();\n+\t\tfinal int len = msgPatterns.size();\n         for (int i = 0; i < len; i++) {\n             final Localizable pat = msgPatterns.get(i);\n             final Object[] args = msgArguments.get(i);\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java", 
          "line": 173, 
          "faulty": "final int len=msgPatterns.size();", 
          "type": "InsertBefore", 
          "seed": "context=new HashMap<String,Object>();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "while (!tableau.isOptimal()) {\n  doIteration(tableau);\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1383/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:11:15.122474556 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 06:29:45.307620212 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1383/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 07:11:15.126474541 -0500\n@@ -174,7 +174,8 @@\n         for (int i = 0; i < len; i++) {\n             final Localizable pat = msgPatterns.get(i);\n             final Object[] args = msgArguments.get(i);\n-            final MessageFormat fmt = new MessageFormat(pat.getLocalizedString(locale),\n+            this.throwable = throwable;\n+\t\t\tfinal MessageFormat fmt = new MessageFormat(pat.getLocalizedString(locale),\n                                                         locale);\n             sb.append(fmt.format(args));\n             if (++count < len) {\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java", 
          "line": 177, 
          "faulty": "final MessageFormat fmt=new MessageFormat(pat.getLocalizedString(locale),locale);", 
          "type": "InsertBefore", 
          "seed": "this.throwable=throwable;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "if (minRatioPositions.size() > 1) {\n  for (  Integer row : minRatioPositions) {\n    for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n      int column=i + tableau.getArtificialVariableOffset();\n      final double entry=tableau.getEntry(row,column);\n      if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n        return row;\n      }\n    }\n  }\n  Integer minRow=null;\n  int minIndex=tableau.getWidth();\n  for (  Integer row : minRatioPositions) {\n    int i=tableau.getNumObjectiveFunctions();\n    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n      if (row == tableau.getBasicRow(i)) {\n        if (i < minIndex) {\n          minIndex=i;\n          minRow=row;\n        }\n      }\n    }\n  }\n  return minRow;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 124, 
          "faulty": "return row;", 
          "type": "Delete", 
          "seed": "doIteration(tableau);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_450/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:00:46.552973481 -0500\n@@ -119,9 +119,8 @@\n                 for (Integer row : minRatioPositions) {\n                     for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                         int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n+                        final double entry = tableau.getEntry(i, col);\n                         if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n                         }\n                     }\n                 }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 122, 
          "faulty": "final double entry=tableau.getEntry(row,column);", 
          "type": "Replace", 
          "seed": "final double entry=tableau.getEntry(i,col);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 124, 
          "faulty": "return row;", 
          "type": "Delete", 
          "seed": "if (minRatioPositions.size() == 0) {\n  return null;\n}\n else if (minRatioPositions.size() > 1) {\n  for (  Integer row : minRatioPositions) {\n    for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n      int column=i + tableau.getArtificialVariableOffset();\n      final double entry=tableau.getEntry(row,column);\n      if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n        return row;\n      }\n    }\n  }\n  Integer minRow=null;\n  int minIndex=tableau.getWidth();\n  for (  Integer row : minRatioPositions) {\n    int i=tableau.getNumObjectiveFunctions();\n    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n      if (row == tableau.getBasicRow(i)) {\n        if (i < minIndex) {\n          minIndex=i;\n          minRow=row;\n        }\n      }\n    }\n  }\n  return minRow;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1245/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:09:46.830814932 -0500\n@@ -101,7 +101,6 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n@@ -117,13 +116,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Delete", 
          "seed": "if (!Precision.equals(entry,0d,maxUlps)) {\n  return null;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "continue;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 124, 
          "faulty": "return row;", 
          "type": "Replace", 
          "seed": "incrementIterationsCounter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_556/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:01:47.212728338 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "continue;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 121, 
          "faulty": "int column=i + tableau.getArtificialVariableOffset();", 
          "type": "InsertBefore", 
          "seed": "while (!tableau.isOptimal()) {\n  doIteration(tableau);\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_501/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:01:17.040849770 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/AbstractLinearOptimizer.java\t2018-12-01 06:29:45.579618752 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_501/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/AbstractLinearOptimizer.java\t2018-12-01 07:01:17.040849770 -0500\n@@ -125,7 +125,10 @@\n     protected void incrementIterationsCounter()\n         throws MaxCountExceededException {\n         if (++iterations > maxIterations) {\n-            throw new MaxCountExceededException(maxIterations);\n+            if (++iterations > maxIterations) {\n+\t\t\t\tthrow new MaxCountExceededException(maxIterations);\n+\t\t\t}\n+\t\t\tthrow new MaxCountExceededException(maxIterations);\n         }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/AbstractLinearOptimizer.java", 
          "line": 128, 
          "faulty": "throw new MaxCountExceededException(maxIterations);", 
          "type": "InsertBefore", 
          "seed": "if (++iterations > maxIterations) {\n  throw new MaxCountExceededException(maxIterations);\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "continue;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_460/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:00:52.608948824 -0500\n@@ -119,9 +119,9 @@\n                 for (Integer row : minRatioPositions) {\n                     for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                         int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n+                        setMaxIterations(DEFAULT_MAX_ITERATIONS);\n+\t\t\t\t\t\tfinal double entry = tableau.getEntry(row, column);\n                         if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n                         }\n                     }\n                 }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 122, 
          "faulty": "final double entry=tableau.getEntry(row,column);", 
          "type": "InsertBefore", 
          "seed": "setMaxIterations(DEFAULT_MAX_ITERATIONS);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 124, 
          "faulty": "return row;", 
          "type": "Delete", 
          "seed": "doIteration(tableau);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_606/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:02:18.960601571 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 122, 
          "faulty": "final double entry=tableau.getEntry(row,column);", 
          "type": "Replace", 
          "seed": "final double entry=tableau.getEntry(i,col);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "if (minRatioPositions.size() > 1) {\n  for (  Integer row : minRatioPositions) {\n    for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n      int column=i + tableau.getArtificialVariableOffset();\n      final double entry=tableau.getEntry(row,column);\n      if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n        return row;\n      }\n    }\n  }\n  Integer minRow=null;\n  int minIndex=tableau.getWidth();\n  for (  Integer row : minRatioPositions) {\n    int i=tableau.getNumObjectiveFunctions();\n    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n      if (row == tableau.getBasicRow(i)) {\n        if (i < minIndex) {\n          minIndex=i;\n          minRow=row;\n        }\n      }\n    }\n  }\n  return minRow;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 124, 
          "faulty": "return row;", 
          "type": "InsertBefore", 
          "seed": "doIteration(tableau);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/LocalizedFormats.java\t2018-12-01 06:29:45.555618881 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1675/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/LocalizedFormats.java\t2018-12-01 07:14:33.041682070 -0500\n@@ -387,8 +387,6 @@\n             // do nothing here\n         }\n \n-        // either the locale is not supported or the resource is unknown\n-        // don't translate and fall back to using the source format\n         return sourceFormat;\n \n     }\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1675/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:14:33.041682070 -0500\n@@ -115,17 +115,6 @@\n         } else if (minRatioPositions.size() > 1) {\n             // there's a degeneracy as indicated by a tie in the minimum ratio test\n \n-            // 1. check if there's an artificial variable that can be forced out of the basis\n-                for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n-                }\n-\n             // 2. apply Bland's rule to prevent cycling:\n             //    take the row for which the corresponding basic variable has the smallest index\n             //\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 119, 
          "faulty": "for (Integer row : minRatioPositions) {\n  for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n    int column=i + tableau.getArtificialVariableOffset();\n    final double entry=tableau.getEntry(row,column);\n    if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n      return row;\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "setMaxIterations(DEFAULT_MAX_ITERATIONS);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "continue;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/util/LocalizedFormats.java", 
          "line": 392, 
          "faulty": "return sourceFormat;", 
          "type": "Replace", 
          "seed": "return sourceFormat;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1095/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:08:21.331149953 -0500\n@@ -101,7 +101,6 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n@@ -121,7 +120,7 @@\n                         int column = i + tableau.getArtificialVariableOffset();\n                         final double entry = tableau.getEntry(row, column);\n                         if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n+                            return minRatioPositions.get(0);\n                         }\n                     }\n                 }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Delete", 
          "seed": "if (!Precision.equals(entry,0d,maxUlps)) {\n  return null;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 124, 
          "faulty": "return row;", 
          "type": "Replace", 
          "seed": "return minRatioPositions.get(0);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_258/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:58:44.457480367 -0500\n@@ -101,7 +101,7 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n+                    return minRatioPositions.get(0);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Replace", 
          "seed": "return minRatioPositions.get(0);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_414/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:00:26.385055904 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "doIteration(tableau);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 121, 
          "faulty": "int column=i + tableau.getArtificialVariableOffset();", 
          "type": "InsertBefore", 
          "seed": "if (minRatioPositions.size() > 1) {\n  for (  Integer row : minRatioPositions) {\n    for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n      int column=i + tableau.getArtificialVariableOffset();\n      final double entry=tableau.getEntry(row,column);\n      if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n        return row;\n      }\n    }\n  }\n  Integer minRow=null;\n  int minIndex=tableau.getWidth();\n  for (  Integer row : minRatioPositions) {\n    int i=tableau.getNumObjectiveFunctions();\n    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n      if (row == tableau.getBasicRow(i)) {\n        if (i < minIndex) {\n          minIndex=i;\n          minRow=row;\n        }\n      }\n    }\n  }\n  return minRow;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_513/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:01:22.212828886 -0500\n@@ -120,9 +120,6 @@\n                     for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                         int column = i + tableau.getArtificialVariableOffset();\n                         final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n                     }\n                 }\n \n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 123, 
          "faulty": "if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n  return row;\n}", 
          "type": "Delete", 
          "seed": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_260/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:58:45.149477436 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 06:29:45.307620212 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_260/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 06:58:45.149477436 -0500\n@@ -170,7 +170,8 @@\n                                 String separator) {\n         final StringBuilder sb = new StringBuilder();\n         int count = 0;\n-        final int len = msgPatterns.size();\n+        this.throwable = throwable;\n+\t\tfinal int len = msgPatterns.size();\n         for (int i = 0; i < len; i++) {\n             final Localizable pat = msgPatterns.get(i);\n             final Object[] args = msgArguments.get(i);\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java", 
          "line": 173, 
          "faulty": "final int len=msgPatterns.size();", 
          "type": "InsertBefore", 
          "seed": "this.throwable=throwable;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "continue;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_130/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:57:18.469813241 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java\t2018-12-01 06:29:45.303620234 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_130/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java\t2018-12-01 06:57:18.473813225 -0500\n@@ -83,6 +83,6 @@\n     /** {@inheritDoc} */\n     @Override\n     public String getLocalizedMessage() {\n-        return context.getLocalizedMessage();\n+        return context.getMessage();\n     }\n }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "continue;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java", 
          "line": 86, 
          "faulty": "return context.getLocalizedMessage();", 
          "type": "Replace", 
          "seed": "return context.getMessage();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1629/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:13:55.949831790 -0500\n@@ -101,7 +101,7 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n+                    return minRatioPositions.get(0);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n@@ -126,7 +126,34 @@\n                     }\n                 }\n \n-            // 2. apply Bland's rule to prevent cycling:\n+            if (minRatioPositions.size() > 1) {\n+\t\t\t\t\tfor (Integer row : minRatioPositions) {\n+\t\t\t\t\t\tfor (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n+\t\t\t\t\t\t\tint column = i\n+\t\t\t\t\t\t\t\t\t+ tableau.getArtificialVariableOffset();\n+\t\t\t\t\t\t\tfinal double entry = tableau.getEntry(row, column);\n+\t\t\t\t\t\t\tif (Precision.equals(entry, 1d, maxUlps)\n+\t\t\t\t\t\t\t\t\t&& row.equals(tableau.getBasicRow(column))) {\n+\t\t\t\t\t\t\t\treturn row;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tInteger minRow = null;\n+\t\t\t\t\tint minIndex = tableau.getWidth();\n+\t\t\t\t\tfor (Integer row : minRatioPositions) {\n+\t\t\t\t\t\tint i = tableau.getNumObjectiveFunctions();\n+\t\t\t\t\t\tfor (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n+\t\t\t\t\t\t\tif (row == tableau.getBasicRow(i)) {\n+\t\t\t\t\t\t\t\tif (i < minIndex) {\n+\t\t\t\t\t\t\t\t\tminIndex = i;\n+\t\t\t\t\t\t\t\t\tminRow = row;\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\treturn minRow;\n+\t\t\t\t}\n+\t\t\t\t// 2. apply Bland's rule to prevent cycling:\n             //    take the row for which the corresponding basic variable has the smallest index\n             //\n             // see http://www.stanford.edu/class/msande310/blandrule.pdf\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 138, 
          "faulty": "Integer minRow=null;", 
          "type": "InsertBefore", 
          "seed": "if (minRatioPositions.size() > 1) {\n  for (  Integer row : minRatioPositions) {\n    for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n      int column=i + tableau.getArtificialVariableOffset();\n      final double entry=tableau.getEntry(row,column);\n      if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n        return row;\n      }\n    }\n  }\n  Integer minRow=null;\n  int minIndex=tableau.getWidth();\n  for (  Integer row : minRatioPositions) {\n    int i=tableau.getNumObjectiveFunctions();\n    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n      if (row == tableau.getBasicRow(i)) {\n        if (i < minIndex) {\n          minIndex=i;\n          minRow=row;\n        }\n      }\n    }\n  }\n  return minRow;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Replace", 
          "seed": "return minRatioPositions.get(0);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_51/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:56:15.522065100 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/AbstractLinearOptimizer.java\t2018-12-01 06:29:45.579618752 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_51/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/AbstractLinearOptimizer.java\t2018-12-01 06:56:15.522065100 -0500\n@@ -125,7 +125,7 @@\n     protected void incrementIterationsCounter()\n         throws MaxCountExceededException {\n         if (++iterations > maxIterations) {\n-            throw new MaxCountExceededException(maxIterations);\n+            throw new NoFeasibleSolutionException();\n         }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/AbstractLinearOptimizer.java", 
          "line": 128, 
          "faulty": "throw new MaxCountExceededException(maxIterations);", 
          "type": "Replace", 
          "seed": "throw new NoFeasibleSolutionException();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "incrementIterationsCounter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1472/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:12:14.026244579 -0500\n@@ -101,7 +101,6 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n@@ -117,13 +116,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n@@ -137,7 +129,8 @@\n             // This heuristic is based on empirical data gathered while investigating MATH-828.\n                 Integer minRow = null;\n                 int minIndex = tableau.getWidth();\n-                for (Integer row : minRatioPositions) {\n+                solvePhase1(tableau);\n+\t\t\t\tfor (Integer row : minRatioPositions) {\n                     int i = tableau.getNumObjectiveFunctions();\n                     for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n                         if (row == tableau.getBasicRow(i)) {\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Delete", 
          "seed": "throw new NoFeasibleSolutionException();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "incrementIterationsCounter();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 140, 
          "faulty": "for (Integer row : minRatioPositions) {\n  int i=tableau.getNumObjectiveFunctions();\n  for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n    if (row == tableau.getBasicRow(i)) {\n      if (i < minIndex) {\n        minIndex=i;\n        minRow=row;\n      }\n    }\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "solvePhase1(tableau);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1170/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:09:02.386988357 -0500\n@@ -101,7 +101,6 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n@@ -117,13 +116,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 122, 
          "faulty": "final double entry=tableau.getEntry(row,column);", 
          "type": "Replace", 
          "seed": "final double entry=tableau.getEntry(i,col);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Delete", 
          "seed": "this.maxUlps=maxUlps;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "if (minRatioPositions.size() > 1) {\n  for (  Integer row : minRatioPositions) {\n    for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n      int column=i + tableau.getArtificialVariableOffset();\n      final double entry=tableau.getEntry(row,column);\n      if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n        return row;\n      }\n    }\n  }\n  Integer minRow=null;\n  int minIndex=tableau.getWidth();\n  for (  Integer row : minRatioPositions) {\n    int i=tableau.getNumObjectiveFunctions();\n    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n      if (row == tableau.getBasicRow(i)) {\n        if (i < minIndex) {\n          minIndex=i;\n          minRow=row;\n        }\n      }\n    }\n  }\n  return minRow;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_330/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:59:34.905268557 -0500\n@@ -115,17 +115,6 @@\n         } else if (minRatioPositions.size() > 1) {\n             // there's a degeneracy as indicated by a tie in the minimum ratio test\n \n-            // 1. check if there's an artificial variable that can be forced out of the basis\n-                for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n-                }\n-\n             // 2. apply Bland's rule to prevent cycling:\n             //    take the row for which the corresponding basic variable has the smallest index\n             //\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 06:29:45.307620212 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_330/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java\t2018-12-01 06:59:34.905268557 -0500\n@@ -176,7 +176,8 @@\n             final Object[] args = msgArguments.get(i);\n             final MessageFormat fmt = new MessageFormat(pat.getLocalizedString(locale),\n                                                         locale);\n-            sb.append(fmt.format(args));\n+            this.throwable = throwable;\n+\t\t\tsb.append(fmt.format(args));\n             if (++count < len) {\n                 // Add a separator if there are other messages.\n                 sb.append(separator);\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 119, 
          "faulty": "for (Integer row : minRatioPositions) {\n  for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n    int column=i + tableau.getArtificialVariableOffset();\n    final double entry=tableau.getEntry(row,column);\n    if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n      return row;\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "setMaxIterations(DEFAULT_MAX_ITERATIONS);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java", 
          "line": 179, 
          "faulty": "sb.append(fmt.format(args));", 
          "type": "InsertBefore", 
          "seed": "this.throwable=throwable;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_428/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:00:34.113024264 -0500\n@@ -101,7 +101,6 @@\n                 // do not use a ulp/epsilon check\n                 final int cmp = Double.compare(ratio, minRatio);\n                 if (cmp == 0) {\n-                    minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n@@ -115,16 +114,7 @@\n         } else if (minRatioPositions.size() > 1) {\n             // there's a degeneracy as indicated by a tie in the minimum ratio test\n \n-            // 1. check if there's an artificial variable that can be forced out of the basis\n-                for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n-                }\n+            minRatioPositions = new ArrayList<Integer>();\n \n             // 2. apply Bland's rule to prevent cycling:\n             //    take the row for which the corresponding basic variable has the smallest index\n@@ -140,12 +130,6 @@\n                 for (Integer row : minRatioPositions) {\n                     int i = tableau.getNumObjectiveFunctions();\n                     for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n-                        if (row == tableau.getBasicRow(i)) {\n-                            if (i < minIndex) {\n-                                minIndex = i;\n-                                minRow = row;\n-                            }\n-                        }\n                     }\n                 }\n                 return minRow;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 119, 
          "faulty": "for (Integer row : minRatioPositions) {\n  for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n    int column=i + tableau.getArtificialVariableOffset();\n    final double entry=tableau.getEntry(row,column);\n    if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n      return row;\n    }\n  }\n}", 
          "type": "Replace", 
          "seed": "minRatioPositions=new ArrayList<Integer>();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 104, 
          "faulty": "minRatioPositions.add(i);", 
          "type": "Delete", 
          "seed": "if (!Precision.equals(entry,0d,maxUlps)) {\n  return null;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "continue;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 143, 
          "faulty": "if (row == tableau.getBasicRow(i)) {\n  if (i < minIndex) {\n    minIndex=i;\n    minRow=row;\n  }\n}", 
          "type": "Delete", 
          "seed": "throw new UnboundedSolutionException();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_799/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:04:44.260031547 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "doIteration(tableau);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 124, 
          "faulty": "return row;", 
          "type": "InsertBefore", 
          "seed": "if (minRatioPositions.size() == 0) {\n  return null;\n}\n else if (minRatioPositions.size() > 1) {\n  for (  Integer row : minRatioPositions) {\n    for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n      int column=i + tableau.getArtificialVariableOffset();\n      final double entry=tableau.getEntry(row,column);\n      if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n        return row;\n      }\n    }\n  }\n  Integer minRow=null;\n  int minIndex=tableau.getWidth();\n  for (  Integer row : minRatioPositions) {\n    int i=tableau.getNumObjectiveFunctions();\n    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n      if (row == tableau.getBasicRow(i)) {\n        if (i < minIndex) {\n          minIndex=i;\n          minRow=row;\n        }\n      }\n    }\n  }\n  return minRow;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_1423/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:11:44.922360794 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "continue;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java", 
          "line": 147, 
          "faulty": "return buildMessage(locale,\": \");", 
          "type": "Replace", 
          "seed": "return buildMessage(locale,\": \");"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 06:29:49.227599214 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_710/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 07:03:32.860310164 -0500\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java\t2018-12-01 06:29:45.303620234 -0500\n+++ /tmp/Arja_Defects4J_Math_28/patches_1aw5/Patch_710/patched/tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java\t2018-12-01 07:03:32.860310164 -0500\n@@ -83,6 +83,6 @@\n     /** {@inheritDoc} */\n     @Override\n     public String getLocalizedMessage() {\n-        return context.getLocalizedMessage();\n+        return context.getMessage();\n     }\n }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 122, 
          "faulty": "final double entry=tableau.getEntry(row,column);", 
          "type": "Replace", 
          "seed": "final double entry=tableau.getEntry(i,col);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java", 
          "line": 120, 
          "faulty": "for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n  int column=i + tableau.getArtificialVariableOffset();\n  final double entry=tableau.getEntry(row,column);\n  if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n    return row;\n  }\n}", 
          "type": "Delete", 
          "seed": "if (minRatioPositions.size() > 1) {\n  for (  Integer row : minRatioPositions) {\n    for (int i=0; i < tableau.getNumArtificialVariables(); i++) {\n      int column=i + tableau.getArtificialVariableOffset();\n      final double entry=tableau.getEntry(row,column);\n      if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {\n        return row;\n      }\n    }\n  }\n  Integer minRow=null;\n  int minIndex=tableau.getWidth();\n  for (  Integer row : minRatioPositions) {\n    int i=tableau.getNumObjectiveFunctions();\n    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n      if (row == tableau.getBasicRow(i)) {\n        if (i < minIndex) {\n          minIndex=i;\n          minRow=row;\n        }\n      }\n    }\n  }\n  return minRow;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java", 
          "line": 86, 
          "faulty": "return context.getLocalizedMessage();", 
          "type": "Replace", 
          "seed": "return context.getMessage();"
        }
      ]
    }
  ]
}