{
  "repair_end": "2018-12-02 18:35:23.027679", 
  "repair_begin": "2018-12-02 17:24:20.124576", 
  "patches": [
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_1046/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 12:21:15.666301758 -0500\n@@ -104,19 +104,19 @@\n \n         // return the initial guess if it is good enough\n         double yInitial = f.value(initial);\n-        if (Math.abs(yInitial) <= functionValueAccuracy) {\n+        clearResult();\n+\t\tclearResult();\n+\t\tif (Math.abs(yInitial) <= functionValueAccuracy) {\n             setResult(initial, 0);\n             return result;\n         }\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if min and initial bracket the root\n+        verifyBracketing(min, max, f);\n+\t\tverifyBracketing(min, max, f);\n+\t\tverifyBracketing(min, max, f);\n+\t\t// reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n@@ -134,7 +134,9 @@\n         }\n \n \n-        // full Brent algorithm starting with provided initial guess\n+        checkResultComputed();\n+\t\tcheckResultComputed();\n+\t\t// full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n \n     }\n@@ -172,7 +174,11 @@\n         // Verify bracketing\n         double sign = yMin * yMax;\n         if (sign > 0) {\n-            // check if either value is close to a zero\n+            resultComputed = true;\n+\t\t\tresultComputed = true;\n+\t\t\tresultComputed = true;\n+\t\t\tret = solve(f, min, yMin, max, yMax, min, yMin);\n+\t\t\t// check if either value is close to a zero\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "checkResultComputed();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "checkResultComputed();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "setup(f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "ret=solve(f,min,yMin,max,yMax,min,yMin);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_539/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:55:01.795132092 -0500\n@@ -104,19 +104,16 @@\n \n         // return the initial guess if it is good enough\n         double yInitial = f.value(initial);\n-        if (Math.abs(yInitial) <= functionValueAccuracy) {\n+        clearResult();\n+\t\tif (Math.abs(yInitial) <= functionValueAccuracy) {\n             setResult(initial, 0);\n             return result;\n         }\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if min and initial bracket the root\n+        verifyBracketing(min, max, f);\n+\t\t// reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n@@ -134,7 +131,9 @@\n         }\n \n \n-        // full Brent algorithm starting with provided initial guess\n+        checkResultComputed();\n+\t\tverifySequence(min, initial, max);\n+\t\t// full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n \n     }\n@@ -172,7 +171,8 @@\n         // Verify bracketing\n         double sign = yMin * yMax;\n         if (sign > 0) {\n-            // check if either value is close to a zero\n+            resultComputed = true;\n+\t\t\t// check if either value is close to a zero\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n@@ -284,7 +284,15 @@\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n+                    if (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (delta / oldDelta > 1) {\n+\t\t\t\t\t\tdelta = 0.5 * oldDelta;\n+\t\t\t\t\t}\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "checkResultComputed();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "verifySequence(min,initial,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "Replace", 
          "seed": "if (delta / oldDelta > 1) {\n  delta=0.5 * oldDelta;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "setup(f);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_500/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:52:59.790904252 -0500\n@@ -104,22 +104,23 @@\n \n         // return the initial guess if it is good enough\n         double yInitial = f.value(initial);\n-        if (Math.abs(yInitial) <= functionValueAccuracy) {\n+        clearResult();\n+\t\tdouble a = initial;\n+\t\tif (Math.abs(yInitial) <= functionValueAccuracy) {\n             setResult(initial, 0);\n             return result;\n         }\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n+        verifyBracketing(min, max, f);\n+\t\tif (Math.abs(yMin) <= functionValueAccuracy) {\n             setResult(yMin, 0);\n             return result;\n         }\n \n-        // reduce interval if min and initial bracket the root\n-        if (yInitial * yMin < 0) {\n-            return solve(f, min, yMin, initial, yInitial, min, yMin);\n-        }\n+        double x1 = max;\n+\t\tclearResult();\n \n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n@@ -134,7 +135,8 @@\n         }\n \n \n-        // full Brent algorithm starting with provided initial guess\n+        verifySequence(min, initial, max);\n+\t\t// full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n \n     }\n@@ -172,7 +174,8 @@\n         // Verify bracketing\n         double sign = yMin * yMax;\n         if (sign > 0) {\n-            // check if either value is close to a zero\n+            resultComputed = true;\n+\t\t\t// check if either value is close to a zero\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "Replace", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "double a=initial;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "verifySequence(min,initial,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "InsertBefore", 
          "seed": "double x1=max;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_743/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 12:05:16.068239049 -0500\n@@ -111,17 +111,17 @@\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if min and initial bracket the root\n+        verifyBracketing(min, max, f);\n+\t\tdouble b = initial;\n+\t\t// reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n \n-        // return the second endpoint if it is good enough\n+        if (yInitial * yMin < 0) {\n+\t\t\treturn solve(f, min, yMin, initial, yInitial, min, yMin);\n+\t\t}\n+\t\t// return the second endpoint if it is good enough\n         double yMax = f.value(max);\n         if (Math.abs(yMax) <= functionValueAccuracy) {\n             setResult(yMax, 0);\n@@ -172,7 +172,8 @@\n         // Verify bracketing\n         double sign = yMin * yMax;\n         if (sign > 0) {\n-            // check if either value is close to a zero\n+            resultComputed = true;\n+\t\t\t// check if either value is close to a zero\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n@@ -284,7 +285,13 @@\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n+                    if (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\toldDelta = delta;\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "InsertBefore", 
          "seed": "double b=initial;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "setup(f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 125, 
          "faulty": "double yMax=f.value(max);", 
          "type": "InsertBefore", 
          "seed": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_1297/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 12:34:55.240061705 -0500\n@@ -99,42 +99,38 @@\n                         final double min, final double max, final double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n \n-        clearResult();\n+        double x0 = min;\n         verifySequence(min, initial, max);\n \n         // return the initial guess if it is good enough\n         double yInitial = f.value(initial);\n-        if (Math.abs(yInitial) <= functionValueAccuracy) {\n+        clearResult();\n+\t\tif (Math.abs(yInitial) <= functionValueAccuracy) {\n             setResult(initial, 0);\n             return result;\n         }\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if min and initial bracket the root\n+        verifyBracketing(min, max, f);\n+\t\tverifyBracketing(min, max, f);\n+\t\t// reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n \n-        // return the second endpoint if it is good enough\n+        verifyInterval(min, max);\n+\t\t// return the second endpoint if it is good enough\n         double yMax = f.value(max);\n-        if (Math.abs(yMax) <= functionValueAccuracy) {\n-            setResult(yMax, 0);\n-            return result;\n-        }\n-\n         // reduce interval if initial and max bracket the root\n         if (yInitial * yMax < 0) {\n             return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n         }\n \n \n-        // full Brent algorithm starting with provided initial guess\n+        checkResultComputed();\n+\t\tcheckResultComputed();\n+\t\t// full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n \n     }\n@@ -172,7 +168,11 @@\n         // Verify bracketing\n         double sign = yMin * yMax;\n         if (sign > 0) {\n-            // check if either value is close to a zero\n+            resultComputed = true;\n+\t\t\tresultComputed = true;\n+\t\t\tresultComputed = true;\n+\t\t\tresultComputed = true;\n+\t\t\t// check if either value is close to a zero\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n@@ -280,7 +280,8 @@\n                 }\n                 if (2.0 * p >= 1.5 * dx * p1 - Math.abs(tolerance * p1) ||\n                         p >= Math.abs(0.5 * oldDelta * p1)) {\n-                    // Inverse quadratic interpolation gives a value\n+                    double r1 = y0 / y2;\n+\t\t\t\t\t// Inverse quadratic interpolation gives a value\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "checkResultComputed();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "checkResultComputed();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "setup(f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 125, 
          "faulty": "double yMax=f.value(max);", 
          "type": "InsertBefore", 
          "seed": "verifyInterval(min,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 102, 
          "faulty": "clearResult();", 
          "type": "Replace", 
          "seed": "double x0=min;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 126, 
          "faulty": "if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(yMax,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "Complex d2v=null;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 286, 
          "faulty": "delta=0.5 * dx;", 
          "type": "InsertBefore", 
          "seed": "double r1=y0 / y2;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_772/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 12:06:40.660421967 -0500\n@@ -111,12 +111,9 @@\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if min and initial bracket the root\n+        verifyBracketing(min, max, f);\n+\t\tdouble b = initial;\n+\t\t// reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n@@ -134,8 +131,7 @@\n         }\n \n \n-        // full Brent algorithm starting with provided initial guess\n-        return solve(f, min, yMin, max, yMax, initial, yInitial);\n+        return max;\n \n     }\n \n@@ -172,7 +168,8 @@\n         // Verify bracketing\n         double sign = yMin * yMax;\n         if (sign > 0) {\n-            // check if either value is close to a zero\n+            resultComputed = true;\n+\t\t\t// check if either value is close to a zero\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n@@ -284,7 +281,13 @@\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n+                    if (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\toldDelta = delta;\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "InsertBefore", 
          "seed": "double b=initial;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "setup(f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "Replace", 
          "seed": "return max;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_667/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 12:01:15.003768241 -0500\n@@ -99,7 +99,6 @@\n                         final double min, final double max, final double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n \n-        clearResult();\n         verifySequence(min, initial, max);\n \n         // return the initial guess if it is good enough\n@@ -111,10 +110,8 @@\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n+        verifyBracketing(min, max, f);\n+\t\tverifyInterval(min, max);\n \n         // reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n@@ -123,10 +120,9 @@\n \n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n-        if (Math.abs(yMax) <= functionValueAccuracy) {\n-            setResult(yMax, 0);\n-            return result;\n-        }\n+        if (f.value(max) == 0.0) {\n+\t\t\treturn max;\n+\t\t}\n \n         // reduce interval if initial and max bracket the root\n         if (yInitial * yMax < 0) {\n@@ -134,7 +130,8 @@\n         }\n \n \n-        // full Brent algorithm starting with provided initial guess\n+        verifySequence(min, initial, max);\n+\t\t// full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n \n     }\n@@ -172,7 +169,9 @@\n         // Verify bracketing\n         double sign = yMin * yMax;\n         if (sign > 0) {\n-            // check if either value is close to a zero\n+            resultComputed = true;\n+\t\t\tresultComputed = true;\n+\t\t\t// check if either value is close to a zero\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n@@ -284,7 +283,13 @@\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n+                    if (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\toldDelta = delta;\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "verifySequence(min,initial,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 102, 
          "faulty": "clearResult();", 
          "type": "Delete", 
          "seed": "verifyInterval(min,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Replace", 
          "seed": "verifyInterval(min,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 126, 
          "faulty": "if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(yMax,0);\n  return result;\n}", 
          "type": "Replace", 
          "seed": "if (f.value(max) == 0.0) {\n  return max;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_1184/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 12:28:55.047191715 -0500\n@@ -104,24 +104,29 @@\n \n         // return the initial guess if it is good enough\n         double yInitial = f.value(initial);\n-        if (Math.abs(yInitial) <= functionValueAccuracy) {\n+        clearResult();\n+\t\tclearResult();\n+\t\tif (Math.abs(yInitial) <= functionValueAccuracy) {\n             setResult(initial, 0);\n             return result;\n         }\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n+        verifyBracketing(min, max, f);\n+\t\tverifyBracketing(min, max, f);\n+\t\tif (Math.abs(yInitial) <= functionValueAccuracy) {\n+\t\t\tsetResult(initial, 0);\n+\t\t\treturn result;\n+\t\t}\n \n         // reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n \n-        // return the second endpoint if it is good enough\n+        verifyInterval(min, max);\n+\t\t// return the second endpoint if it is good enough\n         double yMax = f.value(max);\n         if (Math.abs(yMax) <= functionValueAccuracy) {\n             setResult(yMax, 0);\n@@ -134,7 +139,11 @@\n         }\n \n \n-        // full Brent algorithm starting with provided initial guess\n+        checkResultComputed();\n+\t\tcheckResultComputed();\n+\t\tcheckResultComputed();\n+\t\tthis.resultComputed = false;\n+\t\t// full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n \n     }\n@@ -172,7 +181,10 @@\n         // Verify bracketing\n         double sign = yMin * yMax;\n         if (sign > 0) {\n-            // check if either value is close to a zero\n+            resultComputed = true;\n+\t\t\tresultComputed = true;\n+\t\t\tresultComputed = true;\n+\t\t\t// check if either value is close to a zero\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "checkResultComputed();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "checkResultComputed();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "setResult(initial,0);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "checkResultComputed();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "setup(f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 125, 
          "faulty": "double yMax=f.value(max);", 
          "type": "InsertBefore", 
          "seed": "verifyInterval(min,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Replace", 
          "seed": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "this.resultComputed=false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_1249/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 12:32:20.811701355 -0500\n@@ -99,29 +99,28 @@\n                         final double min, final double max, final double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n \n-        clearResult();\n+        double x0 = min;\n         verifySequence(min, initial, max);\n \n         // return the initial guess if it is good enough\n         double yInitial = f.value(initial);\n-        if (Math.abs(yInitial) <= functionValueAccuracy) {\n+        clearResult();\n+\t\tif (Math.abs(yInitial) <= functionValueAccuracy) {\n             setResult(initial, 0);\n             return result;\n         }\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if min and initial bracket the root\n+        verifyBracketing(min, max, f);\n+\t\tverifyBracketing(min, max, f);\n+\t\t// reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n \n-        // return the second endpoint if it is good enough\n+        verifyInterval(min, max);\n+\t\t// return the second endpoint if it is good enough\n         double yMax = f.value(max);\n         if (Math.abs(yMax) <= functionValueAccuracy) {\n             setResult(yMax, 0);\n@@ -134,7 +133,8 @@\n         }\n \n \n-        // full Brent algorithm starting with provided initial guess\n+        checkResultComputed();\n+\t\t// full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n \n     }\n@@ -172,7 +172,10 @@\n         // Verify bracketing\n         double sign = yMin * yMax;\n         if (sign > 0) {\n-            // check if either value is close to a zero\n+            resultComputed = true;\n+\t\t\tresultComputed = true;\n+\t\t\tresultComputed = true;\n+\t\t\t// check if either value is close to a zero\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "checkResultComputed();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "setup(f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 125, 
          "faulty": "double yMax=f.value(max);", 
          "type": "InsertBefore", 
          "seed": "verifyInterval(min,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 102, 
          "faulty": "clearResult();", 
          "type": "Replace", 
          "seed": "double x0=min;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_888/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 12:12:28.941222486 -0500\n@@ -99,24 +99,26 @@\n                         final double min, final double max, final double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n \n-        clearResult();\n+        verifySequence(min, initial, max);\n         verifySequence(min, initial, max);\n \n         // return the initial guess if it is good enough\n         double yInitial = f.value(initial);\n-        if (Math.abs(yInitial) <= functionValueAccuracy) {\n+        clearResult();\n+\t\tif (Math.abs(yInitial) <= functionValueAccuracy) {\n             setResult(initial, 0);\n             return result;\n         }\n \n-        // return the first endpoint if it is good enough\n+        this.defaultFunctionValueAccuracy = 1.0e-15;\n+\t\t// return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if min and initial bracket the root\n+        verifyBracketing(min, max, f);\n+\t\tif (f.value(min) == 0.0) {\n+\t\t\treturn min;\n+\t\t}\n+\t\tsetResult(initial, 0);\n+\t\t// reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n@@ -128,13 +130,14 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n         if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+\t\t\treturn solve(f, initial, yInitial, max, yMax, initial, yInitial);\n+\t\t}\n \n \n-        // full Brent algorithm starting with provided initial guess\n+        checkResultComputed();\n+\t\tverifySequence(min, initial, max);\n+\t\t// full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n \n     }\n@@ -172,7 +175,9 @@\n         // Verify bracketing\n         double sign = yMin * yMax;\n         if (sign > 0) {\n-            // check if either value is close to a zero\n+            resultComputed = true;\n+\t\t\tresultComputed = true;\n+\t\t\t// check if either value is close to a zero\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n@@ -180,7 +185,8 @@\n                 setResult(max, 0);\n                 ret = max;\n             } else {\n-                // neither value is close to zero and min and max do not bracket root.\n+                this.f = f;\n+\t\t\t\t// neither value is close to zero and min and max do not bracket root.\n                 throw MathRuntimeException.createIllegalArgumentException(\n                         NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n             }\n@@ -284,7 +290,21 @@\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n+                    if (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (delta / oldDelta > 1) {\n+\t\t\t\t\t\tdelta = 0.5 * oldDelta;\n+\t\t\t\t\t}\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "checkResultComputed();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "verifySequence(min,initial,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "Replace", 
          "seed": "if (delta / oldDelta > 1) {\n  delta=0.5 * oldDelta;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 113, 
          "faulty": "double yMin=f.value(min);", 
          "type": "InsertBefore", 
          "seed": "this.defaultFunctionValueAccuracy=1.0e-15;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 102, 
          "faulty": "clearResult();", 
          "type": "Replace", 
          "seed": "verifySequence(min,initial,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 184, 
          "faulty": "throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);", 
          "type": "InsertBefore", 
          "seed": "this.f=f;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "if (f.value(min) == 0.0) {\n  return min;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "double x2=max;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "setResult(initial,0);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_697/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 12:02:39.587906436 -0500\n@@ -111,7 +111,8 @@\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n+        verifyBracketing(min, max, f);\n+\t\tif (Math.abs(yMin) <= functionValueAccuracy) {\n             setResult(yMin, 0);\n             return result;\n         }\n@@ -128,12 +129,6 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n-\n-\n         // full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n \n@@ -284,7 +279,6 @@\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Delete", 
          "seed": "setup(f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "Delete", 
          "seed": "oldDelta=x2 - x1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_853/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 12:10:47.572988165 -0500\n@@ -99,42 +99,47 @@\n                         final double min, final double max, final double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n \n-        clearResult();\n+        verifySequence(min, initial, max);\n         verifySequence(min, initial, max);\n \n         // return the initial guess if it is good enough\n         double yInitial = f.value(initial);\n-        if (Math.abs(yInitial) <= functionValueAccuracy) {\n+        clearResult();\n+\t\tclearResult();\n+\t\tint i = 1;\n+\t\tif (Math.abs(yInitial) <= functionValueAccuracy) {\n             setResult(initial, 0);\n             return result;\n         }\n \n-        // return the first endpoint if it is good enough\n+        this.defaultFunctionValueAccuracy = 1.0e-15;\n+\t\t// return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if min and initial bracket the root\n-        if (yInitial * yMin < 0) {\n-            return solve(f, min, yMin, initial, yInitial, min, yMin);\n-        }\n-\n-        // return the second endpoint if it is good enough\n+        verifyBracketing(min, max, f);\n+\t\tverifyBracketing(min, max, f);\n+\t\tdouble x1 = max;\n+\t\t// return the second endpoint if it is good enough\n         double yMax = f.value(max);\n         if (Math.abs(yMax) <= functionValueAccuracy) {\n             setResult(yMax, 0);\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n         if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+\t\t\treturn solve(f, initial, yInitial, max, yMax, initial, yInitial);\n+\t\t}\n \n \n-        // full Brent algorithm starting with provided initial guess\n+        checkResultComputed();\n+\t\tif (f == null) {\n+\t\t\tthrow MathRuntimeException\n+\t\t\t\t\t.createIllegalArgumentException(\"function to solve cannot be null\");\n+\t\t}\n+\t\tcheckResultComputed();\n+\t\tverifySequence(min, initial, max);\n+\t\tcheckResultComputed();\n+\t\tverifySequence(min, initial, max);\n+\t\t// full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n \n     }\n@@ -172,7 +177,10 @@\n         // Verify bracketing\n         double sign = yMin * yMax;\n         if (sign > 0) {\n-            // check if either value is close to a zero\n+            resultComputed = true;\n+\t\t\tresultComputed = true;\n+\t\t\tresultComputed = true;\n+\t\t\t// check if either value is close to a zero\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n@@ -180,7 +188,8 @@\n                 setResult(max, 0);\n                 ret = max;\n             } else {\n-                // neither value is close to zero and min and max do not bracket root.\n+                this.f = f;\n+\t\t\t\t// neither value is close to zero and min and max do not bracket root.\n                 throw MathRuntimeException.createIllegalArgumentException(\n                         NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n             }\n@@ -284,7 +293,18 @@\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n+                    if (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (delta / oldDelta > 1) {\n+\t\t\t\t\t\tdelta = 0.5 * oldDelta;\n+\t\t\t\t\t}\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n@@ -297,7 +317,10 @@\n             if (Math.abs(delta) > tolerance) {\n                 x1 = x1 + delta;\n             } else if (dx > 0.0) {\n-                x1 = x1 + 0.5 * tolerance;\n+                if (delta / oldDelta > 1) {\n+\t\t\t\t\tdelta = 0.5 * oldDelta;\n+\t\t\t\t}\n+\t\t\t\tx1 = x1 + 0.5 * tolerance;\n             } else if (dx <= 0.0) {\n                 x1 = x1 - 0.5 * tolerance;\n             }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "checkResultComputed();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "if (f == null) {\n  throw MathRuntimeException.createIllegalArgumentException(\"function to solve cannot be null\");\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "InsertBefore", 
          "seed": "double x1=max;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "checkResultComputed();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "verifySequence(min,initial,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "checkResultComputed();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "setup(f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "verifySequence(min,initial,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "Replace", 
          "seed": "if (delta / oldDelta > 1) {\n  delta=0.5 * oldDelta;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 113, 
          "faulty": "double yMin=f.value(min);", 
          "type": "InsertBefore", 
          "seed": "this.defaultFunctionValueAccuracy=1.0e-15;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 102, 
          "faulty": "clearResult();", 
          "type": "Replace", 
          "seed": "verifySequence(min,initial,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 184, 
          "faulty": "throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);", 
          "type": "InsertBefore", 
          "seed": "this.f=f;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "Delete", 
          "seed": "return solve(f,min,max,UnivariateRealSolverUtils.midpoint(min,max));"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 300, 
          "faulty": "x1=x1 + 0.5 * tolerance;", 
          "type": "InsertBefore", 
          "seed": "if (delta / oldDelta > 1) {\n  delta=0.5 * oldDelta;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "int i=1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_634/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:59:41.235613368 -0500\n@@ -99,7 +99,7 @@\n                         final double min, final double max, final double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n \n-        clearResult();\n+        verifySequence(min, initial, max);\n         verifySequence(min, initial, max);\n \n         // return the initial guess if it is good enough\n@@ -111,12 +111,8 @@\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if min and initial bracket the root\n+        verifyBracketing(min, max, f);\n+\t\t// reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n@@ -134,7 +130,9 @@\n         }\n \n \n-        // full Brent algorithm starting with provided initial guess\n+        checkResultComputed();\n+\t\tverifySequence(min, initial, max);\n+\t\t// full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n \n     }\n@@ -172,18 +170,22 @@\n         // Verify bracketing\n         double sign = yMin * yMax;\n         if (sign > 0) {\n-            // check if either value is close to a zero\n+            resultComputed = true;\n+\t\t\tresultComputed = true;\n+\t\t\t// check if either value is close to a zero\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n-            } else if (Math.abs(yMax) <= functionValueAccuracy) {\n-                setResult(max, 0);\n-                ret = max;\n             } else {\n-                // neither value is close to zero and min and max do not bracket root.\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                        NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n-            }\n+\t\t\t\tret = min;\n+\t\t\t\tif (Math.abs(yMax) <= functionValueAccuracy) {\n+\t\t\t\t\tsetResult(max, 0);\n+\t\t\t\t\tret = max;\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow MathRuntimeException.createIllegalArgumentException(\n+\t\t\t\t\t\t\tNON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n+\t\t\t\t}\n+\t\t\t}\n         } else if (sign < 0){\n             // solve using only the first endpoint as initial guess\n             ret = solve(f, min, yMin, max, yMax, min, yMin);\n@@ -284,7 +286,15 @@\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n+                    if (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (delta / oldDelta > 1) {\n+\t\t\t\t\t\tdelta = 0.5 * oldDelta;\n+\t\t\t\t\t}\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "checkResultComputed();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "verifySequence(min,initial,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "Replace", 
          "seed": "if (delta / oldDelta > 1) {\n  delta=0.5 * oldDelta;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "setup(f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 102, 
          "faulty": "clearResult();", 
          "type": "Replace", 
          "seed": "verifySequence(min,initial,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 179, 
          "faulty": "if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "ret=min;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_825/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 12:09:22.748788330 -0500\n@@ -104,24 +104,27 @@\n \n         // return the initial guess if it is good enough\n         double yInitial = f.value(initial);\n-        if (Math.abs(yInitial) <= functionValueAccuracy) {\n+        clearResult();\n+\t\tif (Math.abs(yInitial) <= functionValueAccuracy) {\n             setResult(initial, 0);\n             return result;\n         }\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if min and initial bracket the root\n+        verifyBracketing(min, max, f);\n+\t\tif (f.value(min) == 0.0) {\n+\t\t\treturn min;\n+\t\t}\n+\t\t// reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n \n-        // return the second endpoint if it is good enough\n+        if (yInitial * yMin < 0) {\n+\t\t\treturn solve(f, min, yMin, initial, yInitial, min, yMin);\n+\t\t}\n+\t\t// return the second endpoint if it is good enough\n         double yMax = f.value(max);\n         if (Math.abs(yMax) <= functionValueAccuracy) {\n             setResult(yMax, 0);\n@@ -134,7 +137,8 @@\n         }\n \n \n-        // full Brent algorithm starting with provided initial guess\n+        checkResultComputed();\n+\t\t// full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n \n     }\n@@ -172,7 +176,8 @@\n         // Verify bracketing\n         double sign = yMin * yMax;\n         if (sign > 0) {\n-            // check if either value is close to a zero\n+            resultComputed = true;\n+\t\t\t// check if either value is close to a zero\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "checkResultComputed();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "setup(f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 125, 
          "faulty": "double yMax=f.value(max);", 
          "type": "InsertBefore", 
          "seed": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "if (f.value(min) == 0.0) {\n  return min;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "double x2=max;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_514/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:53:43.574987902 -0500\n@@ -104,22 +104,25 @@\n \n         // return the initial guess if it is good enough\n         double yInitial = f.value(initial);\n-        if (Math.abs(yInitial) <= functionValueAccuracy) {\n+        clearResult();\n+\t\tdouble a = initial;\n+\t\tif (Math.abs(yInitial) <= functionValueAccuracy) {\n             setResult(initial, 0);\n             return result;\n         }\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n+        verifyBracketing(min, max, f);\n+\t\tverifyBracketing(min, max, f);\n+\t\tif (Math.abs(yMin) <= functionValueAccuracy) {\n             setResult(yMin, 0);\n             return result;\n         }\n \n-        // reduce interval if min and initial bracket the root\n-        if (yInitial * yMin < 0) {\n-            return solve(f, min, yMin, initial, yInitial, min, yMin);\n-        }\n+        double b = initial;\n+\t\tdouble x1 = max;\n+\t\tclearResult();\n \n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n@@ -134,7 +137,8 @@\n         }\n \n \n-        // full Brent algorithm starting with provided initial guess\n+        verifySequence(min, initial, max);\n+\t\t// full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n \n     }\n@@ -172,7 +176,8 @@\n         // Verify bracketing\n         double sign = yMin * yMax;\n         if (sign > 0) {\n-            // check if either value is close to a zero\n+            resultComputed = true;\n+\t\t\t// check if either value is close to a zero\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n@@ -274,7 +279,8 @@\n                     p1 = (r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);\n                 }\n                 if (p > 0.0) {\n-                    p1 = -p1;\n+                    x0 = x1;\n+\t\t\t\t\tp1 = -p1;\n                 } else {\n                     p = -p;\n                 }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "InsertBefore", 
          "seed": "double b=initial;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "Replace", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "double a=initial;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "verifySequence(min,initial,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "InsertBefore", 
          "seed": "double x1=max;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 277, 
          "faulty": "p1=-p1;", 
          "type": "InsertBefore", 
          "seed": "x0=x1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_598/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:57:58.851441361 -0500\n@@ -99,7 +99,7 @@\n                         final double min, final double max, final double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n \n-        clearResult();\n+        verifySequence(min, initial, max);\n         verifySequence(min, initial, max);\n \n         // return the initial guess if it is good enough\n@@ -111,12 +111,10 @@\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if min and initial bracket the root\n+        verifyBracketing(min, max, f);\n+\t\tverifyBracketing(min, max, f);\n+\t\tdouble b = initial;\n+\t\t// reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n@@ -134,7 +132,9 @@\n         }\n \n \n-        // full Brent algorithm starting with provided initial guess\n+        checkResultComputed();\n+\t\tverifySequence(min, initial, max);\n+\t\t// full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n \n     }\n@@ -172,7 +172,8 @@\n         // Verify bracketing\n         double sign = yMin * yMax;\n         if (sign > 0) {\n-            // check if either value is close to a zero\n+            resultComputed = true;\n+\t\t\t// check if either value is close to a zero\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n@@ -284,7 +285,18 @@\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n+                    if (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (delta / oldDelta > 1) {\n+\t\t\t\t\t\tdelta = 0.5 * oldDelta;\n+\t\t\t\t\t}\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "InsertBefore", 
          "seed": "double b=initial;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "checkResultComputed();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "verifySequence(min,initial,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "Replace", 
          "seed": "if (delta / oldDelta > 1) {\n  delta=0.5 * oldDelta;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "setup(f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 102, 
          "faulty": "clearResult();", 
          "type": "Replace", 
          "seed": "verifySequence(min,initial,max);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_713/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 12:03:35.596012008 -0500\n@@ -99,7 +99,7 @@\n                         final double min, final double max, final double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n \n-        clearResult();\n+        verifySequence(min, initial, max);\n         verifySequence(min, initial, max);\n \n         // return the initial guess if it is good enough\n@@ -111,17 +111,18 @@\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if min and initial bracket the root\n+        verifyBracketing(min, max, f);\n+\t\tverifyBracketing(min, max, f);\n+\t\tdouble b = initial;\n+\t\t// reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n \n-        // return the second endpoint if it is good enough\n+        if (yInitial * yMin < 0) {\n+\t\t\treturn solve(f, min, yMin, initial, yInitial, min, yMin);\n+\t\t}\n+\t\t// return the second endpoint if it is good enough\n         double yMax = f.value(max);\n         if (Math.abs(yMax) <= functionValueAccuracy) {\n             setResult(yMax, 0);\n@@ -134,7 +135,8 @@\n         }\n \n \n-        // full Brent algorithm starting with provided initial guess\n+        verifySequence(min, initial, max);\n+\t\t// full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n \n     }\n@@ -172,7 +174,10 @@\n         // Verify bracketing\n         double sign = yMin * yMax;\n         if (sign > 0) {\n-            // check if either value is close to a zero\n+            resultComputed = true;\n+\t\t\tresultComputed = true;\n+\t\t\tresultComputed = true;\n+\t\t\t// check if either value is close to a zero\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n@@ -284,7 +289,15 @@\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n+                    if (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (delta / oldDelta > 1) {\n+\t\t\t\t\t\tdelta = 0.5 * oldDelta;\n+\t\t\t\t\t}\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "verifySequence(min,initial,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "Replace", 
          "seed": "if (delta / oldDelta > 1) {\n  delta=0.5 * oldDelta;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "setup(f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 102, 
          "faulty": "clearResult();", 
          "type": "Replace", 
          "seed": "verifySequence(min,initial,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "InsertBefore", 
          "seed": "double b=initial;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "setup(f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 125, 
          "faulty": "double yMax=f.value(max);", 
          "type": "InsertBefore", 
          "seed": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_677/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 12:01:45.499818205 -0500\n@@ -99,29 +99,31 @@\n                         final double min, final double max, final double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n \n-        clearResult();\n+        verifySequence(min, initial, max);\n         verifySequence(min, initial, max);\n \n         // return the initial guess if it is good enough\n         double yInitial = f.value(initial);\n-        if (Math.abs(yInitial) <= functionValueAccuracy) {\n+        clearResult();\n+\t\tif (Math.abs(yInitial) <= functionValueAccuracy) {\n             setResult(initial, 0);\n             return result;\n         }\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if min and initial bracket the root\n+        verifyBracketing(min, max, f);\n+\t\tverifyBracketing(min, max, f);\n+\t\tdouble b = initial;\n+\t\t// reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n \n-        // return the second endpoint if it is good enough\n+        if (yInitial * yMin < 0) {\n+\t\t\treturn solve(f, min, yMin, initial, yInitial, min, yMin);\n+\t\t}\n+\t\t// return the second endpoint if it is good enough\n         double yMax = f.value(max);\n         if (Math.abs(yMax) <= functionValueAccuracy) {\n             setResult(yMax, 0);\n@@ -134,7 +136,9 @@\n         }\n \n \n-        // full Brent algorithm starting with provided initial guess\n+        checkResultComputed();\n+\t\tverifySequence(min, initial, max);\n+\t\t// full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n \n     }\n@@ -172,7 +176,10 @@\n         // Verify bracketing\n         double sign = yMin * yMax;\n         if (sign > 0) {\n-            // check if either value is close to a zero\n+            resultComputed = true;\n+\t\t\tresultComputed = true;\n+\t\t\tresultComputed = true;\n+\t\t\t// check if either value is close to a zero\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n@@ -284,7 +291,15 @@\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n+                    if (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (delta / oldDelta > 1) {\n+\t\t\t\t\t\tdelta = 0.5 * oldDelta;\n+\t\t\t\t\t}\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "checkResultComputed();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "verifySequence(min,initial,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "Replace", 
          "seed": "if (delta / oldDelta > 1) {\n  delta=0.5 * oldDelta;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "setup(f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 102, 
          "faulty": "clearResult();", 
          "type": "Replace", 
          "seed": "verifySequence(min,initial,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "InsertBefore", 
          "seed": "double b=initial;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "setup(f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 125, 
          "faulty": "double yMax=f.value(max);", 
          "type": "InsertBefore", 
          "seed": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_349/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:45:01.373772463 -0500\n@@ -111,22 +111,10 @@\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if min and initial bracket the root\n-        if (yInitial * yMin < 0) {\n-            return solve(f, min, yMin, initial, yInitial, min, yMin);\n-        }\n-\n-        // return the second endpoint if it is good enough\n+        verifyBracketing(min, max, f);\n+\t\t// return the second endpoint if it is good enough\n         double yMax = f.value(max);\n-        if (Math.abs(yMax) <= functionValueAccuracy) {\n-            setResult(yMax, 0);\n-            return result;\n-        }\n+        this.defaultFunctionValueAccuracy = 1.0e-15;\n \n         // reduce interval if initial and max bracket the root\n         if (yInitial * yMax < 0) {\n@@ -284,7 +272,10 @@\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n+                    if (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\toldDelta = delta;\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "int iterationCount=0;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "Delete", 
          "seed": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 126, 
          "faulty": "if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(yMax,0);\n  return result;\n}", 
          "type": "Replace", 
          "seed": "this.defaultFunctionValueAccuracy=1.0e-15;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_684/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 12:02:02.559846085 -0500\n@@ -111,7 +111,8 @@\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n+        verifyBracketing(min, max, f);\n+\t\tif (Math.abs(yMin) <= functionValueAccuracy) {\n             setResult(yMin, 0);\n             return result;\n         }\n@@ -128,12 +129,6 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n-\n-\n         // full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n \n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Delete", 
          "seed": "setup(f);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_847/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 12:10:33.928955661 -0500\n@@ -104,24 +104,28 @@\n \n         // return the initial guess if it is good enough\n         double yInitial = f.value(initial);\n-        if (Math.abs(yInitial) <= functionValueAccuracy) {\n+        clearResult();\n+\t\tif (Math.abs(yInitial) <= functionValueAccuracy) {\n             setResult(initial, 0);\n             return result;\n         }\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if min and initial bracket the root\n+        verifyBracketing(min, max, f);\n+\t\tif (f.value(min) == 0.0) {\n+\t\t\treturn min;\n+\t\t}\n+\t\tsetResult(initial, 0);\n+\t\t// reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n \n-        // return the second endpoint if it is good enough\n+        if (yInitial * yMin < 0) {\n+\t\t\treturn solve(f, min, yMin, initial, yInitial, min, yMin);\n+\t\t}\n+\t\t// return the second endpoint if it is good enough\n         double yMax = f.value(max);\n         if (Math.abs(yMax) <= functionValueAccuracy) {\n             setResult(yMax, 0);\n@@ -134,7 +138,8 @@\n         }\n \n \n-        // full Brent algorithm starting with provided initial guess\n+        checkResultComputed();\n+\t\t// full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n \n     }\n@@ -172,7 +177,8 @@\n         // Verify bracketing\n         double sign = yMin * yMax;\n         if (sign > 0) {\n-            // check if either value is close to a zero\n+            resultComputed = true;\n+\t\t\t// check if either value is close to a zero\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "checkResultComputed();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "setup(f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 125, 
          "faulty": "double yMax=f.value(max);", 
          "type": "InsertBefore", 
          "seed": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "if (f.value(min) == 0.0) {\n  return min;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "double x2=max;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "setResult(initial,0);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_370/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:46:04.937921326 -0500\n@@ -111,22 +111,16 @@\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if min and initial bracket the root\n+        verifyBracketing(min, max, f);\n+\t\tdouble b = initial;\n+\t\t// reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n \n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n-        if (Math.abs(yMax) <= functionValueAccuracy) {\n-            setResult(yMax, 0);\n-            return result;\n-        }\n+        this.defaultFunctionValueAccuracy = 1.0e-15;\n \n         // reduce interval if initial and max bracket the root\n         if (yInitial * yMax < 0) {\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "int iterationCount=0;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 126, 
          "faulty": "if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(yMax,0);\n  return result;\n}", 
          "type": "Replace", 
          "seed": "this.defaultFunctionValueAccuracy=1.0e-15;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "InsertBefore", 
          "seed": "double b=initial;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_579/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:56:59.835340296 -0500\n@@ -99,27 +99,28 @@\n                         final double min, final double max, final double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n \n-        clearResult();\n+        this.resultComputed = false;\n         verifySequence(min, initial, max);\n \n         // return the initial guess if it is good enough\n         double yInitial = f.value(initial);\n-        if (Math.abs(yInitial) <= functionValueAccuracy) {\n+        clearResult();\n+\t\tif (Math.abs(yInitial) <= functionValueAccuracy) {\n             setResult(initial, 0);\n             return result;\n         }\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n+        verifyBracketing(min, max, f);\n+\t\tverifyBracketing(min, max, f);\n+\t\tif (Math.abs(yMin) <= functionValueAccuracy) {\n             setResult(yMin, 0);\n             return result;\n         }\n \n-        // reduce interval if min and initial bracket the root\n-        if (yInitial * yMin < 0) {\n-            return solve(f, min, yMin, initial, yInitial, min, yMin);\n-        }\n+        double b = initial;\n+\t\tclearResult();\n \n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n@@ -172,7 +173,8 @@\n         // Verify bracketing\n         double sign = yMin * yMax;\n         if (sign > 0) {\n-            // check if either value is close to a zero\n+            resultComputed = true;\n+\t\t\t// check if either value is close to a zero\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n@@ -284,7 +286,13 @@\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n+                    if (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\toldDelta = delta;\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "Replace", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 102, 
          "faulty": "clearResult();", 
          "type": "Replace", 
          "seed": "this.resultComputed=false;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "InsertBefore", 
          "seed": "double b=initial;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_603/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:58:09.031458635 -0500\n@@ -111,12 +111,10 @@\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if min and initial bracket the root\n+        verifyBracketing(min, max, f);\n+\t\tthis.resultComputed = false;\n+\t\tdouble b = initial;\n+\t\t// reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n@@ -172,7 +170,8 @@\n         // Verify bracketing\n         double sign = yMin * yMax;\n         if (sign > 0) {\n-            // check if either value is close to a zero\n+            resultComputed = true;\n+\t\t\t// check if either value is close to a zero\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "InsertBefore", 
          "seed": "double b=initial;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "setup(f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "this.resultComputed=false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_583/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:57:10.119358029 -0500\n@@ -111,12 +111,8 @@\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if min and initial bracket the root\n+        verifyBracketing(min, max, f);\n+\t\t// reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n@@ -134,7 +130,8 @@\n         }\n \n \n-        // full Brent algorithm starting with provided initial guess\n+        verifySequence(min, initial, max);\n+\t\t// full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n \n     }\n@@ -172,7 +169,8 @@\n         // Verify bracketing\n         double sign = yMin * yMax;\n         if (sign > 0) {\n-            // check if either value is close to a zero\n+            resultComputed = true;\n+\t\t\t// check if either value is close to a zero\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n@@ -284,7 +282,15 @@\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n+                    if (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (delta / oldDelta > 1) {\n+\t\t\t\t\t\tdelta = 0.5 * oldDelta;\n+\t\t\t\t\t}\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "verifySequence(min,initial,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "Replace", 
          "seed": "if (delta / oldDelta > 1) {\n  delta=0.5 * oldDelta;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "setup(f);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_399/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:47:38.858170600 -0500\n@@ -104,29 +104,24 @@\n \n         // return the initial guess if it is good enough\n         double yInitial = f.value(initial);\n-        if (Math.abs(yInitial) <= functionValueAccuracy) {\n+        verifySequence(min, initial, max);\n+\t\tif (Math.abs(yInitial) <= functionValueAccuracy) {\n             setResult(initial, 0);\n             return result;\n         }\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if min and initial bracket the root\n+        verifyBracketing(min, max, f);\n+\t\tdouble b = initial;\n+\t\t// reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n \n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n-        if (Math.abs(yMax) <= functionValueAccuracy) {\n-            setResult(yMax, 0);\n-            return result;\n-        }\n+        this.defaultFunctionValueAccuracy = 1.0e-15;\n \n         // reduce interval if initial and max bracket the root\n         if (yInitial * yMax < 0) {\n@@ -172,7 +167,8 @@\n         // Verify bracketing\n         double sign = yMin * yMax;\n         if (sign > 0) {\n-            // check if either value is close to a zero\n+            resultComputed = true;\n+\t\t\t// check if either value is close to a zero\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifySequence(min,initial,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "int iterationCount=0;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 126, 
          "faulty": "if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(yMax,0);\n  return result;\n}", 
          "type": "Replace", 
          "seed": "this.defaultFunctionValueAccuracy=1.0e-15;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "InsertBefore", 
          "seed": "double b=initial;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_1152/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 12:27:11.566959793 -0500\n@@ -104,24 +104,22 @@\n \n         // return the initial guess if it is good enough\n         double yInitial = f.value(initial);\n-        if (Math.abs(yInitial) <= functionValueAccuracy) {\n+        clearResult();\n+\t\tif (Math.abs(yInitial) <= functionValueAccuracy) {\n             setResult(initial, 0);\n             return result;\n         }\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if min and initial bracket the root\n+        verifyBracketing(min, max, f);\n+\t\t// reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n \n-        // return the second endpoint if it is good enough\n+        verifyInterval(min, max);\n+\t\t// return the second endpoint if it is good enough\n         double yMax = f.value(max);\n         if (Math.abs(yMax) <= functionValueAccuracy) {\n             setResult(yMax, 0);\n@@ -134,7 +132,8 @@\n         }\n \n \n-        // full Brent algorithm starting with provided initial guess\n+        checkResultComputed();\n+\t\t// full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n \n     }\n@@ -172,7 +171,8 @@\n         // Verify bracketing\n         double sign = yMin * yMax;\n         if (sign > 0) {\n-            // check if either value is close to a zero\n+            resultComputed = true;\n+\t\t\t// check if either value is close to a zero\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "checkResultComputed();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "setup(f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 125, 
          "faulty": "double yMax=f.value(max);", 
          "type": "InsertBefore", 
          "seed": "verifyInterval(min,max);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_618/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:58:51.743530674 -0500\n@@ -99,7 +99,8 @@\n                         final double min, final double max, final double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n \n-        clearResult();\n+        verifyInterval(min, max);\n+\t\tclearResult();\n         verifySequence(min, initial, max);\n \n         // return the initial guess if it is good enough\n@@ -111,12 +112,14 @@\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n+        verifyBracketing(min, max, f);\n+\t\tif (Math.abs(yMin) <= functionValueAccuracy) {\n             setResult(yMin, 0);\n             return result;\n         }\n \n-        // reduce interval if min and initial bracket the root\n+        double x1 = max;\n+\t\t// reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n@@ -128,13 +131,8 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n-\n-\n-        // full Brent algorithm starting with provided initial guess\n+        verifySequence(min, initial, max);\n+\t\t// full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n \n     }\n@@ -274,7 +272,8 @@\n                     p1 = (r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);\n                 }\n                 if (p > 0.0) {\n-                    p1 = -p1;\n+                    x0 = x1;\n+\t\t\t\t\tp1 = -p1;\n                 } else {\n                     p = -p;\n                 }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "verifySequence(min,initial,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "InsertBefore", 
          "seed": "double x1=max;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 277, 
          "faulty": "p1=-p1;", 
          "type": "InsertBefore", 
          "seed": "x0=x1;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 102, 
          "faulty": "clearResult();", 
          "type": "InsertBefore", 
          "seed": "verifyInterval(min,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Delete", 
          "seed": "return solve2(f,min,max);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_553/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:55:41.623203417 -0500\n@@ -104,29 +104,26 @@\n \n         // return the initial guess if it is good enough\n         double yInitial = f.value(initial);\n-        if (Math.abs(yInitial) <= functionValueAccuracy) {\n+        double a = initial;\n+\t\tif (Math.abs(yInitial) <= functionValueAccuracy) {\n             setResult(initial, 0);\n             return result;\n         }\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n+        verifyBracketing(min, max, f);\n+\t\tif (Math.abs(yMin) <= functionValueAccuracy) {\n             setResult(yMin, 0);\n             return result;\n         }\n \n-        // reduce interval if min and initial bracket the root\n-        if (yInitial * yMin < 0) {\n-            return solve(f, min, yMin, initial, yInitial, min, yMin);\n-        }\n+        double x1 = max;\n+\t\tclearResult();\n \n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n-        if (Math.abs(yMax) <= functionValueAccuracy) {\n-            setResult(yMax, 0);\n-            return result;\n-        }\n+        this.defaultFunctionValueAccuracy = 1.0e-15;\n \n         // reduce interval if initial and max bracket the root\n         if (yInitial * yMax < 0) {\n@@ -134,7 +131,8 @@\n         }\n \n \n-        // full Brent algorithm starting with provided initial guess\n+        verifySequence(min, initial, max);\n+\t\t// full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n \n     }\n@@ -284,7 +282,10 @@\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n+                    if (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\toldDelta = delta;\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 126, 
          "faulty": "if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(yMax,0);\n  return result;\n}", 
          "type": "Replace", 
          "seed": "this.defaultFunctionValueAccuracy=1.0e-15;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "Replace", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "double a=initial;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "verifySequence(min,initial,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "InsertBefore", 
          "seed": "double x1=max;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_801/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 12:08:11.828622127 -0500\n@@ -99,19 +99,24 @@\n                         final double min, final double max, final double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n \n-        clearResult();\n+        verifySequence(min, initial, max);\n         verifySequence(min, initial, max);\n \n         // return the initial guess if it is good enough\n         double yInitial = f.value(initial);\n-        if (Math.abs(yInitial) <= functionValueAccuracy) {\n+        clearResult();\n+\t\tclearResult();\n+\t\tif (Math.abs(yInitial) <= functionValueAccuracy) {\n             setResult(initial, 0);\n             return result;\n         }\n \n-        // return the first endpoint if it is good enough\n+        this.defaultFunctionValueAccuracy = 1.0e-15;\n+\t\t// return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n+        verifyBracketing(min, max, f);\n+\t\tverifyBracketing(min, max, f);\n+\t\tif (Math.abs(yMin) <= functionValueAccuracy) {\n             setResult(yMin, 0);\n             return result;\n         }\n@@ -128,13 +133,15 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n         if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+\t\t\treturn solve(f, initial, yInitial, max, yMax, initial, yInitial);\n+\t\t}\n \n \n-        // full Brent algorithm starting with provided initial guess\n+        checkResultComputed();\n+\t\tcheckResultComputed();\n+\t\tverifySequence(min, initial, max);\n+\t\t// full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n \n     }\n@@ -172,7 +179,10 @@\n         // Verify bracketing\n         double sign = yMin * yMax;\n         if (sign > 0) {\n-            // check if either value is close to a zero\n+            resultComputed = true;\n+\t\t\tresultComputed = true;\n+\t\t\tresultComputed = true;\n+\t\t\t// check if either value is close to a zero\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n@@ -180,7 +190,8 @@\n                 setResult(max, 0);\n                 ret = max;\n             } else {\n-                // neither value is close to zero and min and max do not bracket root.\n+                this.f = f;\n+\t\t\t\t// neither value is close to zero and min and max do not bracket root.\n                 throw MathRuntimeException.createIllegalArgumentException(\n                         NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n             }\n@@ -280,11 +291,23 @@\n                 }\n                 if (2.0 * p >= 1.5 * dx * p1 - Math.abs(tolerance * p1) ||\n                         p >= Math.abs(0.5 * oldDelta * p1)) {\n-                    // Inverse quadratic interpolation gives a value\n+                    double r2 = y1 / y2;\n+\t\t\t\t\t// Inverse quadratic interpolation gives a value\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n+                    if (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (delta / oldDelta > 1) {\n+\t\t\t\t\t\tdelta = 0.5 * oldDelta;\n+\t\t\t\t\t}\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "checkResultComputed();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "checkResultComputed();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "verifySequence(min,initial,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "Replace", 
          "seed": "if (delta / oldDelta > 1) {\n  delta=0.5 * oldDelta;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 113, 
          "faulty": "double yMin=f.value(min);", 
          "type": "InsertBefore", 
          "seed": "this.defaultFunctionValueAccuracy=1.0e-15;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 102, 
          "faulty": "clearResult();", 
          "type": "Replace", 
          "seed": "verifySequence(min,initial,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 184, 
          "faulty": "throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);", 
          "type": "InsertBefore", 
          "seed": "this.f=f;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 286, 
          "faulty": "delta=0.5 * dx;", 
          "type": "InsertBefore", 
          "seed": "double r2=y1 / y2;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_749/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 12:05:32.444275002 -0500\n@@ -99,7 +99,6 @@\n                         final double min, final double max, final double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n \n-        clearResult();\n         verifySequence(min, initial, max);\n \n         // return the initial guess if it is good enough\n@@ -111,17 +110,17 @@\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if min and initial bracket the root\n+        verifyBracketing(min, max, f);\n+\t\tdouble b = initial;\n+\t\t// reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n \n-        // return the second endpoint if it is good enough\n+        if (yInitial * yMin < 0) {\n+\t\t\treturn solve(f, min, yMin, initial, yInitial, min, yMin);\n+\t\t}\n+\t\t// return the second endpoint if it is good enough\n         double yMax = f.value(max);\n         if (Math.abs(yMax) <= functionValueAccuracy) {\n             setResult(yMax, 0);\n@@ -172,7 +171,8 @@\n         // Verify bracketing\n         double sign = yMin * yMax;\n         if (sign > 0) {\n-            // check if either value is close to a zero\n+            resultComputed = true;\n+\t\t\t// check if either value is close to a zero\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n@@ -284,7 +284,13 @@\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n+                    if (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\toldDelta = delta;\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "InsertBefore", 
          "seed": "double b=initial;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "setup(f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 125, 
          "faulty": "double yMax=f.value(max);", 
          "type": "InsertBefore", 
          "seed": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 102, 
          "faulty": "clearResult();", 
          "type": "Delete", 
          "seed": "Complex H=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_434/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:49:34.086467121 -0500\n@@ -111,12 +111,14 @@\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n+        verifyBracketing(min, max, f);\n+\t\tif (Math.abs(yMin) <= functionValueAccuracy) {\n             setResult(yMin, 0);\n             return result;\n         }\n \n-        // reduce interval if min and initial bracket the root\n+        double b = initial;\n+\t\t// reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "InsertBefore", 
          "seed": "double b=initial;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_365/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:45:52.545893335 -0500\n@@ -99,10 +99,12 @@\n                         final double min, final double max, final double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n \n-        clearResult();\n+        this.resultComputed = false;\n+\t\tclearResult();\n         verifySequence(min, initial, max);\n \n-        // return the initial guess if it is good enough\n+        int i = 0;\n+\t\t// return the initial guess if it is good enough\n         double yInitial = f.value(initial);\n         if (Math.abs(yInitial) <= functionValueAccuracy) {\n             setResult(initial, 0);\n@@ -111,23 +113,20 @@\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n+        verifyBracketing(min, max, f);\n+\t\tif (Math.abs(yMin) <= functionValueAccuracy) {\n             setResult(yMin, 0);\n             return result;\n         }\n \n-        // reduce interval if min and initial bracket the root\n+        double b = initial;\n+\t\t// reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n \n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n-        if (Math.abs(yMax) <= functionValueAccuracy) {\n-            setResult(yMax, 0);\n-            return result;\n-        }\n-\n         // reduce interval if initial and max bracket the root\n         if (yInitial * yMax < 0) {\n             return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n@@ -284,7 +283,13 @@\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n+                    if (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\toldDelta = delta;\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 126, 
          "faulty": "if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(yMax,0);\n  return result;\n}", 
          "type": "Replace", 
          "seed": "this.defaultFunctionValueAccuracy=1.0e-15;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "InsertBefore", 
          "seed": "double b=initial;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 102, 
          "faulty": "clearResult();", 
          "type": "InsertBefore", 
          "seed": "this.resultComputed=false;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 106, 
          "faulty": "double yInitial=f.value(initial);", 
          "type": "InsertBefore", 
          "seed": "int i=0;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 126, 
          "faulty": "if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(yMax,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "functionValueAccuracy=defaultFunctionValueAccuracy;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_517/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:53:50.263000476 -0500\n@@ -104,14 +104,16 @@\n \n         // return the initial guess if it is good enough\n         double yInitial = f.value(initial);\n-        if (Math.abs(yInitial) <= functionValueAccuracy) {\n+        clearResult();\n+\t\tif (Math.abs(yInitial) <= functionValueAccuracy) {\n             setResult(initial, 0);\n             return result;\n         }\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n+        verifyBracketing(min, max, f);\n+\t\tif (Math.abs(yMin) <= functionValueAccuracy) {\n             setResult(yMin, 0);\n             return result;\n         }\n@@ -134,7 +136,9 @@\n         }\n \n \n-        // full Brent algorithm starting with provided initial guess\n+        checkResultComputed();\n+\t\tverifySequence(min, initial, max);\n+\t\t// full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n \n     }\n@@ -172,7 +176,8 @@\n         // Verify bracketing\n         double sign = yMin * yMax;\n         if (sign > 0) {\n-            // check if either value is close to a zero\n+            resultComputed = true;\n+\t\t\t// check if either value is close to a zero\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n@@ -284,7 +289,15 @@\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n+                    if (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (delta / oldDelta > 1) {\n+\t\t\t\t\t\tdelta = 0.5 * oldDelta;\n+\t\t\t\t\t}\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "checkResultComputed();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "verifySequence(min,initial,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "Replace", 
          "seed": "if (delta / oldDelta > 1) {\n  delta=0.5 * oldDelta;\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_336/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:44:30.449694745 -0500\n@@ -104,22 +104,24 @@\n \n         // return the initial guess if it is good enough\n         double yInitial = f.value(initial);\n-        if (Math.abs(yInitial) <= functionValueAccuracy) {\n+        clearResult();\n+\t\tdouble a = initial;\n+\t\tif (Math.abs(yInitial) <= functionValueAccuracy) {\n             setResult(initial, 0);\n             return result;\n         }\n \n-        // return the first endpoint if it is good enough\n+        double ret = Double.NaN;\n+\t\t// return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n+        verifyBracketing(min, max, f);\n+\t\tif (Math.abs(yMin) <= functionValueAccuracy) {\n             setResult(yMin, 0);\n             return result;\n         }\n \n-        // reduce interval if min and initial bracket the root\n-        if (yInitial * yMin < 0) {\n-            return solve(f, min, yMin, initial, yInitial, min, yMin);\n-        }\n+        double b = initial;\n+\t\tclearResult();\n \n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n@@ -180,7 +182,8 @@\n                 setResult(max, 0);\n                 ret = max;\n             } else {\n-                // neither value is close to zero and min and max do not bracket root.\n+                this.functionValueAccuracy = defaultFunctionValueAccuracy;\n+\t\t\t\t// neither value is close to zero and min and max do not bracket root.\n                 throw MathRuntimeException.createIllegalArgumentException(\n                         NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n             }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 184, 
          "faulty": "throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);", 
          "type": "InsertBefore", 
          "seed": "this.functionValueAccuracy=defaultFunctionValueAccuracy;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "Replace", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "double a=initial;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "InsertBefore", 
          "seed": "double b=initial;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 113, 
          "faulty": "double yMin=f.value(min);", 
          "type": "InsertBefore", 
          "seed": "double ret=Double.NaN;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_241/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:39:14.504741624 -0500\n@@ -111,7 +111,8 @@\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n+        verifyBracketing(min, max, f);\n+\t\tif (Math.abs(yMin) <= functionValueAccuracy) {\n             setResult(yMin, 0);\n             return result;\n         }\n@@ -123,10 +124,7 @@\n \n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n-        if (Math.abs(yMax) <= functionValueAccuracy) {\n-            setResult(yMax, 0);\n-            return result;\n-        }\n+        this.defaultFunctionValueAccuracy = 1.0e-15;\n \n         // reduce interval if initial and max bracket the root\n         if (yInitial * yMax < 0) {\n@@ -284,7 +282,13 @@\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n+                    if (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\toldDelta = delta;\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 126, 
          "faulty": "if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(yMax,0);\n  return result;\n}", 
          "type": "Replace", 
          "seed": "this.defaultFunctionValueAccuracy=1.0e-15;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_1259/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 12:32:51.223774361 -0500\n@@ -99,42 +99,37 @@\n                         final double min, final double max, final double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n \n-        clearResult();\n+        double x0 = min;\n         verifySequence(min, initial, max);\n \n         // return the initial guess if it is good enough\n         double yInitial = f.value(initial);\n-        if (Math.abs(yInitial) <= functionValueAccuracy) {\n+        clearResult();\n+\t\tif (Math.abs(yInitial) <= functionValueAccuracy) {\n             setResult(initial, 0);\n             return result;\n         }\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if min and initial bracket the root\n+        verifyBracketing(min, max, f);\n+\t\tverifyBracketing(min, max, f);\n+\t\t// reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n \n-        // return the second endpoint if it is good enough\n+        verifyInterval(min, max);\n+\t\t// return the second endpoint if it is good enough\n         double yMax = f.value(max);\n-        if (Math.abs(yMax) <= functionValueAccuracy) {\n-            setResult(yMax, 0);\n-            return result;\n-        }\n-\n         // reduce interval if initial and max bracket the root\n         if (yInitial * yMax < 0) {\n             return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n         }\n \n \n-        // full Brent algorithm starting with provided initial guess\n+        checkResultComputed();\n+\t\t// full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n \n     }\n@@ -172,7 +167,10 @@\n         // Verify bracketing\n         double sign = yMin * yMax;\n         if (sign > 0) {\n-            // check if either value is close to a zero\n+            resultComputed = true;\n+\t\t\tresultComputed = true;\n+\t\t\tresultComputed = true;\n+\t\t\t// check if either value is close to a zero\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "checkResultComputed();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "setup(f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 125, 
          "faulty": "double yMax=f.value(max);", 
          "type": "InsertBefore", 
          "seed": "verifyInterval(min,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 102, 
          "faulty": "clearResult();", 
          "type": "Replace", 
          "seed": "double x0=min;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 126, 
          "faulty": "if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(yMax,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "Complex d2v=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_471/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:51:32.750729718 -0500\n@@ -104,23 +104,21 @@\n \n         // return the initial guess if it is good enough\n         double yInitial = f.value(initial);\n-        if (Math.abs(yInitial) <= functionValueAccuracy) {\n+        clearResult();\n+\t\tdouble a = initial;\n+\t\tif (Math.abs(yInitial) <= functionValueAccuracy) {\n             setResult(initial, 0);\n             return result;\n         }\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n+        verifyBracketing(min, max, f);\n+\t\tif (Math.abs(yMin) <= functionValueAccuracy) {\n             setResult(yMin, 0);\n             return result;\n         }\n \n-        // reduce interval if min and initial bracket the root\n-        if (yInitial * yMin < 0) {\n-            return solve(f, min, yMin, initial, yInitial, min, yMin);\n-        }\n-\n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n         if (Math.abs(yMax) <= functionValueAccuracy) {\n@@ -134,7 +132,8 @@\n         }\n \n \n-        // full Brent algorithm starting with provided initial guess\n+        verifySequence(min, initial, max);\n+\t\t// full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n \n     }\n@@ -172,7 +171,8 @@\n         // Verify bracketing\n         double sign = yMin * yMax;\n         if (sign > 0) {\n-            // check if either value is close to a zero\n+            resultComputed = true;\n+\t\t\t// check if either value is close to a zero\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "Replace", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "double a=initial;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "verifySequence(min,initial,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "Delete", 
          "seed": "return min;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_346/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:44:54.621755817 -0500\n@@ -104,22 +104,23 @@\n \n         // return the initial guess if it is good enough\n         double yInitial = f.value(initial);\n-        if (Math.abs(yInitial) <= functionValueAccuracy) {\n+        clearResult();\n+\t\tdouble a = initial;\n+\t\tif (Math.abs(yInitial) <= functionValueAccuracy) {\n             setResult(initial, 0);\n             return result;\n         }\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n+        verifyBracketing(min, max, f);\n+\t\tif (Math.abs(yMin) <= functionValueAccuracy) {\n             setResult(yMin, 0);\n             return result;\n         }\n \n-        // reduce interval if min and initial bracket the root\n-        if (yInitial * yMin < 0) {\n-            return solve(f, min, yMin, initial, yInitial, min, yMin);\n-        }\n+        double b = initial;\n+\t\tclearResult();\n \n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n@@ -172,7 +173,8 @@\n         // Verify bracketing\n         double sign = yMin * yMax;\n         if (sign > 0) {\n-            // check if either value is close to a zero\n+            resultComputed = true;\n+\t\t\t// check if either value is close to a zero\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "Replace", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "double a=initial;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "InsertBefore", 
          "seed": "double b=initial;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_1209/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 12:30:11.931378606 -0500\n@@ -99,7 +99,6 @@\n                         final double min, final double max, final double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n \n-        clearResult();\n         verifySequence(min, initial, max);\n \n         // return the initial guess if it is good enough\n@@ -111,17 +110,14 @@\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if min and initial bracket the root\n+        verifyBracketing(min, max, f);\n+\t\t// reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n \n-        // return the second endpoint if it is good enough\n+        verifyInterval(min, max);\n+\t\t// return the second endpoint if it is good enough\n         double yMax = f.value(max);\n         if (Math.abs(yMax) <= functionValueAccuracy) {\n             setResult(yMax, 0);\n@@ -172,7 +168,8 @@\n         // Verify bracketing\n         double sign = yMin * yMax;\n         if (sign > 0) {\n-            // check if either value is close to a zero\n+            resultComputed = true;\n+\t\t\t// check if either value is close to a zero\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "setup(f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 125, 
          "faulty": "double yMax=f.value(max);", 
          "type": "InsertBefore", 
          "seed": "verifyInterval(min,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 102, 
          "faulty": "clearResult();", 
          "type": "Delete", 
          "seed": "this.defaultFunctionValueAccuracy=1.0e-15;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_320/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:43:40.093559241 -0500\n@@ -104,22 +104,23 @@\n \n         // return the initial guess if it is good enough\n         double yInitial = f.value(initial);\n-        if (Math.abs(yInitial) <= functionValueAccuracy) {\n+        clearResult();\n+\t\tdouble a = initial;\n+\t\tif (Math.abs(yInitial) <= functionValueAccuracy) {\n             setResult(initial, 0);\n             return result;\n         }\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n+        verifyBracketing(min, max, f);\n+\t\tif (Math.abs(yMin) <= functionValueAccuracy) {\n             setResult(yMin, 0);\n             return result;\n         }\n \n-        // reduce interval if min and initial bracket the root\n-        if (yInitial * yMin < 0) {\n-            return solve(f, min, yMin, initial, yInitial, min, yMin);\n-        }\n+        double b = initial;\n+\t\tclearResult();\n \n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n@@ -180,7 +181,8 @@\n                 setResult(max, 0);\n                 ret = max;\n             } else {\n-                // neither value is close to zero and min and max do not bracket root.\n+                this.functionValueAccuracy = defaultFunctionValueAccuracy;\n+\t\t\t\t// neither value is close to zero and min and max do not bracket root.\n                 throw MathRuntimeException.createIllegalArgumentException(\n                         NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n             }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 184, 
          "faulty": "throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);", 
          "type": "InsertBefore", 
          "seed": "this.functionValueAccuracy=defaultFunctionValueAccuracy;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "Replace", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "double a=initial;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "InsertBefore", 
          "seed": "double b=initial;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_338/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:44:33.913703644 -0500\n@@ -111,22 +111,15 @@\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if min and initial bracket the root\n+        verifyBracketing(min, max, f);\n+\t\t// reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n \n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n-        if (Math.abs(yMax) <= functionValueAccuracy) {\n-            setResult(yMax, 0);\n-            return result;\n-        }\n+        this.defaultFunctionValueAccuracy = 1.0e-15;\n \n         // reduce interval if initial and max bracket the root\n         if (yInitial * yMax < 0) {\n@@ -284,7 +277,19 @@\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n+                    if (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\toldDelta = delta;\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 126, 
          "faulty": "if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(yMax,0);\n  return result;\n}", 
          "type": "Replace", 
          "seed": "this.defaultFunctionValueAccuracy=1.0e-15;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "Complex oldc=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_484/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:52:12.890811736 -0500\n@@ -111,7 +111,8 @@\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n+        verifyBracketing(min, max, f);\n+\t\tif (Math.abs(yMin) <= functionValueAccuracy) {\n             setResult(yMin, 0);\n             return result;\n         }\n@@ -134,7 +135,8 @@\n         }\n \n \n-        // full Brent algorithm starting with provided initial guess\n+        verifySequence(min, initial, max);\n+\t\t// full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n \n     }\n@@ -284,7 +286,13 @@\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n+                    if (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\toldDelta = delta;\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "verifySequence(min,initial,max);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_1262/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 12:32:57.931790319 -0500\n@@ -111,17 +111,14 @@\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if min and initial bracket the root\n+        verifyBracketing(min, max, f);\n+\t\t// reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n \n-        // return the second endpoint if it is good enough\n+        verifyInterval(min, max);\n+\t\t// return the second endpoint if it is good enough\n         double yMax = f.value(max);\n         if (Math.abs(yMax) <= functionValueAccuracy) {\n             setResult(yMax, 0);\n@@ -134,7 +131,8 @@\n         }\n \n \n-        // full Brent algorithm starting with provided initial guess\n+        checkResultComputed();\n+\t\t// full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n \n     }\n@@ -172,7 +170,9 @@\n         // Verify bracketing\n         double sign = yMin * yMax;\n         if (sign > 0) {\n-            // check if either value is close to a zero\n+            resultComputed = true;\n+\t\t\tresultComputed = true;\n+\t\t\t// check if either value is close to a zero\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n@@ -180,7 +180,8 @@\n                 setResult(max, 0);\n                 ret = max;\n             } else {\n-                // neither value is close to zero and min and max do not bracket root.\n+                double x1 = min;\n+\t\t\t\t// neither value is close to zero and min and max do not bracket root.\n                 throw MathRuntimeException.createIllegalArgumentException(\n                         NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n             }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "checkResultComputed();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "setup(f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 125, 
          "faulty": "double yMax=f.value(max);", 
          "type": "InsertBefore", 
          "seed": "verifyInterval(min,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 184, 
          "faulty": "throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);", 
          "type": "InsertBefore", 
          "seed": "double x1=min;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_495/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:52:46.234877843 -0500\n@@ -104,19 +104,22 @@\n \n         // return the initial guess if it is good enough\n         double yInitial = f.value(initial);\n-        if (Math.abs(yInitial) <= functionValueAccuracy) {\n+        clearResult();\n+\t\tif (Math.abs(yInitial) <= functionValueAccuracy) {\n             setResult(initial, 0);\n             return result;\n         }\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n+        verifyBracketing(min, max, f);\n+\t\tif (Math.abs(yMin) <= functionValueAccuracy) {\n             setResult(yMin, 0);\n             return result;\n         }\n \n-        // reduce interval if min and initial bracket the root\n+        double b = initial;\n+\t\t// reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n@@ -172,7 +175,8 @@\n         // Verify bracketing\n         double sign = yMin * yMax;\n         if (sign > 0) {\n-            // check if either value is close to a zero\n+            resultComputed = true;\n+\t\t\t// check if either value is close to a zero\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n@@ -284,7 +288,10 @@\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n+                    if (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\toldDelta = delta;\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "InsertBefore", 
          "seed": "double b=initial;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_869/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 12:11:38.325106995 -0500\n@@ -109,14 +109,12 @@\n             return result;\n         }\n \n-        // return the first endpoint if it is good enough\n+        int i = 0;\n+\t\t// return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if min and initial bracket the root\n+        verifyBracketing(min, max, f);\n+\t\tdouble b = initial;\n+\t\t// reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n@@ -134,8 +132,7 @@\n         }\n \n \n-        // full Brent algorithm starting with provided initial guess\n-        return solve(f, min, yMin, max, yMax, initial, yInitial);\n+        return max;\n \n     }\n \n@@ -172,7 +169,9 @@\n         // Verify bracketing\n         double sign = yMin * yMax;\n         if (sign > 0) {\n-            // check if either value is close to a zero\n+            resultComputed = true;\n+\t\t\tresultComputed = true;\n+\t\t\t// check if either value is close to a zero\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n@@ -284,7 +283,13 @@\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n+                    if (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\toldDelta = delta;\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "InsertBefore", 
          "seed": "double b=initial;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "setup(f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "Replace", 
          "seed": "return max;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 113, 
          "faulty": "double yMin=f.value(min);", 
          "type": "InsertBefore", 
          "seed": "int i=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_815/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 12:08:55.876726098 -0500\n@@ -104,19 +104,26 @@\n \n         // return the initial guess if it is good enough\n         double yInitial = f.value(initial);\n-        if (Math.abs(yInitial) <= functionValueAccuracy) {\n+        clearResult();\n+\t\tclearResult();\n+\t\tdouble x2 = max;\n+\t\tif (Math.abs(yInitial) <= functionValueAccuracy) {\n             setResult(initial, 0);\n             return result;\n         }\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n+        verifyBracketing(min, max, f);\n+\t\tverifyBracketing(min, max, f);\n+\t\tverifyBracketing(min, max, f);\n+\t\tif (Math.abs(yMin) <= functionValueAccuracy) {\n             setResult(yMin, 0);\n             return result;\n         }\n \n-        // reduce interval if min and initial bracket the root\n+        double x1 = max;\n+\t\t// reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n@@ -134,7 +141,19 @@\n         }\n \n \n-        // full Brent algorithm starting with provided initial guess\n+        checkResultComputed();\n+\t\tif (f == null) {\n+\t\t\tthrow MathRuntimeException\n+\t\t\t\t\t.createIllegalArgumentException(\"function to solve cannot be null\");\n+\t\t}\n+\t\tcheckResultComputed();\n+\t\tverifySequence(min, initial, max);\n+\t\tcheckResultComputed();\n+\t\tif (f == null) {\n+\t\t\tthrow MathRuntimeException\n+\t\t\t\t\t.createIllegalArgumentException(\"function to solve cannot be null\");\n+\t\t}\n+\t\t// full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n \n     }\n@@ -172,7 +191,8 @@\n         // Verify bracketing\n         double sign = yMin * yMax;\n         if (sign > 0) {\n-            // check if either value is close to a zero\n+            resultComputed = true;\n+\t\t\t// check if either value is close to a zero\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n@@ -284,7 +304,13 @@\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n+                    if (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\toldDelta = delta;\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "checkResultComputed();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "if (f == null) {\n  throw MathRuntimeException.createIllegalArgumentException(\"function to solve cannot be null\");\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "InsertBefore", 
          "seed": "double x1=max;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "checkResultComputed();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "verifySequence(min,initial,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "checkResultComputed();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "if (f == null) {\n  throw MathRuntimeException.createIllegalArgumentException(\"function to solve cannot be null\");\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "double x2=max;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_692/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 12:02:25.959884247 -0500\n@@ -99,9 +99,7 @@\n                         final double min, final double max, final double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n \n-        clearResult();\n         verifySequence(min, initial, max);\n-\n         // return the initial guess if it is good enough\n         double yInitial = f.value(initial);\n         if (Math.abs(yInitial) <= functionValueAccuracy) {\n@@ -109,14 +107,12 @@\n             return result;\n         }\n \n-        // return the first endpoint if it is good enough\n+        this.defaultFunctionValueAccuracy = 1.0e-15;\n+\t\t// return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if min and initial bracket the root\n+        verifyBracketing(min, max, f);\n+\t\tdouble b = initial;\n+\t\t// reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n@@ -134,7 +130,8 @@\n         }\n \n \n-        // full Brent algorithm starting with provided initial guess\n+        verifySequence(min, initial, max);\n+\t\t// full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n \n     }\n@@ -172,7 +169,9 @@\n         // Verify bracketing\n         double sign = yMin * yMax;\n         if (sign > 0) {\n-            // check if either value is close to a zero\n+            resultComputed = true;\n+\t\t\tresultComputed = true;\n+\t\t\t// check if either value is close to a zero\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n@@ -284,7 +283,15 @@\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n+                    if (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (delta / oldDelta > 1) {\n+\t\t\t\t\t\tdelta = 0.5 * oldDelta;\n+\t\t\t\t\t}\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "verifySequence(min,initial,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "Replace", 
          "seed": "if (delta / oldDelta > 1) {\n  delta=0.5 * oldDelta;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 113, 
          "faulty": "double yMin=f.value(min);", 
          "type": "InsertBefore", 
          "seed": "this.defaultFunctionValueAccuracy=1.0e-15;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 102, 
          "faulty": "clearResult();", 
          "type": "Replace", 
          "seed": "verifySequence(min,initial,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "InsertBefore", 
          "seed": "double b=initial;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "setup(f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 103, 
          "faulty": "verifySequence(min,initial,max);", 
          "type": "Delete", 
          "seed": "Complex denominator=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_1189/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 12:29:08.367221985 -0500\n@@ -111,17 +111,14 @@\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if min and initial bracket the root\n+        verifyBracketing(min, max, f);\n+\t\t// reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n \n-        // return the second endpoint if it is good enough\n+        verifyInterval(min, max);\n+\t\t// return the second endpoint if it is good enough\n         double yMax = f.value(max);\n         if (Math.abs(yMax) <= functionValueAccuracy) {\n             setResult(yMax, 0);\n@@ -134,7 +131,8 @@\n         }\n \n \n-        // full Brent algorithm starting with provided initial guess\n+        checkResultComputed();\n+\t\t// full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n \n     }\n@@ -172,7 +170,10 @@\n         // Verify bracketing\n         double sign = yMin * yMax;\n         if (sign > 0) {\n-            // check if either value is close to a zero\n+            resultComputed = true;\n+\t\t\tresultComputed = true;\n+\t\t\tresultComputed = true;\n+\t\t\t// check if either value is close to a zero\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "checkResultComputed();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "setup(f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 125, 
          "faulty": "double yMax=f.value(max);", 
          "type": "InsertBefore", 
          "seed": "verifyInterval(min,max);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_916/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 12:13:57.081417226 -0500\n@@ -104,19 +104,19 @@\n \n         // return the initial guess if it is good enough\n         double yInitial = f.value(initial);\n-        if (Math.abs(yInitial) <= functionValueAccuracy) {\n+        clearResult();\n+\t\tif (Math.abs(yInitial) <= functionValueAccuracy) {\n             setResult(initial, 0);\n             return result;\n         }\n \n-        // return the first endpoint if it is good enough\n+        int i = 0;\n+\t\t// return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if min and initial bracket the root\n+        verifyBracketing(min, max, f);\n+\t\tverifyBracketing(min, max, f);\n+\t\tdouble b = initial;\n+\t\t// reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n@@ -134,8 +134,9 @@\n         }\n \n \n-        // full Brent algorithm starting with provided initial guess\n-        return solve(f, min, yMin, max, yMax, initial, yInitial);\n+        checkResultComputed();\n+\t\tverifySequence(min, initial, max);\n+\t\treturn max;\n \n     }\n \n@@ -172,7 +173,8 @@\n         // Verify bracketing\n         double sign = yMin * yMax;\n         if (sign > 0) {\n-            // check if either value is close to a zero\n+            resultComputed = true;\n+\t\t\t// check if either value is close to a zero\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n@@ -284,7 +286,21 @@\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n+                    if (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (delta / oldDelta > 1) {\n+\t\t\t\t\t\tdelta = 0.5 * oldDelta;\n+\t\t\t\t\t}\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "checkResultComputed();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "verifySequence(min,initial,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "Replace", 
          "seed": "if (delta / oldDelta > 1) {\n  delta=0.5 * oldDelta;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "InsertBefore", 
          "seed": "double b=initial;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "setup(f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "Replace", 
          "seed": "return max;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 113, 
          "faulty": "double yMin=f.value(min);", 
          "type": "InsertBefore", 
          "seed": "int i=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_1245/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 12:32:10.739676932 -0500\n@@ -111,17 +111,15 @@\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if min and initial bracket the root\n+        verifyBracketing(min, max, f);\n+\t\tclearResult();\n+\t\t// reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n \n-        // return the second endpoint if it is good enough\n+        verifyInterval(min, max);\n+\t\t// return the second endpoint if it is good enough\n         double yMax = f.value(max);\n         if (Math.abs(yMax) <= functionValueAccuracy) {\n             setResult(yMax, 0);\n@@ -172,7 +170,8 @@\n         // Verify bracketing\n         double sign = yMin * yMax;\n         if (sign > 0) {\n-            // check if either value is close to a zero\n+            resultComputed = true;\n+\t\t\t// check if either value is close to a zero\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n@@ -284,7 +283,9 @@\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n+                    if (delta / oldDelta > 1) {\n+\t\t\t\t\t\tdelta = 0.5 * oldDelta;\n+\t\t\t\t\t}\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-02 11:24:06.671526982 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_1245/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-02 12:32:10.743676941 -0500\n@@ -222,7 +222,8 @@\n      * @throws IllegalArgumentException\n      */\n     protected void verifySequence(final double lower, final double initial, final double upper) {\n-        if (!isSequence(lower, initial, upper)) {\n+        int numIterations = 0;\n+\t\tif (!isSequence(lower, initial, upper)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n                     \"invalid interval, initial value parameters:  lower={0}, initial={1}, upper={2}\",\n                     lower, initial, upper);\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "Replace", 
          "seed": "if (delta / oldDelta > 1) {\n  delta=0.5 * oldDelta;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "setup(f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 125, 
          "faulty": "double yMax=f.value(max);", 
          "type": "InsertBefore", 
          "seed": "verifyInterval(min,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java", 
          "line": 225, 
          "faulty": "if (!isSequence(lower,initial,upper)) {\n  throw MathRuntimeException.createIllegalArgumentException(\"invalid interval, initial value parameters:  lower={0}, initial={1}, upper={2}\",lower,initial,upper);\n}", 
          "type": "InsertBefore", 
          "seed": "int numIterations=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_601/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:58:05.643452890 -0500\n@@ -99,27 +99,21 @@\n                         final double min, final double max, final double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n \n-        clearResult();\n+        verifySequence(min, initial, max);\n         verifySequence(min, initial, max);\n \n         // return the initial guess if it is good enough\n         double yInitial = f.value(initial);\n-        if (Math.abs(yInitial) <= functionValueAccuracy) {\n+        clearResult();\n+\t\tif (Math.abs(yInitial) <= functionValueAccuracy) {\n             setResult(initial, 0);\n             return result;\n         }\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if min and initial bracket the root\n-        if (yInitial * yMin < 0) {\n-            return solve(f, min, yMin, initial, yInitial, min, yMin);\n-        }\n+        verifyBracketing(min, max, f);\n+\t\tclearResult();\n \n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n@@ -134,7 +128,9 @@\n         }\n \n \n-        // full Brent algorithm starting with provided initial guess\n+        checkResultComputed();\n+\t\tverifySequence(min, initial, max);\n+\t\t// full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n \n     }\n@@ -172,7 +168,8 @@\n         // Verify bracketing\n         double sign = yMin * yMax;\n         if (sign > 0) {\n-            // check if either value is close to a zero\n+            resultComputed = true;\n+\t\t\t// check if either value is close to a zero\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n@@ -284,7 +281,15 @@\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n+                    if (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (delta / oldDelta > 1) {\n+\t\t\t\t\t\tdelta = 0.5 * oldDelta;\n+\t\t\t\t\t}\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "checkResultComputed();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "verifySequence(min,initial,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "Replace", 
          "seed": "if (delta / oldDelta > 1) {\n  delta=0.5 * oldDelta;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "setup(f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 102, 
          "faulty": "clearResult();", 
          "type": "Replace", 
          "seed": "verifySequence(min,initial,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "Replace", 
          "seed": "clearResult();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_642/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 12:00:01.395646847 -0500\n@@ -111,12 +111,8 @@\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if min and initial bracket the root\n+        verifyBracketing(min, max, f);\n+\t\t// reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n@@ -134,7 +130,8 @@\n         }\n \n \n-        // full Brent algorithm starting with provided initial guess\n+        verifySequence(min, initial, max);\n+\t\t// full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n \n     }\n@@ -284,7 +281,15 @@\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n+                    if (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (delta / oldDelta > 1) {\n+\t\t\t\t\t\tdelta = 0.5 * oldDelta;\n+\t\t\t\t\t}\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "verifySequence(min,initial,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "Replace", 
          "seed": "if (delta / oldDelta > 1) {\n  delta=0.5 * oldDelta;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "setup(f);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_765/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 12:06:20.396378764 -0500\n@@ -99,19 +99,24 @@\n                         final double min, final double max, final double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n \n-        clearResult();\n+        verifySequence(min, initial, max);\n         verifySequence(min, initial, max);\n \n         // return the initial guess if it is good enough\n         double yInitial = f.value(initial);\n-        if (Math.abs(yInitial) <= functionValueAccuracy) {\n+        clearResult();\n+\t\tclearResult();\n+\t\tif (Math.abs(yInitial) <= functionValueAccuracy) {\n             setResult(initial, 0);\n             return result;\n         }\n \n-        // return the first endpoint if it is good enough\n+        this.defaultFunctionValueAccuracy = 1.0e-15;\n+\t\t// return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n+        verifyBracketing(min, max, f);\n+\t\tverifyBracketing(min, max, f);\n+\t\tif (Math.abs(yMin) <= functionValueAccuracy) {\n             setResult(yMin, 0);\n             return result;\n         }\n@@ -128,13 +133,15 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n         if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+\t\t\treturn solve(f, initial, yInitial, max, yMax, initial, yInitial);\n+\t\t}\n \n \n-        // full Brent algorithm starting with provided initial guess\n+        checkResultComputed();\n+\t\tcheckResultComputed();\n+\t\tverifySequence(min, initial, max);\n+\t\t// full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n \n     }\n@@ -172,7 +179,10 @@\n         // Verify bracketing\n         double sign = yMin * yMax;\n         if (sign > 0) {\n-            // check if either value is close to a zero\n+            resultComputed = true;\n+\t\t\tresultComputed = true;\n+\t\t\tresultComputed = true;\n+\t\t\t// check if either value is close to a zero\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n@@ -180,7 +190,8 @@\n                 setResult(max, 0);\n                 ret = max;\n             } else {\n-                // neither value is close to zero and min and max do not bracket root.\n+                this.f = f;\n+\t\t\t\t// neither value is close to zero and min and max do not bracket root.\n                 throw MathRuntimeException.createIllegalArgumentException(\n                         NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n             }\n@@ -284,7 +295,18 @@\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n+                    if (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (delta / oldDelta > 1) {\n+\t\t\t\t\t\tdelta = 0.5 * oldDelta;\n+\t\t\t\t\t}\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "checkResultComputed();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "checkResultComputed();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "verifySequence(min,initial,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "Replace", 
          "seed": "if (delta / oldDelta > 1) {\n  delta=0.5 * oldDelta;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 113, 
          "faulty": "double yMin=f.value(min);", 
          "type": "InsertBefore", 
          "seed": "this.defaultFunctionValueAccuracy=1.0e-15;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 102, 
          "faulty": "clearResult();", 
          "type": "Replace", 
          "seed": "verifySequence(min,initial,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 184, 
          "faulty": "throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);", 
          "type": "InsertBefore", 
          "seed": "this.f=f;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_886/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 12:12:25.645215051 -0500\n@@ -104,24 +104,24 @@\n \n         // return the initial guess if it is good enough\n         double yInitial = f.value(initial);\n-        if (Math.abs(yInitial) <= functionValueAccuracy) {\n+        clearResult();\n+\t\tif (Math.abs(yInitial) <= functionValueAccuracy) {\n             setResult(initial, 0);\n             return result;\n         }\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if min and initial bracket the root\n+        verifyBracketing(min, max, f);\n+\t\t// reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n \n-        // return the second endpoint if it is good enough\n+        if (yInitial * yMin < 0) {\n+\t\t\treturn solve(f, min, yMin, initial, yInitial, min, yMin);\n+\t\t}\n+\t\t// return the second endpoint if it is good enough\n         double yMax = f.value(max);\n         if (Math.abs(yMax) <= functionValueAccuracy) {\n             setResult(yMax, 0);\n@@ -134,7 +134,8 @@\n         }\n \n \n-        // full Brent algorithm starting with provided initial guess\n+        checkResultComputed();\n+\t\t// full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n \n     }\n@@ -172,7 +173,8 @@\n         // Verify bracketing\n         double sign = yMin * yMax;\n         if (sign > 0) {\n-            // check if either value is close to a zero\n+            resultComputed = true;\n+\t\t\t// check if either value is close to a zero\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n@@ -280,7 +282,8 @@\n                 }\n                 if (2.0 * p >= 1.5 * dx * p1 - Math.abs(tolerance * p1) ||\n                         p >= Math.abs(0.5 * oldDelta * p1)) {\n-                    // Inverse quadratic interpolation gives a value\n+                    double r2 = y1 / y2;\n+\t\t\t\t\t// Inverse quadratic interpolation gives a value\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n\n\n--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-02 11:24:06.671526982 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_886/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-02 12:12:25.649215061 -0500\n@@ -206,7 +206,8 @@\n      */\n     protected void verifyInterval(final double lower, final double upper) {\n         if (lower >= upper) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n+            int i = 0;\n+\t\t\tthrow MathRuntimeException.createIllegalArgumentException(\n                     \"endpoints do not specify an interval: [{0}, {1}]\",\n                     lower, upper);\n         }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "checkResultComputed();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "setup(f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 125, 
          "faulty": "double yMax=f.value(max);", 
          "type": "InsertBefore", 
          "seed": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 286, 
          "faulty": "delta=0.5 * dx;", 
          "type": "InsertBefore", 
          "seed": "double r2=y1 / y2;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java", 
          "line": 209, 
          "faulty": "throw MathRuntimeException.createIllegalArgumentException(\"endpoints do not specify an interval: [{0}, {1}]\",lower,upper);", 
          "type": "InsertBefore", 
          "seed": "int i=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_648/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 12:00:18.139674572 -0500\n@@ -99,24 +99,23 @@\n                         final double min, final double max, final double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n \n-        clearResult();\n+        verifySequence(min, initial, max);\n         verifySequence(min, initial, max);\n \n         // return the initial guess if it is good enough\n         double yInitial = f.value(initial);\n-        if (Math.abs(yInitial) <= functionValueAccuracy) {\n+        clearResult();\n+\t\tif (Math.abs(yInitial) <= functionValueAccuracy) {\n             setResult(initial, 0);\n             return result;\n         }\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if min and initial bracket the root\n+        verifyBracketing(min, max, f);\n+\t\tverifyBracketing(min, max, f);\n+\t\tdouble b = initial;\n+\t\t// reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n@@ -134,7 +133,9 @@\n         }\n \n \n-        // full Brent algorithm starting with provided initial guess\n+        checkResultComputed();\n+\t\tverifySequence(min, initial, max);\n+\t\t// full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n \n     }\n@@ -172,7 +173,10 @@\n         // Verify bracketing\n         double sign = yMin * yMax;\n         if (sign > 0) {\n-            // check if either value is close to a zero\n+            resultComputed = true;\n+\t\t\tresultComputed = true;\n+\t\t\tresultComputed = true;\n+\t\t\t// check if either value is close to a zero\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n@@ -284,7 +288,15 @@\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n+                    if (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (delta / oldDelta > 1) {\n+\t\t\t\t\t\tdelta = 0.5 * oldDelta;\n+\t\t\t\t\t}\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "checkResultComputed();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "verifySequence(min,initial,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "Replace", 
          "seed": "if (delta / oldDelta > 1) {\n  delta=0.5 * oldDelta;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "setup(f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 102, 
          "faulty": "clearResult();", 
          "type": "Replace", 
          "seed": "verifySequence(min,initial,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "InsertBefore", 
          "seed": "double b=initial;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "setup(f);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_884/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 12:12:22.217207306 -0500\n@@ -99,28 +99,26 @@\n                         final double min, final double max, final double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n \n-        clearResult();\n+        verifySequence(min, initial, max);\n         verifySequence(min, initial, max);\n \n         // return the initial guess if it is good enough\n         double yInitial = f.value(initial);\n-        if (Math.abs(yInitial) <= functionValueAccuracy) {\n+        clearResult();\n+\t\tif (Math.abs(yInitial) <= functionValueAccuracy) {\n             setResult(initial, 0);\n             return result;\n         }\n \n-        // return the first endpoint if it is good enough\n+        this.defaultFunctionValueAccuracy = 1.0e-15;\n+\t\t// return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n+        verifyBracketing(min, max, f);\n+\t\tif (Math.abs(yMin) <= functionValueAccuracy) {\n             setResult(yMin, 0);\n             return result;\n         }\n \n-        // reduce interval if min and initial bracket the root\n-        if (yInitial * yMin < 0) {\n-            return solve(f, min, yMin, initial, yInitial, min, yMin);\n-        }\n-\n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n         if (Math.abs(yMax) <= functionValueAccuracy) {\n@@ -128,13 +126,14 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n         if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+\t\t\treturn solve(f, initial, yInitial, max, yMax, initial, yInitial);\n+\t\t}\n \n \n-        // full Brent algorithm starting with provided initial guess\n+        checkResultComputed();\n+\t\tverifySequence(min, initial, max);\n+\t\t// full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n \n     }\n@@ -172,7 +171,9 @@\n         // Verify bracketing\n         double sign = yMin * yMax;\n         if (sign > 0) {\n-            // check if either value is close to a zero\n+            resultComputed = true;\n+\t\t\tresultComputed = true;\n+\t\t\t// check if either value is close to a zero\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n@@ -180,7 +181,8 @@\n                 setResult(max, 0);\n                 ret = max;\n             } else {\n-                // neither value is close to zero and min and max do not bracket root.\n+                this.f = f;\n+\t\t\t\t// neither value is close to zero and min and max do not bracket root.\n                 throw MathRuntimeException.createIllegalArgumentException(\n                         NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n             }\n@@ -280,11 +282,26 @@\n                 }\n                 if (2.0 * p >= 1.5 * dx * p1 - Math.abs(tolerance * p1) ||\n                         p >= Math.abs(0.5 * oldDelta * p1)) {\n-                    // Inverse quadratic interpolation gives a value\n+                    double r2 = y1 / y2;\n+\t\t\t\t\t// Inverse quadratic interpolation gives a value\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n+                    if (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (delta / oldDelta > 1) {\n+\t\t\t\t\t\tdelta = 0.5 * oldDelta;\n+\t\t\t\t\t}\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-02 11:24:06.671526982 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_884/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-02 12:12:22.217207306 -0500\n@@ -206,7 +206,8 @@\n      */\n     protected void verifyInterval(final double lower, final double upper) {\n         if (lower >= upper) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n+            int i = 0;\n+\t\t\tthrow MathRuntimeException.createIllegalArgumentException(\n                     \"endpoints do not specify an interval: [{0}, {1}]\",\n                     lower, upper);\n         }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "checkResultComputed();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "verifySequence(min,initial,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "Replace", 
          "seed": "if (delta / oldDelta > 1) {\n  delta=0.5 * oldDelta;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 113, 
          "faulty": "double yMin=f.value(min);", 
          "type": "InsertBefore", 
          "seed": "this.defaultFunctionValueAccuracy=1.0e-15;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 102, 
          "faulty": "clearResult();", 
          "type": "Replace", 
          "seed": "verifySequence(min,initial,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 184, 
          "faulty": "throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);", 
          "type": "InsertBefore", 
          "seed": "this.f=f;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 286, 
          "faulty": "delta=0.5 * dx;", 
          "type": "InsertBefore", 
          "seed": "double r2=y1 / y2;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java", 
          "line": 209, 
          "faulty": "throw MathRuntimeException.createIllegalArgumentException(\"endpoints do not specify an interval: [{0}, {1}]\",lower,upper);", 
          "type": "InsertBefore", 
          "seed": "int i=0;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "Delete", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_439/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:49:47.774499259 -0500\n@@ -104,22 +104,22 @@\n \n         // return the initial guess if it is good enough\n         double yInitial = f.value(initial);\n-        if (Math.abs(yInitial) <= functionValueAccuracy) {\n+        clearResult();\n+\t\tdouble a = initial;\n+\t\tif (Math.abs(yInitial) <= functionValueAccuracy) {\n             setResult(initial, 0);\n             return result;\n         }\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n+        verifyBracketing(min, max, f);\n+\t\tif (Math.abs(yMin) <= functionValueAccuracy) {\n             setResult(yMin, 0);\n             return result;\n         }\n \n-        // reduce interval if min and initial bracket the root\n-        if (yInitial * yMin < 0) {\n-            return solve(f, min, yMin, initial, yInitial, min, yMin);\n-        }\n+        clearResult();\n \n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n@@ -134,7 +134,8 @@\n         }\n \n \n-        // full Brent algorithm starting with provided initial guess\n+        verifySequence(min, initial, max);\n+\t\t// full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n \n     }\n@@ -172,7 +173,8 @@\n         // Verify bracketing\n         double sign = yMin * yMax;\n         if (sign > 0) {\n-            // check if either value is close to a zero\n+            resultComputed = true;\n+\t\t\t// check if either value is close to a zero\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "Replace", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "double a=initial;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "verifySequence(min,initial,max);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_910/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 12:13:40.049380178 -0500\n@@ -99,7 +99,7 @@\n                         final double min, final double max, final double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n \n-        clearResult();\n+        verifySequence(min, initial, max);\n         verifySequence(min, initial, max);\n \n         // return the initial guess if it is good enough\n@@ -109,18 +109,15 @@\n             return result;\n         }\n \n-        // return the first endpoint if it is good enough\n+        this.defaultFunctionValueAccuracy = 1.0e-15;\n+\t\t// return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n+        verifyBracketing(min, max, f);\n+\t\tif (Math.abs(yMin) <= functionValueAccuracy) {\n             setResult(yMin, 0);\n             return result;\n         }\n \n-        // reduce interval if min and initial bracket the root\n-        if (yInitial * yMin < 0) {\n-            return solve(f, min, yMin, initial, yInitial, min, yMin);\n-        }\n-\n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n         if (Math.abs(yMax) <= functionValueAccuracy) {\n@@ -128,13 +125,13 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n         if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+\t\t\treturn solve(f, initial, yInitial, max, yMax, initial, yInitial);\n+\t\t}\n \n \n-        // full Brent algorithm starting with provided initial guess\n+        verifySequence(min, initial, max);\n+\t\t// full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n \n     }\n@@ -172,7 +169,9 @@\n         // Verify bracketing\n         double sign = yMin * yMax;\n         if (sign > 0) {\n-            // check if either value is close to a zero\n+            resultComputed = true;\n+\t\t\tresultComputed = true;\n+\t\t\t// check if either value is close to a zero\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n@@ -180,7 +179,8 @@\n                 setResult(max, 0);\n                 ret = max;\n             } else {\n-                // neither value is close to zero and min and max do not bracket root.\n+                this.f = f;\n+\t\t\t\t// neither value is close to zero and min and max do not bracket root.\n                 throw MathRuntimeException.createIllegalArgumentException(\n                         NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n             }\n@@ -280,11 +280,20 @@\n                 }\n                 if (2.0 * p >= 1.5 * dx * p1 - Math.abs(tolerance * p1) ||\n                         p >= Math.abs(0.5 * oldDelta * p1)) {\n-                    // Inverse quadratic interpolation gives a value\n+                    double r2 = y1 / y2;\n+\t\t\t\t\t// Inverse quadratic interpolation gives a value\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n+                    if (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (delta / oldDelta > 1) {\n+\t\t\t\t\t\tdelta = 0.5 * oldDelta;\n+\t\t\t\t\t}\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-02 11:24:06.671526982 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_910/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-02 12:13:40.049380178 -0500\n@@ -206,7 +206,8 @@\n      */\n     protected void verifyInterval(final double lower, final double upper) {\n         if (lower >= upper) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n+            int i = 0;\n+\t\t\tthrow MathRuntimeException.createIllegalArgumentException(\n                     \"endpoints do not specify an interval: [{0}, {1}]\",\n                     lower, upper);\n         }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "verifySequence(min,initial,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "Replace", 
          "seed": "if (delta / oldDelta > 1) {\n  delta=0.5 * oldDelta;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 113, 
          "faulty": "double yMin=f.value(min);", 
          "type": "InsertBefore", 
          "seed": "this.defaultFunctionValueAccuracy=1.0e-15;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 102, 
          "faulty": "clearResult();", 
          "type": "Replace", 
          "seed": "verifySequence(min,initial,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 184, 
          "faulty": "throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);", 
          "type": "InsertBefore", 
          "seed": "this.f=f;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 286, 
          "faulty": "delta=0.5 * dx;", 
          "type": "InsertBefore", 
          "seed": "double r2=y1 / y2;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java", 
          "line": 209, 
          "faulty": "throw MathRuntimeException.createIllegalArgumentException(\"endpoints do not specify an interval: [{0}, {1}]\",lower,upper);", 
          "type": "InsertBefore", 
          "seed": "int i=0;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "Delete", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_637/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:59:47.991624602 -0500\n@@ -99,7 +99,6 @@\n                         final double min, final double max, final double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n \n-        clearResult();\n         verifySequence(min, initial, max);\n \n         // return the initial guess if it is good enough\n@@ -111,10 +110,8 @@\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n+        verifyBracketing(min, max, f);\n+\t\tverifyInterval(min, max);\n \n         // reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n@@ -134,7 +131,8 @@\n         }\n \n \n-        // full Brent algorithm starting with provided initial guess\n+        verifySequence(min, initial, max);\n+\t\t// full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n \n     }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "verifySequence(min,initial,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 102, 
          "faulty": "clearResult();", 
          "type": "Delete", 
          "seed": "verifyInterval(min,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Replace", 
          "seed": "verifyInterval(min,max);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_881/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 12:12:15.477192043 -0500\n@@ -99,42 +99,52 @@\n                         final double min, final double max, final double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n \n-        clearResult();\n+        verifySequence(min, initial, max);\n         verifySequence(min, initial, max);\n \n         // return the initial guess if it is good enough\n         double yInitial = f.value(initial);\n-        if (Math.abs(yInitial) <= functionValueAccuracy) {\n+        clearResult();\n+\t\tclearResult();\n+\t\tif (Math.abs(yInitial) <= functionValueAccuracy) {\n             setResult(initial, 0);\n             return result;\n         }\n \n-        // return the first endpoint if it is good enough\n+        this.defaultFunctionValueAccuracy = 1.0e-15;\n+\t\t// return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n+        verifyBracketing(min, max, f);\n+\t\tverifyBracketing(min, max, f);\n+\t\tverifyBracketing(min, max, f);\n+\t\tif (Math.abs(yMin) <= functionValueAccuracy) {\n             setResult(yMin, 0);\n             return result;\n         }\n \n-        // reduce interval if min and initial bracket the root\n+        double x1 = max;\n+\t\t// reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n \n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n-        if (Math.abs(yMax) <= functionValueAccuracy) {\n-            setResult(yMax, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if initial and max bracket the root\n         if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+\t\t\treturn solve(f, initial, yInitial, max, yMax, initial, yInitial);\n+\t\t}\n \n \n-        // full Brent algorithm starting with provided initial guess\n+        checkResultComputed();\n+\t\tif (f == null) {\n+\t\t\tthrow MathRuntimeException\n+\t\t\t\t\t.createIllegalArgumentException(\"function to solve cannot be null\");\n+\t\t}\n+\t\tcheckResultComputed();\n+\t\tverifySequence(min, initial, max);\n+\t\tcheckResultComputed();\n+\t\tverifySequence(min, initial, max);\n+\t\t// full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n \n     }\n@@ -172,7 +182,10 @@\n         // Verify bracketing\n         double sign = yMin * yMax;\n         if (sign > 0) {\n-            // check if either value is close to a zero\n+            resultComputed = true;\n+\t\t\tresultComputed = true;\n+\t\t\tresultComputed = true;\n+\t\t\t// check if either value is close to a zero\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n@@ -180,7 +193,8 @@\n                 setResult(max, 0);\n                 ret = max;\n             } else {\n-                // neither value is close to zero and min and max do not bracket root.\n+                this.f = f;\n+\t\t\t\t// neither value is close to zero and min and max do not bracket root.\n                 throw MathRuntimeException.createIllegalArgumentException(\n                         NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n             }\n@@ -280,11 +294,26 @@\n                 }\n                 if (2.0 * p >= 1.5 * dx * p1 - Math.abs(tolerance * p1) ||\n                         p >= Math.abs(0.5 * oldDelta * p1)) {\n-                    // Inverse quadratic interpolation gives a value\n+                    double r2 = y1 / y2;\n+\t\t\t\t\t// Inverse quadratic interpolation gives a value\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n+                    if (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (delta / oldDelta > 1) {\n+\t\t\t\t\t\tdelta = 0.5 * oldDelta;\n+\t\t\t\t\t}\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-02 11:24:06.671526982 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_881/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-02 12:12:15.481192052 -0500\n@@ -206,7 +206,8 @@\n      */\n     protected void verifyInterval(final double lower, final double upper) {\n         if (lower >= upper) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n+            int i = 0;\n+\t\t\tthrow MathRuntimeException.createIllegalArgumentException(\n                     \"endpoints do not specify an interval: [{0}, {1}]\",\n                     lower, upper);\n         }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "checkResultComputed();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "if (f == null) {\n  throw MathRuntimeException.createIllegalArgumentException(\"function to solve cannot be null\");\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "InsertBefore", 
          "seed": "double x1=max;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "checkResultComputed();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "verifySequence(min,initial,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "checkResultComputed();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "verifySequence(min,initial,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "Replace", 
          "seed": "if (delta / oldDelta > 1) {\n  delta=0.5 * oldDelta;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 113, 
          "faulty": "double yMin=f.value(min);", 
          "type": "InsertBefore", 
          "seed": "this.defaultFunctionValueAccuracy=1.0e-15;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 102, 
          "faulty": "clearResult();", 
          "type": "Replace", 
          "seed": "verifySequence(min,initial,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 184, 
          "faulty": "throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);", 
          "type": "InsertBefore", 
          "seed": "this.f=f;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 286, 
          "faulty": "delta=0.5 * dx;", 
          "type": "InsertBefore", 
          "seed": "double r2=y1 / y2;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java", 
          "line": 209, 
          "faulty": "throw MathRuntimeException.createIllegalArgumentException(\"endpoints do not specify an interval: [{0}, {1}]\",lower,upper);", 
          "type": "InsertBefore", 
          "seed": "int i=0;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 126, 
          "faulty": "if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(yMax,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "return new BrentSolver();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_613/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:58:38.195507894 -0500\n@@ -99,7 +99,6 @@\n                         final double min, final double max, final double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n \n-        clearResult();\n         verifySequence(min, initial, max);\n \n         // return the initial guess if it is good enough\n@@ -111,12 +110,11 @@\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n+        verifyBracketing(min, max, f);\n+\t\tverifyInterval(min, max);\n \n-        // reduce interval if min and initial bracket the root\n+        double x1 = max;\n+\t\t// reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n@@ -172,7 +170,8 @@\n         // Verify bracketing\n         double sign = yMin * yMax;\n         if (sign > 0) {\n-            // check if either value is close to a zero\n+            resultComputed = true;\n+\t\t\t// check if either value is close to a zero\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "InsertBefore", 
          "seed": "double x1=max;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 102, 
          "faulty": "clearResult();", 
          "type": "Delete", 
          "seed": "verifyInterval(min,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Replace", 
          "seed": "verifyInterval(min,max);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_941/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 12:15:17.221588196 -0500\n@@ -104,23 +104,20 @@\n \n         // return the initial guess if it is good enough\n         double yInitial = f.value(initial);\n-        if (Math.abs(yInitial) <= functionValueAccuracy) {\n+        clearResult();\n+\t\tif (Math.abs(yInitial) <= functionValueAccuracy) {\n             setResult(initial, 0);\n             return result;\n         }\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n+        verifyBracketing(min, max, f);\n+\t\tif (Math.abs(yMin) <= functionValueAccuracy) {\n             setResult(yMin, 0);\n             return result;\n         }\n \n-        // reduce interval if min and initial bracket the root\n-        if (yInitial * yMin < 0) {\n-            return solve(f, min, yMin, initial, yInitial, min, yMin);\n-        }\n-\n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n         if (Math.abs(yMax) <= functionValueAccuracy) {\n@@ -128,10 +125,9 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n         if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+\t\t\treturn solve(f, initial, yInitial, max, yMax, initial, yInitial);\n+\t\t}\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -172,7 +168,9 @@\n         // Verify bracketing\n         double sign = yMin * yMax;\n         if (sign > 0) {\n-            // check if either value is close to a zero\n+            resultComputed = true;\n+\t\t\tresultComputed = true;\n+\t\t\t// check if either value is close to a zero\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n@@ -180,7 +178,8 @@\n                 setResult(max, 0);\n                 ret = max;\n             } else {\n-                // neither value is close to zero and min and max do not bracket root.\n+                this.f = f;\n+\t\t\t\t// neither value is close to zero and min and max do not bracket root.\n                 throw MathRuntimeException.createIllegalArgumentException(\n                         NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n             }\n@@ -280,7 +279,8 @@\n                 }\n                 if (2.0 * p >= 1.5 * dx * p1 - Math.abs(tolerance * p1) ||\n                         p >= Math.abs(0.5 * oldDelta * p1)) {\n-                    // Inverse quadratic interpolation gives a value\n+                    double r2 = y1 / y2;\n+\t\t\t\t\t// Inverse quadratic interpolation gives a value\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n\n\n--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-02 11:24:06.671526982 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_941/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-02 12:15:17.225588204 -0500\n@@ -206,7 +206,8 @@\n      */\n     protected void verifyInterval(final double lower, final double upper) {\n         if (lower >= upper) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n+            int i = 0;\n+\t\t\tthrow MathRuntimeException.createIllegalArgumentException(\n                     \"endpoints do not specify an interval: [{0}, {1}]\",\n                     lower, upper);\n         }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 184, 
          "faulty": "throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);", 
          "type": "InsertBefore", 
          "seed": "this.f=f;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 286, 
          "faulty": "delta=0.5 * dx;", 
          "type": "InsertBefore", 
          "seed": "double r2=y1 / y2;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java", 
          "line": 209, 
          "faulty": "throw MathRuntimeException.createIllegalArgumentException(\"endpoints do not specify an interval: [{0}, {1}]\",lower,upper);", 
          "type": "InsertBefore", 
          "seed": "int i=0;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "Delete", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_679/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 12:01:48.891823752 -0500\n@@ -99,24 +99,22 @@\n                         final double min, final double max, final double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n \n-        clearResult();\n         verifySequence(min, initial, max);\n-\n         // return the initial guess if it is good enough\n         double yInitial = f.value(initial);\n-        if (Math.abs(yInitial) <= functionValueAccuracy) {\n+        clearResult();\n+\t\tif (Math.abs(yInitial) <= functionValueAccuracy) {\n             setResult(initial, 0);\n             return result;\n         }\n \n-        // return the first endpoint if it is good enough\n+        this.defaultFunctionValueAccuracy = 1.0e-15;\n+\t\t// return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if min and initial bracket the root\n+        verifyBracketing(min, max, f);\n+\t\tverifyBracketing(min, max, f);\n+\t\tdouble b = initial;\n+\t\t// reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n@@ -134,7 +132,9 @@\n         }\n \n \n-        // full Brent algorithm starting with provided initial guess\n+        checkResultComputed();\n+\t\tverifySequence(min, initial, max);\n+\t\t// full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n \n     }\n@@ -172,7 +172,10 @@\n         // Verify bracketing\n         double sign = yMin * yMax;\n         if (sign > 0) {\n-            // check if either value is close to a zero\n+            resultComputed = true;\n+\t\t\tresultComputed = true;\n+\t\t\tresultComputed = true;\n+\t\t\t// check if either value is close to a zero\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n@@ -284,7 +287,15 @@\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n+                    if (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (delta / oldDelta > 1) {\n+\t\t\t\t\t\tdelta = 0.5 * oldDelta;\n+\t\t\t\t\t}\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "checkResultComputed();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "verifySequence(min,initial,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "Replace", 
          "seed": "if (delta / oldDelta > 1) {\n  delta=0.5 * oldDelta;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 113, 
          "faulty": "double yMin=f.value(min);", 
          "type": "InsertBefore", 
          "seed": "this.defaultFunctionValueAccuracy=1.0e-15;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 102, 
          "faulty": "clearResult();", 
          "type": "Replace", 
          "seed": "verifySequence(min,initial,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "InsertBefore", 
          "seed": "double b=initial;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "setup(f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 103, 
          "faulty": "verifySequence(min,initial,max);", 
          "type": "Delete", 
          "seed": "Complex denominator=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_545/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:55:17.527160415 -0500\n@@ -99,7 +99,7 @@\n                         final double min, final double max, final double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n \n-        clearResult();\n+        this.resultComputed = false;\n         verifySequence(min, initial, max);\n \n         // return the initial guess if it is good enough\n@@ -111,12 +111,15 @@\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n+        verifyBracketing(min, max, f);\n+\t\tverifyBracketing(min, max, f);\n+\t\tif (Math.abs(yMin) <= functionValueAccuracy) {\n             setResult(yMin, 0);\n             return result;\n         }\n \n-        // reduce interval if min and initial bracket the root\n+        double b = initial;\n+\t\t// reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n@@ -284,7 +287,19 @@\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n+                    if (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\toldDelta = delta;\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 102, 
          "faulty": "clearResult();", 
          "type": "Replace", 
          "seed": "this.resultComputed=false;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "InsertBefore", 
          "seed": "double b=initial;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_380/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:46:35.361988176 -0500\n@@ -111,22 +111,16 @@\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if min and initial bracket the root\n+        verifyBracketing(min, max, f);\n+\t\tdouble b = initial;\n+\t\t// reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n \n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n-        if (Math.abs(yMax) <= functionValueAccuracy) {\n-            setResult(yMax, 0);\n-            return result;\n-        }\n+        this.defaultFunctionValueAccuracy = 1.0e-15;\n \n         // reduce interval if initial and max bracket the root\n         if (yInitial * yMax < 0) {\n@@ -134,7 +128,8 @@\n         }\n \n \n-        // full Brent algorithm starting with provided initial guess\n+        verifySequence(min, initial, max);\n+\t\t// full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n \n     }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "int iterationCount=0;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 126, 
          "faulty": "if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(yMax,0);\n  return result;\n}", 
          "type": "Replace", 
          "seed": "this.defaultFunctionValueAccuracy=1.0e-15;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "InsertBefore", 
          "seed": "double b=initial;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "verifySequence(min,initial,max);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_657/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 12:00:45.215719261 -0500\n@@ -104,19 +104,16 @@\n \n         // return the initial guess if it is good enough\n         double yInitial = f.value(initial);\n-        if (Math.abs(yInitial) <= functionValueAccuracy) {\n+        clearResult();\n+\t\tif (Math.abs(yInitial) <= functionValueAccuracy) {\n             setResult(initial, 0);\n             return result;\n         }\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if min and initial bracket the root\n+        verifyBracketing(min, max, f);\n+\t\t// reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n@@ -134,7 +131,13 @@\n         }\n \n \n-        // full Brent algorithm starting with provided initial guess\n+        checkResultComputed();\n+\t\tcheckResultComputed();\n+\t\tif (f == null) {\n+\t\t\tthrow MathRuntimeException\n+\t\t\t\t\t.createIllegalArgumentException(\"function to solve cannot be null\");\n+\t\t}\n+\t\t// full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n \n     }\n@@ -172,7 +175,8 @@\n         // Verify bracketing\n         double sign = yMin * yMax;\n         if (sign > 0) {\n-            // check if either value is close to a zero\n+            resultComputed = true;\n+\t\t\t// check if either value is close to a zero\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n@@ -284,7 +288,10 @@\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n+                    if (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\toldDelta = delta;\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "checkResultComputed();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "checkResultComputed();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "this.functionValueAccuracy=defaultFunctionValueAccuracy;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "if (f == null) {\n  throw MathRuntimeException.createIllegalArgumentException(\"function to solve cannot be null\");\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_562/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:56:10.051253613 -0500\n@@ -99,24 +99,21 @@\n                         final double min, final double max, final double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n \n-        clearResult();\n+        verifySequence(min, initial, max);\n         verifySequence(min, initial, max);\n \n         // return the initial guess if it is good enough\n         double yInitial = f.value(initial);\n-        if (Math.abs(yInitial) <= functionValueAccuracy) {\n+        clearResult();\n+\t\tif (Math.abs(yInitial) <= functionValueAccuracy) {\n             setResult(initial, 0);\n             return result;\n         }\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if min and initial bracket the root\n+        verifyBracketing(min, max, f);\n+\t\t// reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n@@ -134,7 +131,9 @@\n         }\n \n \n-        // full Brent algorithm starting with provided initial guess\n+        checkResultComputed();\n+\t\tverifySequence(min, initial, max);\n+\t\t// full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n \n     }\n@@ -172,7 +171,8 @@\n         // Verify bracketing\n         double sign = yMin * yMax;\n         if (sign > 0) {\n-            // check if either value is close to a zero\n+            resultComputed = true;\n+\t\t\t// check if either value is close to a zero\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n@@ -284,7 +284,15 @@\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n+                    if (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (delta / oldDelta > 1) {\n+\t\t\t\t\t\tdelta = 0.5 * oldDelta;\n+\t\t\t\t\t}\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "checkResultComputed();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "verifySequence(min,initial,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "Replace", 
          "seed": "if (delta / oldDelta > 1) {\n  delta=0.5 * oldDelta;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "setup(f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 102, 
          "faulty": "clearResult();", 
          "type": "Replace", 
          "seed": "verifySequence(min,initial,max);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_572/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:56:37.135300952 -0500\n@@ -104,22 +104,22 @@\n \n         // return the initial guess if it is good enough\n         double yInitial = f.value(initial);\n-        if (Math.abs(yInitial) <= functionValueAccuracy) {\n+        clearResult();\n+\t\tif (Math.abs(yInitial) <= functionValueAccuracy) {\n             setResult(initial, 0);\n             return result;\n         }\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n+        verifyBracketing(min, max, f);\n+\t\tif (Math.abs(yMin) <= functionValueAccuracy) {\n             setResult(yMin, 0);\n             return result;\n         }\n \n-        // reduce interval if min and initial bracket the root\n-        if (yInitial * yMin < 0) {\n-            return solve(f, min, yMin, initial, yInitial, min, yMin);\n-        }\n+        double b = initial;\n+\t\tclearResult();\n \n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n@@ -134,7 +134,8 @@\n         }\n \n \n-        // full Brent algorithm starting with provided initial guess\n+        verifySequence(min, initial, max);\n+\t\t// full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n \n     }\n@@ -172,7 +173,8 @@\n         // Verify bracketing\n         double sign = yMin * yMax;\n         if (sign > 0) {\n-            // check if either value is close to a zero\n+            resultComputed = true;\n+\t\t\t// check if either value is close to a zero\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n@@ -284,7 +286,12 @@\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n+                    if (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-02 11:24:06.671526982 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_572/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-02 11:56:37.139300957 -0500\n@@ -222,7 +222,8 @@\n      * @throws IllegalArgumentException\n      */\n     protected void verifySequence(final double lower, final double initial, final double upper) {\n-        if (!isSequence(lower, initial, upper)) {\n+        this.resultComputed = false;\n+\t\tif (!isSequence(lower, initial, upper)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n                     \"invalid interval, initial value parameters:  lower={0}, initial={1}, upper={2}\",\n                     lower, initial, upper);\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "InsertBefore", 
          "seed": "double b=initial;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "Replace", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "verifySequence(min,initial,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "Delete", 
          "seed": "if (x0 == x2) {\n  p=dx * r3;\n  p1=1.0 - r3;\n}\n else {\n  double r1=y0 / y2;\n  double r2=y1 / y2;\n  p=r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));\n  p1=(r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java", 
          "line": 225, 
          "faulty": "if (!isSequence(lower,initial,upper)) {\n  throw MathRuntimeException.createIllegalArgumentException(\"invalid interval, initial value parameters:  lower={0}, initial={1}, upper={2}\",lower,initial,upper);\n}", 
          "type": "InsertBefore", 
          "seed": "this.resultComputed=false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_820/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 12:09:09.252757184 -0500\n@@ -99,19 +99,24 @@\n                         final double min, final double max, final double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n \n-        clearResult();\n+        verifySequence(min, initial, max);\n         verifySequence(min, initial, max);\n \n         // return the initial guess if it is good enough\n         double yInitial = f.value(initial);\n-        if (Math.abs(yInitial) <= functionValueAccuracy) {\n+        clearResult();\n+\t\tclearResult();\n+\t\tif (Math.abs(yInitial) <= functionValueAccuracy) {\n             setResult(initial, 0);\n             return result;\n         }\n \n-        // return the first endpoint if it is good enough\n+        this.defaultFunctionValueAccuracy = 1.0e-15;\n+\t\t// return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n+        verifyBracketing(min, max, f);\n+\t\tverifyBracketing(min, max, f);\n+\t\tif (Math.abs(yMin) <= functionValueAccuracy) {\n             setResult(yMin, 0);\n             return result;\n         }\n@@ -128,13 +133,15 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n         if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+\t\t\treturn solve(f, initial, yInitial, max, yMax, initial, yInitial);\n+\t\t}\n \n \n-        // full Brent algorithm starting with provided initial guess\n+        checkResultComputed();\n+\t\tcheckResultComputed();\n+\t\tverifySequence(min, initial, max);\n+\t\t// full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n \n     }\n@@ -172,7 +179,10 @@\n         // Verify bracketing\n         double sign = yMin * yMax;\n         if (sign > 0) {\n-            // check if either value is close to a zero\n+            resultComputed = true;\n+\t\t\tresultComputed = true;\n+\t\t\tresultComputed = true;\n+\t\t\t// check if either value is close to a zero\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n@@ -180,7 +190,8 @@\n                 setResult(max, 0);\n                 ret = max;\n             } else {\n-                // neither value is close to zero and min and max do not bracket root.\n+                this.f = f;\n+\t\t\t\t// neither value is close to zero and min and max do not bracket root.\n                 throw MathRuntimeException.createIllegalArgumentException(\n                         NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n             }\n@@ -280,11 +291,23 @@\n                 }\n                 if (2.0 * p >= 1.5 * dx * p1 - Math.abs(tolerance * p1) ||\n                         p >= Math.abs(0.5 * oldDelta * p1)) {\n-                    // Inverse quadratic interpolation gives a value\n+                    double r2 = y1 / y2;\n+\t\t\t\t\t// Inverse quadratic interpolation gives a value\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n+                    if (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (dx <= 0.0) {\n+\t\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (delta / oldDelta > 1) {\n+\t\t\t\t\t\tdelta = 0.5 * oldDelta;\n+\t\t\t\t\t}\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-02 11:24:06.671526982 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_820/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-02 12:09:09.256757193 -0500\n@@ -206,7 +206,8 @@\n      */\n     protected void verifyInterval(final double lower, final double upper) {\n         if (lower >= upper) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n+            int i = 0;\n+\t\t\tthrow MathRuntimeException.createIllegalArgumentException(\n                     \"endpoints do not specify an interval: [{0}, {1}]\",\n                     lower, upper);\n         }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "checkResultComputed();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "checkResultComputed();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "verifySequence(min,initial,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "Replace", 
          "seed": "if (delta / oldDelta > 1) {\n  delta=0.5 * oldDelta;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 113, 
          "faulty": "double yMin=f.value(min);", 
          "type": "InsertBefore", 
          "seed": "this.defaultFunctionValueAccuracy=1.0e-15;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 102, 
          "faulty": "clearResult();", 
          "type": "Replace", 
          "seed": "verifySequence(min,initial,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 184, 
          "faulty": "throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);", 
          "type": "InsertBefore", 
          "seed": "this.f=f;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 286, 
          "faulty": "delta=0.5 * dx;", 
          "type": "InsertBefore", 
          "seed": "double r2=y1 / y2;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java", 
          "line": 209, 
          "faulty": "throw MathRuntimeException.createIllegalArgumentException(\"endpoints do not specify an interval: [{0}, {1}]\",lower,upper);", 
          "type": "InsertBefore", 
          "seed": "int i=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_565/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:56:16.739265345 -0500\n@@ -111,12 +111,9 @@\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if min and initial bracket the root\n+        verifyBracketing(min, max, f);\n+\t\tdouble b = initial;\n+\t\t// reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n@@ -172,7 +169,8 @@\n         // Verify bracketing\n         double sign = yMin * yMax;\n         if (sign > 0) {\n-            // check if either value is close to a zero\n+            resultComputed = true;\n+\t\t\t// check if either value is close to a zero\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "InsertBefore", 
          "seed": "double b=initial;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "setup(f);"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_739/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 12:05:05.984216770 -0500\n@@ -104,14 +104,17 @@\n \n         // return the initial guess if it is good enough\n         double yInitial = f.value(initial);\n-        if (Math.abs(yInitial) <= functionValueAccuracy) {\n+        clearResult();\n+\t\tdouble x2 = max;\n+\t\tif (Math.abs(yInitial) <= functionValueAccuracy) {\n             setResult(initial, 0);\n             return result;\n         }\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n+        verifyBracketing(min, max, f);\n+\t\tif (Math.abs(yMin) <= functionValueAccuracy) {\n             setResult(yMin, 0);\n             return result;\n         }\n@@ -134,7 +137,12 @@\n         }\n \n \n-        // full Brent algorithm starting with provided initial guess\n+        checkResultComputed();\n+\t\tif (f == null) {\n+\t\t\tthrow MathRuntimeException\n+\t\t\t\t\t.createIllegalArgumentException(\"function to solve cannot be null\");\n+\t\t}\n+\t\t// full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n \n     }\n@@ -172,7 +180,8 @@\n         // Verify bracketing\n         double sign = yMin * yMax;\n         if (sign > 0) {\n-            // check if either value is close to a zero\n+            resultComputed = true;\n+\t\t\t// check if either value is close to a zero\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "checkResultComputed();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "if (f == null) {\n  throw MathRuntimeException.createIllegalArgumentException(\"function to solve cannot be null\");\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "double x2=max;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_786/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 12:07:24.596514416 -0500\n@@ -104,14 +104,16 @@\n \n         // return the initial guess if it is good enough\n         double yInitial = f.value(initial);\n-        if (Math.abs(yInitial) <= functionValueAccuracy) {\n+        double x2 = max;\n+\t\tif (Math.abs(yInitial) <= functionValueAccuracy) {\n             setResult(initial, 0);\n             return result;\n         }\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n+        verifyBracketing(min, max, f);\n+\t\tif (Math.abs(yMin) <= functionValueAccuracy) {\n             setResult(yMin, 0);\n             return result;\n         }\n@@ -134,7 +136,11 @@\n         }\n \n \n-        // full Brent algorithm starting with provided initial guess\n+        if (f == null) {\n+\t\t\tthrow MathRuntimeException\n+\t\t\t\t\t.createIllegalArgumentException(\"function to solve cannot be null\");\n+\t\t}\n+\t\t// full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n \n     }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "if (f == null) {\n  throw MathRuntimeException.createIllegalArgumentException(\"function to solve cannot be null\");\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "double x2=max;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_342/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:44:44.197729770 -0500\n@@ -104,19 +104,22 @@\n \n         // return the initial guess if it is good enough\n         double yInitial = f.value(initial);\n-        if (Math.abs(yInitial) <= functionValueAccuracy) {\n+        this.functionValueAccuracy = defaultFunctionValueAccuracy;\n+\t\tif (Math.abs(yInitial) <= functionValueAccuracy) {\n             setResult(initial, 0);\n             return result;\n         }\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n+        verifyBracketing(min, max, f);\n+\t\tif (Math.abs(yMin) <= functionValueAccuracy) {\n             setResult(yMin, 0);\n             return result;\n         }\n \n-        // reduce interval if min and initial bracket the root\n+        double b = initial;\n+\t\t// reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "InsertBefore", 
          "seed": "double b=initial;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "this.functionValueAccuracy=defaultFunctionValueAccuracy;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 11:24:09.151526925 -0500\n+++ /tmp/GenProg_Defects4J_Math_73/patches_p045/Patch_851/patched/tmp/GenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-02 12:10:44.040979774 -0500\n@@ -104,19 +104,16 @@\n \n         // return the initial guess if it is good enough\n         double yInitial = f.value(initial);\n-        if (Math.abs(yInitial) <= functionValueAccuracy) {\n+        clearResult();\n+\t\tif (Math.abs(yInitial) <= functionValueAccuracy) {\n             setResult(initial, 0);\n             return result;\n         }\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if min and initial bracket the root\n+        verifyBracketing(min, max, f);\n+\t\t// reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n@@ -134,7 +131,13 @@\n         }\n \n \n-        // full Brent algorithm starting with provided initial guess\n+        checkResultComputed();\n+\t\tcheckResultComputed();\n+\t\tif (f == null) {\n+\t\t\tthrow MathRuntimeException\n+\t\t\t\t\t.createIllegalArgumentException(\"function to solve cannot be null\");\n+\t\t}\n+\t\t// full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n \n     }\n@@ -172,7 +175,8 @@\n         // Verify bracketing\n         double sign = yMin * yMax;\n         if (sign > 0) {\n-            // check if either value is close to a zero\n+            resultComputed = true;\n+\t\t\t// check if either value is close to a zero\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n\n\n", 
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 176, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "checkResultComputed();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "checkResultComputed();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "this.functionValueAccuracy=defaultFunctionValueAccuracy;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "if (f == null) {\n  throw MathRuntimeException.createIllegalArgumentException(\"function to solve cannot be null\");\n}"
        }
      ]
    }
  ]
}