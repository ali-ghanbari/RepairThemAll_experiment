{
  "repair_end": "2018-12-01 13:40:29.470869", 
  "repair_begin": "2018-12-01 12:00:19.731949", 
  "patches": [
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "Delete", 
          "seed": "p=dx * r3;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1141/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:56:35.555528070 -0500\n@@ -128,7 +128,8 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n+        verifyBracketing(min, max, f);\n+\t\t// reduce interval if initial and max bracket the root\n         if (yInitial * yMax < 0) {\n             return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n         }\n@@ -284,7 +285,6 @@\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "if (!resultComputed) {\n  throw MathRuntimeException.createIllegalStateException(\"no result available\");\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_361/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:19:01.729301217 -0500\n@@ -111,11 +111,6 @@\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n-\n         // reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n@@ -128,10 +123,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 300, 
          "faulty": "x1=x1 + 0.5 * tolerance;", 
          "type": "InsertBefore", 
          "seed": "functionValueAccuracy=defaultFunctionValueAccuracy;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_359/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:18:58.473293170 -0500\n@@ -128,10 +128,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -297,7 +294,8 @@\n             if (Math.abs(delta) > tolerance) {\n                 x1 = x1 + delta;\n             } else if (dx > 0.0) {\n-                x1 = x1 + 0.5 * tolerance;\n+                functionValueAccuracy = defaultFunctionValueAccuracy;\n+\t\t\t\tx1 = x1 + 0.5 * tolerance;\n             } else if (dx <= 0.0) {\n                 x1 = x1 - 0.5 * tolerance;\n             }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "InsertBefore", 
          "seed": "this.iterationCount=iterationCount;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_782/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:39:21.456493894 -0500\n@@ -116,7 +116,8 @@\n             return result;\n         }\n \n-        // reduce interval if min and initial bracket the root\n+        this.iterationCount = iterationCount;\n+\t\t// reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n@@ -128,10 +129,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_186/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:10:59.343859999 -0500\n@@ -128,7 +128,8 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n+        verifyBracketing(min, max, f);\n+\t\t// reduce interval if initial and max bracket the root\n         if (yInitial * yMax < 0) {\n             return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n         }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "Replace", 
          "seed": "if (Math.abs(dx) <= tolerance) {\n  setResult(x1,i);\n  return result;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "Replace", 
          "seed": "iterationCount+=this.iterationCount;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1808/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 07:30:10.885417519 -0500\n@@ -116,10 +116,7 @@\n             return result;\n         }\n \n-        // reduce interval if min and initial bracket the root\n-        if (yInitial * yMin < 0) {\n-            return solve(f, min, yMin, initial, yInitial, min, yMin);\n-        }\n+        iterationCount += this.iterationCount;\n \n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n@@ -128,10 +125,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -284,7 +278,10 @@\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n+                    if (Math.abs(dx) <= tolerance) {\n+\t\t\t\t\t\tsetResult(x1, i);\n+\t\t\t\t\t\treturn result;\n+\t\t\t\t\t}\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 102, 
          "faulty": "clearResult();", 
          "type": "Replace", 
          "seed": "setResult(max,0);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 286, 
          "faulty": "delta=0.5 * dx;", 
          "type": "InsertBefore", 
          "seed": "x1=x1 + 0.5 * tolerance;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_789/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:39:39.620545269 -0500\n@@ -99,7 +99,7 @@\n                         final double min, final double max, final double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n \n-        clearResult();\n+        setResult(max, 0);\n         verifySequence(min, initial, max);\n \n         // return the initial guess if it is good enough\n@@ -128,10 +128,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -280,7 +277,8 @@\n                 }\n                 if (2.0 * p >= 1.5 * dx * p1 - Math.abs(tolerance * p1) ||\n                         p >= Math.abs(0.5 * oldDelta * p1)) {\n-                    // Inverse quadratic interpolation gives a value\n+                    x1 = x1 + 0.5 * tolerance;\n+\t\t\t\t\t// Inverse quadratic interpolation gives a value\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java", 
          "line": 196, 
          "faulty": "return (start < mid) && (mid < end);", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 06:00:06.853104067 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1904/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 07:34:50.310240195 -0500\n@@ -193,7 +193,8 @@\n      * @return true if the arguments form an increasing sequence\n      */\n     protected boolean isSequence(final double start, final double mid, final double end) {\n-        return (start < mid) && (mid < end);\n+        resultComputed = true;\n+\t\treturn (start < mid) && (mid < end);\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1904/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 07:34:50.310240195 -0500\n@@ -128,10 +128,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "Replace", 
          "seed": "verifySequence(min,initial,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 179, 
          "faulty": "if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "ret=min;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1101/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:54:42.127192726 -0500\n@@ -116,10 +116,7 @@\n             return result;\n         }\n \n-        // reduce interval if min and initial bracket the root\n-        if (yInitial * yMin < 0) {\n-            return solve(f, min, yMin, initial, yInitial, min, yMin);\n-        }\n+        verifySequence(min, initial, max);\n \n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n@@ -128,10 +125,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -176,14 +170,16 @@\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n-            } else if (Math.abs(yMax) <= functionValueAccuracy) {\n-                setResult(max, 0);\n-                ret = max;\n             } else {\n-                // neither value is close to zero and min and max do not bracket root.\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                        NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n-            }\n+\t\t\t\tret = min;\n+\t\t\t\tif (Math.abs(yMax) <= functionValueAccuracy) {\n+\t\t\t\t\tsetResult(max, 0);\n+\t\t\t\t\tret = max;\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow MathRuntimeException.createIllegalArgumentException(\n+\t\t\t\t\t\t\tNON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n+\t\t\t\t}\n+\t\t\t}\n         } else if (sign < 0){\n             // solve using only the first endpoint as initial guess\n             ret = solve(f, min, yMin, max, yMax, min, yMin);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 251, 
          "faulty": "return result;", 
          "type": "InsertBefore", 
          "seed": "delta=x1 - x0;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 126, 
          "faulty": "if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(yMax,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "this.iterationCount=iterationCount;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_190/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:11:08.899889057 -0500\n@@ -123,15 +123,7 @@\n \n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n-        if (Math.abs(yMax) <= functionValueAccuracy) {\n-            setResult(yMax, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -248,7 +240,8 @@\n                 Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\n             if (Math.abs(dx) <= tolerance) {\n                 setResult(x1, i);\n-                return result;\n+                delta = x1 - x0;\n+\t\t\t\treturn result;\n             }\n             if ((Math.abs(oldDelta) < tolerance) ||\n                     (Math.abs(y0) <= Math.abs(y1))) {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "Delete", 
          "seed": "p=dx * r3;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 106, 
          "faulty": "double yInitial=f.value(initial);", 
          "type": "InsertBefore", 
          "seed": "this.iterationCount=iterationCount;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_596/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:30:09.867062348 -0500\n@@ -102,7 +102,8 @@\n         clearResult();\n         verifySequence(min, initial, max);\n \n-        // return the initial guess if it is good enough\n+        this.iterationCount = iterationCount;\n+\t\t// return the initial guess if it is good enough\n         double yInitial = f.value(initial);\n         if (Math.abs(yInitial) <= functionValueAccuracy) {\n             setResult(initial, 0);\n@@ -128,10 +129,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -284,7 +282,6 @@\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 102, 
          "faulty": "clearResult();", 
          "type": "Replace", 
          "seed": "this.resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1896/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 07:34:28.362175588 -0500\n@@ -99,7 +99,7 @@\n                         final double min, final double max, final double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n \n-        clearResult();\n+        this.resultComputed = true;\n         verifySequence(min, initial, max);\n \n         // return the initial guess if it is good enough\n@@ -128,10 +128,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java", 
          "line": 209, 
          "faulty": "throw MathRuntimeException.createIllegalArgumentException(\"endpoints do not specify an interval: [{0}, {1}]\",lower,upper);", 
          "type": "Replace", 
          "seed": "throw MathRuntimeException.createIllegalArgumentException(\"endpoints do not specify an interval: [{0}, {1}]\",lower,upper);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 06:00:06.853104067 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1943/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 07:36:44.198575415 -0500\n@@ -207,8 +207,8 @@\n     protected void verifyInterval(final double lower, final double upper) {\n         if (lower >= upper) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"endpoints do not specify an interval: [{0}, {1}]\",\n-                    lower, upper);\n+\t\t\t\t\t\"endpoints do not specify an interval: [{0}, {1}]\", lower,\n+\t\t\t\t\tupper);\n         }\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1943/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 07:36:44.202575428 -0500\n@@ -111,11 +111,6 @@\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n-\n         // reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n@@ -128,10 +123,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 299, 
          "faulty": "if (dx > 0.0) {\n  x1=x1 + 0.5 * tolerance;\n}\n else if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}", 
          "type": "InsertBefore", 
          "seed": "delta=x1 - x0;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_524/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:26:52.790572086 -0500\n@@ -111,11 +111,6 @@\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n-\n         // reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n@@ -128,10 +123,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -296,11 +288,14 @@\n             // Compute new X1, Y1\n             if (Math.abs(delta) > tolerance) {\n                 x1 = x1 + delta;\n-            } else if (dx > 0.0) {\n-                x1 = x1 + 0.5 * tolerance;\n-            } else if (dx <= 0.0) {\n-                x1 = x1 - 0.5 * tolerance;\n-            }\n+            } else {\n+\t\t\t\tdelta = x1 - x0;\n+\t\t\t\tif (dx > 0.0) {\n+\t\t\t\t\tx1 = x1 + 0.5 * tolerance;\n+\t\t\t\t} else if (dx <= 0.0) {\n+\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t}\n+\t\t\t}\n             y1 = f.value(x1);\n             if ((y1 > 0) == (y2 > 0)) {\n                 x2 = x0;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 251, 
          "faulty": "return result;", 
          "type": "InsertBefore", 
          "seed": "delta=x1 - x0;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_446/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:23:03.677959645 -0500\n@@ -128,10 +128,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -248,7 +245,8 @@\n                 Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\n             if (Math.abs(dx) <= tolerance) {\n                 setResult(x1, i);\n-                return result;\n+                delta = x1 - x0;\n+\t\t\t\treturn result;\n             }\n             if ((Math.abs(oldDelta) < tolerance) ||\n                     (Math.abs(y0) <= Math.abs(y1))) {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 299, 
          "faulty": "if (dx > 0.0) {\n  x1=x1 + 0.5 * tolerance;\n}\n else if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}", 
          "type": "InsertBefore", 
          "seed": "if (Math.abs(dx) <= tolerance) {\n  setResult(x1,i);\n  return result;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_964/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:48:04.818017104 -0500\n@@ -128,7 +128,8 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n+        verifyBracketing(min, max, f);\n+\t\t// reduce interval if initial and max bracket the root\n         if (yInitial * yMax < 0) {\n             return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n         }\n@@ -296,11 +297,17 @@\n             // Compute new X1, Y1\n             if (Math.abs(delta) > tolerance) {\n                 x1 = x1 + delta;\n-            } else if (dx > 0.0) {\n-                x1 = x1 + 0.5 * tolerance;\n-            } else if (dx <= 0.0) {\n-                x1 = x1 - 0.5 * tolerance;\n-            }\n+            } else {\n+\t\t\t\tif (Math.abs(dx) <= tolerance) {\n+\t\t\t\t\tsetResult(x1, i);\n+\t\t\t\t\treturn result;\n+\t\t\t\t}\n+\t\t\t\tif (dx > 0.0) {\n+\t\t\t\t\tx1 = x1 + 0.5 * tolerance;\n+\t\t\t\t} else if (dx <= 0.0) {\n+\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t}\n+\t\t\t}\n             y1 = f.value(x1);\n             if ((y1 > 0) == (y2 > 0)) {\n                 x2 = x0;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 102, 
          "faulty": "clearResult();", 
          "type": "InsertBefore", 
          "seed": "verifySequence(min,initial,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 126, 
          "faulty": "if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(yMax,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_545/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:27:41.538685168 -0500\n@@ -99,7 +99,8 @@\n                         final double min, final double max, final double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n \n-        clearResult();\n+        verifySequence(min, initial, max);\n+\t\tclearResult();\n         verifySequence(min, initial, max);\n \n         // return the initial guess if it is good enough\n@@ -123,7 +124,8 @@\n \n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n-        if (Math.abs(yMax) <= functionValueAccuracy) {\n+        verifyBracketing(min, max, f);\n+\t\tif (Math.abs(yMax) <= functionValueAccuracy) {\n             setResult(yMax, 0);\n             return result;\n         }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "InsertBefore", 
          "seed": "iterationCount+=this.iterationCount;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_119/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:07:43.643285880 -0500\n@@ -116,7 +116,8 @@\n             return result;\n         }\n \n-        // reduce interval if min and initial bracket the root\n+        iterationCount += this.iterationCount;\n+\t\t// reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n@@ -128,10 +129,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 113, 
          "faulty": "double yMin=f.value(min);", 
          "type": "InsertBefore", 
          "seed": "this.resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1170/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:57:53.759759227 -0500\n@@ -109,7 +109,8 @@\n             return result;\n         }\n \n-        // return the first endpoint if it is good enough\n+        this.resultComputed = true;\n+\t\t// return the first endpoint if it is good enough\n         double yMin = f.value(min);\n         if (Math.abs(yMin) <= functionValueAccuracy) {\n             setResult(yMin, 0);\n@@ -128,10 +129,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "InsertBefore", 
          "seed": "iterationCount+=this.iterationCount;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 126, 
          "faulty": "if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(yMax,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "iterationCount+=this.iterationCount;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_102/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:06:54.251149811 -0500\n@@ -116,22 +116,15 @@\n             return result;\n         }\n \n-        // reduce interval if min and initial bracket the root\n+        iterationCount += this.iterationCount;\n+\t\t// reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n \n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n-        if (Math.abs(yMax) <= functionValueAccuracy) {\n-            setResult(yMax, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 300, 
          "faulty": "x1=x1 + 0.5 * tolerance;", 
          "type": "Delete", 
          "seed": "y0=y1;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 299, 
          "faulty": "if (dx > 0.0) {\n  x1=x1 + 0.5 * tolerance;\n}\n else if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}", 
          "type": "InsertBefore", 
          "seed": "if (Math.abs(dx) <= tolerance) {\n  setResult(x1,i);\n  return result;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_860/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:42:59.089114061 -0500\n@@ -128,10 +128,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -296,11 +293,17 @@\n             // Compute new X1, Y1\n             if (Math.abs(delta) > tolerance) {\n                 x1 = x1 + delta;\n-            } else if (dx > 0.0) {\n-                x1 = x1 + 0.5 * tolerance;\n-            } else if (dx <= 0.0) {\n-                x1 = x1 - 0.5 * tolerance;\n-            }\n+            } else {\n+\t\t\t\tif (Math.abs(dx) <= tolerance) {\n+\t\t\t\t\tsetResult(x1, i);\n+\t\t\t\t\treturn result;\n+\t\t\t\t}\n+\t\t\t\tif (dx > 0.0) {\n+\t\t\t\t\tx1 = x1 + 0.5 * tolerance;\n+\t\t\t\t} else if (dx <= 0.0) {\n+\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t}\n+\t\t\t}\n             y1 = f.value(x1);\n             if ((y1 > 0) == (y2 > 0)) {\n                 x2 = x0;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java", 
          "line": 196, 
          "faulty": "return (start < mid) && (mid < end);", 
          "type": "Replace", 
          "seed": "return (start < mid) && (mid < end);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 125, 
          "faulty": "double yMax=f.value(max);", 
          "type": "InsertBefore", 
          "seed": "verifySequence(min,initial,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "\n\n--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1927/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 07:35:56.746435750 -0500\n@@ -121,17 +121,15 @@\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n \n-        // return the second endpoint if it is good enough\n+        verifySequence(min, initial, max);\n+\t\t// return the second endpoint if it is good enough\n         double yMax = f.value(max);\n         if (Math.abs(yMax) <= functionValueAccuracy) {\n             setResult(yMax, 0);\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "InsertBefore", 
          "seed": "if (f.value(max) == 0.0) {\n  return max;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1623/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 07:20:54.215785041 -0500\n@@ -116,7 +116,10 @@\n             return result;\n         }\n \n-        // reduce interval if min and initial bracket the root\n+        if (f.value(max) == 0.0) {\n+\t\t\treturn max;\n+\t\t}\n+\t\t// reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n@@ -128,10 +131,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java", 
          "line": 196, 
          "faulty": "return (start < mid) && (mid < end);", 
          "type": "InsertBefore", 
          "seed": "this.resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "Replace", 
          "seed": "if (Math.abs(dx) <= tolerance) {\n  setResult(x1,i);\n  return result;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 06:00:06.853104067 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_598/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 06:30:12.927070532 -0500\n@@ -193,7 +193,8 @@\n      * @return true if the arguments form an increasing sequence\n      */\n     protected boolean isSequence(final double start, final double mid, final double end) {\n-        return (start < mid) && (mid < end);\n+        this.resultComputed = true;\n+\t\treturn (start < mid) && (mid < end);\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_598/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:30:12.927070532 -0500\n@@ -128,10 +128,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -284,7 +281,10 @@\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n+                    if (Math.abs(dx) <= tolerance) {\n+\t\t\t\t\t\tsetResult(x1, i);\n+\t\t\t\t\t\treturn result;\n+\t\t\t\t\t}\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java", 
          "line": 196, 
          "faulty": "return (start < mid) && (mid < end);", 
          "type": "InsertBefore", 
          "seed": "this.resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 102, 
          "faulty": "clearResult();", 
          "type": "Delete", 
          "seed": "this.iterationCount=iterationCount;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 06:00:06.853104067 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_772/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 06:38:53.664415447 -0500\n@@ -193,7 +193,8 @@\n      * @return true if the arguments form an increasing sequence\n      */\n     protected boolean isSequence(final double start, final double mid, final double end) {\n-        return (start < mid) && (mid < end);\n+        this.resultComputed = true;\n+\t\treturn (start < mid) && (mid < end);\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_772/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:38:53.668415457 -0500\n@@ -99,7 +99,6 @@\n                         final double min, final double max, final double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n \n-        clearResult();\n         verifySequence(min, initial, max);\n \n         // return the initial guess if it is good enough\n@@ -111,11 +110,6 @@\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n-\n         // reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n@@ -128,10 +122,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "Replace", 
          "seed": "p=dx * r3;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1508/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 07:14:59.738750191 -0500\n@@ -128,7 +128,8 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n+        verifyBracketing(min, max, f);\n+\t\t// reduce interval if initial and max bracket the root\n         if (yInitial * yMax < 0) {\n             return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n         }\n@@ -284,7 +285,7 @@\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n+                    p = dx * r3;\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 107, 
          "faulty": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "this.functionValueAccuracy=defaultFunctionValueAccuracy;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_531/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:27:08.470607725 -0500\n@@ -104,7 +104,8 @@\n \n         // return the initial guess if it is good enough\n         double yInitial = f.value(initial);\n-        if (Math.abs(yInitial) <= functionValueAccuracy) {\n+        this.functionValueAccuracy = defaultFunctionValueAccuracy;\n+\t\tif (Math.abs(yInitial) <= functionValueAccuracy) {\n             setResult(initial, 0);\n             return result;\n         }\n@@ -128,10 +129,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 300, 
          "faulty": "x1=x1 + 0.5 * tolerance;", 
          "type": "InsertBefore", 
          "seed": "functionValueAccuracy=defaultFunctionValueAccuracy;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 299, 
          "faulty": "if (dx > 0.0) {\n  x1=x1 + 0.5 * tolerance;\n}\n else if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}", 
          "type": "InsertBefore", 
          "seed": "if (Math.abs(dx) <= tolerance) {\n  setResult(x1,i);\n  return result;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1052/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:52:26.538791730 -0500\n@@ -128,10 +128,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -296,11 +293,17 @@\n             // Compute new X1, Y1\n             if (Math.abs(delta) > tolerance) {\n                 x1 = x1 + delta;\n-            } else if (dx > 0.0) {\n-                x1 = x1 + 0.5 * tolerance;\n-            } else if (dx <= 0.0) {\n-                x1 = x1 - 0.5 * tolerance;\n-            }\n+            } else {\n+\t\t\t\tif (Math.abs(dx) <= tolerance) {\n+\t\t\t\t\tsetResult(x1, i);\n+\t\t\t\t\treturn result;\n+\t\t\t\t}\n+\t\t\t\tif (dx > 0.0) {\n+\t\t\t\t\tx1 = x1 + 0.5 * tolerance;\n+\t\t\t\t} else if (dx <= 0.0) {\n+\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t}\n+\t\t\t}\n             y1 = f.value(x1);\n             if ((y1 > 0) == (y2 > 0)) {\n                 x2 = x0;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 102, 
          "faulty": "clearResult();", 
          "type": "Replace", 
          "seed": "verifyInterval(min,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1144/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:56:41.795546516 -0500\n@@ -99,7 +99,7 @@\n                         final double min, final double max, final double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n \n-        clearResult();\n+        verifyInterval(min, max);\n         verifySequence(min, initial, max);\n \n         // return the initial guess if it is good enough\n@@ -128,10 +128,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 250, 
          "faulty": "setResult(x1,i);", 
          "type": "InsertBefore", 
          "seed": "if (Math.abs(y1) <= functionValueAccuracy) {\n  setResult(x1,i);\n  return result;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "verifySequence(min,initial,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "Replace", 
          "seed": "iterationCount+=this.iterationCount;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_822/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:41:12.344808698 -0500\n@@ -111,15 +111,7 @@\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if min and initial bracket the root\n-        if (yInitial * yMin < 0) {\n-            return solve(f, min, yMin, initial, yInitial, min, yMin);\n-        }\n+        iterationCount += this.iterationCount;\n \n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n@@ -128,10 +120,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -247,7 +236,11 @@\n             double tolerance =\n                 Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\n             if (Math.abs(dx) <= tolerance) {\n-                setResult(x1, i);\n+                if (Math.abs(y1) <= functionValueAccuracy) {\n+\t\t\t\t\tsetResult(x1, i);\n+\t\t\t\t\treturn result;\n+\t\t\t\t}\n+\t\t\t\tsetResult(x1, i);\n                 return result;\n             }\n             if ((Math.abs(oldDelta) < tolerance) ||\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java", 
          "line": 196, 
          "faulty": "return (start < mid) && (mid < end);", 
          "type": "InsertBefore", 
          "seed": "this.resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 286, 
          "faulty": "delta=0.5 * dx;", 
          "type": "InsertBefore", 
          "seed": "if (2.0 * p >= 1.5 * dx * p1 - Math.abs(tolerance * p1) || p >= Math.abs(0.5 * oldDelta * p1)) {\n  delta=0.5 * dx;\n  oldDelta=delta;\n}\n else {\n  oldDelta=delta;\n  delta=p / p1;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 06:00:06.853104067 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1730/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 07:26:15.808727040 -0500\n@@ -193,7 +193,8 @@\n      * @return true if the arguments form an increasing sequence\n      */\n     protected boolean isSequence(final double start, final double mid, final double end) {\n-        return (start < mid) && (mid < end);\n+        this.resultComputed = true;\n+\t\treturn (start < mid) && (mid < end);\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1730/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 07:26:15.808727040 -0500\n@@ -128,10 +128,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -280,7 +277,16 @@\n                 }\n                 if (2.0 * p >= 1.5 * dx * p1 - Math.abs(tolerance * p1) ||\n                         p >= Math.abs(0.5 * oldDelta * p1)) {\n-                    // Inverse quadratic interpolation gives a value\n+                    if (2.0 * p >= 1.5 * dx * p1\n+\t\t\t\t\t\t\t\t\t- Math.abs(tolerance * p1)\n+\t\t\t\t\t\t\t\t\t|| p >= Math.abs(0.5 * oldDelta * p1)) {\n+\t\t\t\t\t\t\t\tdelta = 0.5 * dx;\n+\t\t\t\t\t\t\t\toldDelta = delta;\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\toldDelta = delta;\n+\t\t\t\t\t\t\t\tdelta = p / p1;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t// Inverse quadratic interpolation gives a value\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 250, 
          "faulty": "setResult(x1,i);", 
          "type": "InsertBefore", 
          "seed": "if (Math.abs(y1) <= functionValueAccuracy) {\n  setResult(x1,i);\n  return result;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "InsertBefore", 
          "seed": "iterationCount+=this.iterationCount;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 126, 
          "faulty": "if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(yMax,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "this.iterationCount=iterationCount;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1326/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 07:05:45.281145461 -0500\n@@ -116,22 +116,15 @@\n             return result;\n         }\n \n-        // reduce interval if min and initial bracket the root\n+        iterationCount += this.iterationCount;\n+\t\t// reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n \n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n-        if (Math.abs(yMax) <= functionValueAccuracy) {\n-            setResult(yMax, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -247,7 +240,11 @@\n             double tolerance =\n                 Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\n             if (Math.abs(dx) <= tolerance) {\n-                setResult(x1, i);\n+                if (Math.abs(y1) <= functionValueAccuracy) {\n+\t\t\t\t\tsetResult(x1, i);\n+\t\t\t\t\treturn result;\n+\t\t\t\t}\n+\t\t\t\tsetResult(x1, i);\n                 return result;\n             }\n             if ((Math.abs(oldDelta) < tolerance) ||\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 126, 
          "faulty": "if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(yMax,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_169/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:10:10.415712434 -0500\n@@ -123,7 +123,8 @@\n \n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n-        if (Math.abs(yMax) <= functionValueAccuracy) {\n+        verifyBracketing(min, max, f);\n+\t\tif (Math.abs(yMax) <= functionValueAccuracy) {\n             setResult(yMax, 0);\n             return result;\n         }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java", 
          "line": 209, 
          "faulty": "throw MathRuntimeException.createIllegalArgumentException(\"endpoints do not specify an interval: [{0}, {1}]\",lower,upper);", 
          "type": "InsertBefore", 
          "seed": "functionValueAccuracy=defaultFunctionValueAccuracy;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "Replace", 
          "seed": "return solve(f,min,max);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 06:00:06.853104067 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1260/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 07:02:39.244602810 -0500\n@@ -206,7 +206,8 @@\n      */\n     protected void verifyInterval(final double lower, final double upper) {\n         if (lower >= upper) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n+            functionValueAccuracy = defaultFunctionValueAccuracy;\n+\t\t\tthrow MathRuntimeException.createIllegalArgumentException(\n                     \"endpoints do not specify an interval: [{0}, {1}]\",\n                     lower, upper);\n         }\n\n\n--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1260/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 07:02:39.244602810 -0500\n@@ -134,8 +134,7 @@\n         }\n \n \n-        // full Brent algorithm starting with provided initial guess\n-        return solve(f, min, yMin, max, yMax, initial, yInitial);\n+        return solve(f, min, max);\n \n     }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_210/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:12:00.888059870 -0500\n@@ -111,10 +111,7 @@\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n+        verifyBracketing(min, max, f);\n \n         // reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n@@ -128,10 +125,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 286, 
          "faulty": "delta=0.5 * dx;", 
          "type": "InsertBefore", 
          "seed": "x1=x1 + 0.5 * tolerance;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 179, 
          "faulty": "if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "this.iterationCount=0;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1457/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 07:12:15.894273668 -0500\n@@ -128,10 +128,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -176,14 +173,16 @@\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n-            } else if (Math.abs(yMax) <= functionValueAccuracy) {\n-                setResult(max, 0);\n-                ret = max;\n             } else {\n-                // neither value is close to zero and min and max do not bracket root.\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                        NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n-            }\n+\t\t\t\tthis.iterationCount = 0;\n+\t\t\t\tif (Math.abs(yMax) <= functionValueAccuracy) {\n+\t\t\t\t\tsetResult(max, 0);\n+\t\t\t\t\tret = max;\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow MathRuntimeException.createIllegalArgumentException(\n+\t\t\t\t\t\t\tNON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n+\t\t\t\t}\n+\t\t\t}\n         } else if (sign < 0){\n             // solve using only the first endpoint as initial guess\n             ret = solve(f, min, yMin, max, yMax, min, yMin);\n@@ -280,7 +279,8 @@\n                 }\n                 if (2.0 * p >= 1.5 * dx * p1 - Math.abs(tolerance * p1) ||\n                         p >= Math.abs(0.5 * oldDelta * p1)) {\n-                    // Inverse quadratic interpolation gives a value\n+                    x1 = x1 + 0.5 * tolerance;\n+\t\t\t\t\t// Inverse quadratic interpolation gives a value\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java", 
          "line": 209, 
          "faulty": "throw MathRuntimeException.createIllegalArgumentException(\"endpoints do not specify an interval: [{0}, {1}]\",lower,upper);", 
          "type": "Replace", 
          "seed": "throw MathRuntimeException.createIllegalArgumentException(\"endpoints do not specify an interval: [{0}, {1}]\",lower,upper);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "verifySequence(min,initial,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 126, 
          "faulty": "if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(yMax,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "this.iterationCount=iterationCount;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 06:00:06.853104067 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1267/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 07:02:57.096655552 -0500\n@@ -207,8 +207,8 @@\n     protected void verifyInterval(final double lower, final double upper) {\n         if (lower >= upper) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"endpoints do not specify an interval: [{0}, {1}]\",\n-                    lower, upper);\n+\t\t\t\t\t\"endpoints do not specify an interval: [{0}, {1}]\", lower,\n+\t\t\t\t\tupper);\n         }\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1267/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 07:02:57.100655563 -0500\n@@ -111,11 +111,6 @@\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n-\n         // reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n@@ -123,15 +118,7 @@\n \n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n-        if (Math.abs(yMax) <= functionValueAccuracy) {\n-            setResult(yMax, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 286, 
          "faulty": "delta=0.5 * dx;", 
          "type": "InsertBefore", 
          "seed": "if (2.0 * p >= 1.5 * dx * p1 - Math.abs(tolerance * p1) || p >= Math.abs(0.5 * oldDelta * p1)) {\n  delta=0.5 * dx;\n  oldDelta=delta;\n}\n else {\n  oldDelta=delta;\n  delta=p / p1;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_549/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:27:50.754707262 -0500\n@@ -128,10 +128,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -280,7 +277,16 @@\n                 }\n                 if (2.0 * p >= 1.5 * dx * p1 - Math.abs(tolerance * p1) ||\n                         p >= Math.abs(0.5 * oldDelta * p1)) {\n-                    // Inverse quadratic interpolation gives a value\n+                    if (2.0 * p >= 1.5 * dx * p1\n+\t\t\t\t\t\t\t\t\t- Math.abs(tolerance * p1)\n+\t\t\t\t\t\t\t\t\t|| p >= Math.abs(0.5 * oldDelta * p1)) {\n+\t\t\t\t\t\t\t\tdelta = 0.5 * dx;\n+\t\t\t\t\t\t\t\toldDelta = delta;\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\toldDelta = delta;\n+\t\t\t\t\t\t\t\tdelta = p / p1;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t// Inverse quadratic interpolation gives a value\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "if (!resultComputed) {\n  throw MathRuntimeException.createIllegalStateException(\"no result available\");\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_297/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:16:06.092888745 -0500\n@@ -111,11 +111,6 @@\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n-\n         // reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n@@ -128,7 +123,8 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n+        verifyBracketing(min, max, f);\n+\t\t// reduce interval if initial and max bracket the root\n         if (yInitial * yMax < 0) {\n             return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n         }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 300, 
          "faulty": "x1=x1 + 0.5 * tolerance;", 
          "type": "InsertBefore", 
          "seed": "if (Math.abs(y1) > Math.abs(y0)) {\n  delta=0.5 * oldDelta;\n}\n else {\n  delta=(x0 - x1) / (1 - y0 / y1);\n  if (delta / oldDelta > 1) {\n    delta=0.5 * oldDelta;\n  }\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_235/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:13:09.224293830 -0500\n@@ -128,10 +128,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -297,7 +294,15 @@\n             if (Math.abs(delta) > tolerance) {\n                 x1 = x1 + delta;\n             } else if (dx > 0.0) {\n-                x1 = x1 + 0.5 * tolerance;\n+                if (Math.abs(y1) > Math.abs(y0)) {\n+\t\t\t\t\tdelta = 0.5 * oldDelta;\n+\t\t\t\t} else {\n+\t\t\t\t\tdelta = (x0 - x1) / (1 - y0 / y1);\n+\t\t\t\t\tif (delta / oldDelta > 1) {\n+\t\t\t\t\t\tdelta = 0.5 * oldDelta;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tx1 = x1 + 0.5 * tolerance;\n             } else if (dx <= 0.0) {\n                 x1 = x1 - 0.5 * tolerance;\n             }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 286, 
          "faulty": "delta=0.5 * dx;", 
          "type": "InsertBefore", 
          "seed": "x1=x1 + 0.5 * tolerance;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 126, 
          "faulty": "if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(yMax,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "this.iterationCount=iterationCount;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1276/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 07:03:18.996720251 -0500\n@@ -123,15 +123,7 @@\n \n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n-        if (Math.abs(yMax) <= functionValueAccuracy) {\n-            setResult(yMax, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -280,7 +272,8 @@\n                 }\n                 if (2.0 * p >= 1.5 * dx * p1 - Math.abs(tolerance * p1) ||\n                         p >= Math.abs(0.5 * oldDelta * p1)) {\n-                    // Inverse quadratic interpolation gives a value\n+                    x1 = x1 + 0.5 * tolerance;\n+\t\t\t\t\t// Inverse quadratic interpolation gives a value\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 179, 
          "faulty": "if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "ret=solve(f,min,yMin,max,yMax,min,yMin);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_172/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:10:16.707731288 -0500\n@@ -128,10 +128,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -176,14 +173,16 @@\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n-            } else if (Math.abs(yMax) <= functionValueAccuracy) {\n-                setResult(max, 0);\n-                ret = max;\n             } else {\n-                // neither value is close to zero and min and max do not bracket root.\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                        NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n-            }\n+\t\t\t\tret = solve(f, min, yMin, max, yMax, min, yMin);\n+\t\t\t\tif (Math.abs(yMax) <= functionValueAccuracy) {\n+\t\t\t\t\tsetResult(max, 0);\n+\t\t\t\t\tret = max;\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow MathRuntimeException.createIllegalArgumentException(\n+\t\t\t\t\t\t\tNON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n+\t\t\t\t}\n+\t\t\t}\n         } else if (sign < 0){\n             // solve using only the first endpoint as initial guess\n             ret = solve(f, min, yMin, max, yMax, min, yMin);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 126, 
          "faulty": "if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(yMax,0);\n  return result;\n}", 
          "type": "Replace", 
          "seed": "iterationCount+=this.iterationCount;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Delete", 
          "seed": "if (f.value(max) == 0.0) {\n  return max;\n}"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_122/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:07:49.887303400 -0500\n@@ -116,23 +116,15 @@\n             return result;\n         }\n \n-        // reduce interval if min and initial bracket the root\n+        verifyBracketing(min, max, f);\n+\t\t// reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n \n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n-        if (Math.abs(yMax) <= functionValueAccuracy) {\n-            setResult(yMax, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n-\n+        iterationCount += this.iterationCount;\n \n         // full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java", 
          "line": 196, 
          "faulty": "return (start < mid) && (mid < end);", 
          "type": "InsertBefore", 
          "seed": "this.iterationCount=0;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 126, 
          "faulty": "if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(yMax,0);\n  return result;\n}", 
          "type": "Replace", 
          "seed": "this.iterationCount=iterationCount;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 06:00:06.853104067 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_690/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 06:34:52.883755422 -0500\n@@ -193,7 +193,8 @@\n      * @return true if the arguments form an increasing sequence\n      */\n     protected boolean isSequence(final double start, final double mid, final double end) {\n-        return (start < mid) && (mid < end);\n+        this.iterationCount = 0;\n+\t\treturn (start < mid) && (mid < end);\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_690/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:34:52.883755422 -0500\n@@ -123,15 +123,9 @@\n \n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n-        if (Math.abs(yMax) <= functionValueAccuracy) {\n-            setResult(yMax, 0);\n-            return result;\n-        }\n+        this.iterationCount = iterationCount;\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 286, 
          "faulty": "delta=0.5 * dx;", 
          "type": "InsertBefore", 
          "seed": "this.f=f;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "Replace", 
          "seed": "iterationCount+=this.iterationCount;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "Replace", 
          "seed": "return solve(f,min,max);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_247/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:13:37.600390178 -0500\n@@ -116,10 +116,7 @@\n             return result;\n         }\n \n-        // reduce interval if min and initial bracket the root\n-        if (yInitial * yMin < 0) {\n-            return solve(f, min, yMin, initial, yInitial, min, yMin);\n-        }\n+        iterationCount += this.iterationCount;\n \n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n@@ -134,8 +131,7 @@\n         }\n \n \n-        // full Brent algorithm starting with provided initial guess\n-        return solve(f, min, yMin, max, yMax, initial, yInitial);\n+        return solve(f, min, max);\n \n     }\n \n@@ -280,7 +276,8 @@\n                 }\n                 if (2.0 * p >= 1.5 * dx * p1 - Math.abs(tolerance * p1) ||\n                         p >= Math.abs(0.5 * oldDelta * p1)) {\n-                    // Inverse quadratic interpolation gives a value\n+                    this.f = f;\n+\t\t\t\t\t// Inverse quadratic interpolation gives a value\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 250, 
          "faulty": "setResult(x1,i);", 
          "type": "InsertBefore", 
          "seed": "y0=y1;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1357/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 07:07:13.157397799 -0500\n@@ -128,10 +128,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -247,7 +244,8 @@\n             double tolerance =\n                 Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\n             if (Math.abs(dx) <= tolerance) {\n-                setResult(x1, i);\n+                y0 = y1;\n+\t\t\t\tsetResult(x1, i);\n                 return result;\n             }\n             if ((Math.abs(oldDelta) < tolerance) ||\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 179, 
          "faulty": "if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "ret=min;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_947/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:47:15.525871095 -0500\n@@ -128,10 +128,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -176,14 +173,16 @@\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n-            } else if (Math.abs(yMax) <= functionValueAccuracy) {\n-                setResult(max, 0);\n-                ret = max;\n             } else {\n-                // neither value is close to zero and min and max do not bracket root.\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                        NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n-            }\n+\t\t\t\tret = min;\n+\t\t\t\tif (Math.abs(yMax) <= functionValueAccuracy) {\n+\t\t\t\t\tsetResult(max, 0);\n+\t\t\t\t\tret = max;\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow MathRuntimeException.createIllegalArgumentException(\n+\t\t\t\t\t\t\tNON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n+\t\t\t\t}\n+\t\t\t}\n         } else if (sign < 0){\n             // solve using only the first endpoint as initial guess\n             ret = solve(f, min, yMin, max, yMax, min, yMin);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java", 
          "line": 196, 
          "faulty": "return (start < mid) && (mid < end);", 
          "type": "InsertBefore", 
          "seed": "this.functionValueAccuracy=defaultFunctionValueAccuracy;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 06:00:06.853104067 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_683/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 06:34:34.323707641 -0500\n@@ -193,7 +193,8 @@\n      * @return true if the arguments form an increasing sequence\n      */\n     protected boolean isSequence(final double start, final double mid, final double end) {\n-        return (start < mid) && (mid < end);\n+        this.functionValueAccuracy = defaultFunctionValueAccuracy;\n+\t\treturn (start < mid) && (mid < end);\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_683/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:34:34.323707641 -0500\n@@ -128,10 +128,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 184, 
          "faulty": "throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);", 
          "type": "InsertBefore", 
          "seed": "if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(yMax,0);\n  return result;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_395/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:20:33.045537398 -0500\n@@ -128,10 +128,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -180,7 +177,11 @@\n                 setResult(max, 0);\n                 ret = max;\n             } else {\n-                // neither value is close to zero and min and max do not bracket root.\n+                if (Math.abs(yMax) <= functionValueAccuracy) {\n+\t\t\t\t\tsetResult(yMax, 0);\n+\t\t\t\t\treturn result;\n+\t\t\t\t}\n+\t\t\t\t// neither value is close to zero and min and max do not bracket root.\n                 throw MathRuntimeException.createIllegalArgumentException(\n                         NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n             }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 102, 
          "faulty": "clearResult();", 
          "type": "Replace", 
          "seed": "setResult(max,0);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1024/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:51:01.974541541 -0500\n@@ -99,7 +99,7 @@\n                         final double min, final double max, final double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n \n-        clearResult();\n+        setResult(max, 0);\n         verifySequence(min, initial, max);\n \n         // return the initial guess if it is good enough\n@@ -128,7 +128,8 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n+        verifyBracketing(min, max, f);\n+\t\t// reduce interval if initial and max bracket the root\n         if (yInitial * yMax < 0) {\n             return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n         }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java", 
          "line": 209, 
          "faulty": "throw MathRuntimeException.createIllegalArgumentException(\"endpoints do not specify an interval: [{0}, {1}]\",lower,upper);", 
          "type": "Replace", 
          "seed": "throw MathRuntimeException.createIllegalArgumentException(\"endpoints do not specify an interval: [{0}, {1}]\",lower,upper);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 299, 
          "faulty": "if (dx > 0.0) {\n  x1=x1 + 0.5 * tolerance;\n}\n else if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}", 
          "type": "InsertBefore", 
          "seed": "if (Math.abs(dx) <= tolerance) {\n  setResult(x1,i);\n  return result;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 06:00:06.853104067 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1162/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 06:57:31.775694250 -0500\n@@ -207,8 +207,8 @@\n     protected void verifyInterval(final double lower, final double upper) {\n         if (lower >= upper) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"endpoints do not specify an interval: [{0}, {1}]\",\n-                    lower, upper);\n+\t\t\t\t\t\"endpoints do not specify an interval: [{0}, {1}]\", lower,\n+\t\t\t\t\tupper);\n         }\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1162/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:57:31.779694261 -0500\n@@ -128,10 +128,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -296,11 +293,17 @@\n             // Compute new X1, Y1\n             if (Math.abs(delta) > tolerance) {\n                 x1 = x1 + delta;\n-            } else if (dx > 0.0) {\n-                x1 = x1 + 0.5 * tolerance;\n-            } else if (dx <= 0.0) {\n-                x1 = x1 - 0.5 * tolerance;\n-            }\n+            } else {\n+\t\t\t\tif (Math.abs(dx) <= tolerance) {\n+\t\t\t\t\tsetResult(x1, i);\n+\t\t\t\t\treturn result;\n+\t\t\t\t}\n+\t\t\t\tif (dx > 0.0) {\n+\t\t\t\t\tx1 = x1 + 0.5 * tolerance;\n+\t\t\t\t} else if (dx <= 0.0) {\n+\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t}\n+\t\t\t}\n             y1 = f.value(x1);\n             if ((y1 > 0) == (y2 > 0)) {\n                 x2 = x0;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "Replace", 
          "seed": "iterationCount+=this.iterationCount;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 126, 
          "faulty": "if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(yMax,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "this.iterationCount=iterationCount;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1124/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:55:45.563380283 -0500\n@@ -116,22 +116,11 @@\n             return result;\n         }\n \n-        // reduce interval if min and initial bracket the root\n-        if (yInitial * yMin < 0) {\n-            return solve(f, min, yMin, initial, yInitial, min, yMin);\n-        }\n+        iterationCount += this.iterationCount;\n \n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n-        if (Math.abs(yMax) <= functionValueAccuracy) {\n-            setResult(yMax, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "InsertBefore", 
          "seed": "if (Math.abs(dx) <= tolerance) {\n  setResult(x1,i);\n  return result;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_706/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:35:40.463880110 -0500\n@@ -128,10 +128,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -284,7 +281,11 @@\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n+                    if (Math.abs(dx) <= tolerance) {\n+\t\t\t\t\t\tsetResult(x1, i);\n+\t\t\t\t\t\treturn result;\n+\t\t\t\t\t}\n+\t\t\t\t\toldDelta = delta;\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 251, 
          "faulty": "return result;", 
          "type": "Replace", 
          "seed": "if (Math.abs(oldDelta) < Math.max(relativeAccuracy * Math.abs(x1),absoluteAccuracy)) {\n  setResult(x1,i);\n  return result;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1978/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 07:38:30.486888228 -0500\n@@ -128,10 +128,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -248,7 +245,11 @@\n                 Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\n             if (Math.abs(dx) <= tolerance) {\n                 setResult(x1, i);\n-                return result;\n+                if (Math.abs(oldDelta) < Math.max(\n+\t\t\t\t\t\trelativeAccuracy * Math.abs(x1), absoluteAccuracy)) {\n+\t\t\t\t\tsetResult(x1, i);\n+\t\t\t\t\treturn result;\n+\t\t\t\t}\n             }\n             if ((Math.abs(oldDelta) < tolerance) ||\n                     (Math.abs(y0) <= Math.abs(y1))) {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java", 
          "line": 196, 
          "faulty": "return (start < mid) && (mid < end);", 
          "type": "InsertBefore", 
          "seed": "this.iterationCount=0;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 102, 
          "faulty": "clearResult();", 
          "type": "Replace", 
          "seed": "setResult(max,0);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 06:00:06.853104067 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1067/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 06:53:10.390921439 -0500\n@@ -193,7 +193,8 @@\n      * @return true if the arguments form an increasing sequence\n      */\n     protected boolean isSequence(final double start, final double mid, final double end) {\n-        return (start < mid) && (mid < end);\n+        this.iterationCount = 0;\n+\t\treturn (start < mid) && (mid < end);\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1067/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:53:10.390921439 -0500\n@@ -99,7 +99,7 @@\n                         final double min, final double max, final double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n \n-        clearResult();\n+        setResult(max, 0);\n         verifySequence(min, initial, max);\n \n         // return the initial guess if it is good enough\n@@ -128,10 +128,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 184, 
          "faulty": "throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);", 
          "type": "Delete", 
          "seed": "if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(yMax,0);\n  return result;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 126, 
          "faulty": "if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(yMax,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "this.iterationCount=iterationCount;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 179, 
          "faulty": "if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "this.iterationCount=0;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1921/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 07:35:40.782388761 -0500\n@@ -123,15 +123,13 @@\n \n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n-        if (Math.abs(yMax) <= functionValueAccuracy) {\n+        this.iterationCount = iterationCount;\n+\t\tif (Math.abs(yMax) <= functionValueAccuracy) {\n             setResult(yMax, 0);\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -176,14 +174,16 @@\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n-            } else if (Math.abs(yMax) <= functionValueAccuracy) {\n-                setResult(max, 0);\n-                ret = max;\n             } else {\n-                // neither value is close to zero and min and max do not bracket root.\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                        NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n-            }\n+\t\t\t\tthis.iterationCount = 0;\n+\t\t\t\tif (Math.abs(yMax) <= functionValueAccuracy) {\n+\t\t\t\t\tsetResult(max, 0);\n+\t\t\t\t\tret = max;\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow MathRuntimeException.createIllegalArgumentException(\n+\t\t\t\t\t\t\tNON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n+\t\t\t\t}\n+\t\t\t}\n         } else if (sign < 0){\n             // solve using only the first endpoint as initial guess\n             ret = solve(f, min, yMin, max, yMax, min, yMin);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 251, 
          "faulty": "return result;", 
          "type": "InsertBefore", 
          "seed": "delta=x1 - x0;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "Replace", 
          "seed": "iterationCount+=this.iterationCount;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1741/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 07:26:47.160818974 -0500\n@@ -116,10 +116,7 @@\n             return result;\n         }\n \n-        // reduce interval if min and initial bracket the root\n-        if (yInitial * yMin < 0) {\n-            return solve(f, min, yMin, initial, yInitial, min, yMin);\n-        }\n+        iterationCount += this.iterationCount;\n \n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n@@ -128,10 +125,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -248,7 +242,8 @@\n                 Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\n             if (Math.abs(dx) <= tolerance) {\n                 setResult(x1, i);\n-                return result;\n+                delta = x1 - x0;\n+\t\t\t\treturn result;\n             }\n             if ((Math.abs(oldDelta) < tolerance) ||\n                     (Math.abs(y0) <= Math.abs(y1))) {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "verifySequence(min,initial,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1273/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 07:03:12.708701675 -0500\n@@ -111,7 +111,8 @@\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n+        verifySequence(min, initial, max);\n+\t\tif (Math.abs(yMin) <= functionValueAccuracy) {\n             setResult(yMin, 0);\n             return result;\n         }\n@@ -128,10 +129,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java", 
          "line": 209, 
          "faulty": "throw MathRuntimeException.createIllegalArgumentException(\"endpoints do not specify an interval: [{0}, {1}]\",lower,upper);", 
          "type": "Replace", 
          "seed": "throw MathRuntimeException.createIllegalArgumentException(\"endpoints do not specify an interval: [{0}, {1}]\",lower,upper);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 06:00:06.853104067 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_319/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 06:17:08.169040471 -0500\n@@ -207,8 +207,8 @@\n     protected void verifyInterval(final double lower, final double upper) {\n         if (lower >= upper) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"endpoints do not specify an interval: [{0}, {1}]\",\n-                    lower, upper);\n+\t\t\t\t\t\"endpoints do not specify an interval: [{0}, {1}]\", lower,\n+\t\t\t\t\tupper);\n         }\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_319/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:17:08.169040471 -0500\n@@ -128,10 +128,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "Delete", 
          "seed": "y1=f.value(x1);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_291/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:15:50.548836913 -0500\n@@ -128,10 +128,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -284,7 +281,6 @@\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 102, 
          "faulty": "clearResult();", 
          "type": "Replace", 
          "seed": "setResult(max,0);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "Replace", 
          "seed": "if (Math.abs(dx) <= tolerance) {\n  setResult(x1,i);\n  return result;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1617/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 07:20:41.627748216 -0500\n@@ -99,7 +99,7 @@\n                         final double min, final double max, final double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n \n-        clearResult();\n+        setResult(max, 0);\n         verifySequence(min, initial, max);\n \n         // return the initial guess if it is good enough\n@@ -128,10 +128,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -284,7 +281,10 @@\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n+                    if (Math.abs(dx) <= tolerance) {\n+\t\t\t\t\t\tsetResult(x1, i);\n+\t\t\t\t\t\treturn result;\n+\t\t\t\t\t}\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 102, 
          "faulty": "clearResult();", 
          "type": "Replace", 
          "seed": "setResult(max,0);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "Replace", 
          "seed": "if (Math.abs(dx) <= tolerance) {\n  setResult(x1,i);\n  return result;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 126, 
          "faulty": "if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(yMax,0);\n  return result;\n}", 
          "type": "Replace", 
          "seed": "this.iterationCount=iterationCount;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1112/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:55:13.707286100 -0500\n@@ -99,7 +99,7 @@\n                         final double min, final double max, final double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n \n-        clearResult();\n+        setResult(max, 0);\n         verifySequence(min, initial, max);\n \n         // return the initial guess if it is good enough\n@@ -123,12 +123,10 @@\n \n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n-        if (Math.abs(yMax) <= functionValueAccuracy) {\n-            setResult(yMax, 0);\n-            return result;\n-        }\n+        this.iterationCount = iterationCount;\n \n-        // reduce interval if initial and max bracket the root\n+        verifyBracketing(min, max, f);\n+\t\t// reduce interval if initial and max bracket the root\n         if (yInitial * yMax < 0) {\n             return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n         }\n@@ -284,7 +282,10 @@\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n+                    if (Math.abs(dx) <= tolerance) {\n+\t\t\t\t\t\tsetResult(x1, i);\n+\t\t\t\t\t\treturn result;\n+\t\t\t\t\t}\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 126, 
          "faulty": "if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(yMax,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "this.iterationCount=iterationCount;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 179, 
          "faulty": "if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "this.iterationCount=0;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1335/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 07:06:06.881207386 -0500\n@@ -123,15 +123,7 @@\n \n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n-        if (Math.abs(yMax) <= functionValueAccuracy) {\n-            setResult(yMax, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -176,14 +168,16 @@\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n-            } else if (Math.abs(yMax) <= functionValueAccuracy) {\n-                setResult(max, 0);\n-                ret = max;\n             } else {\n-                // neither value is close to zero and min and max do not bracket root.\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                        NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n-            }\n+\t\t\t\tthis.iterationCount = 0;\n+\t\t\t\tif (Math.abs(yMax) <= functionValueAccuracy) {\n+\t\t\t\t\tsetResult(max, 0);\n+\t\t\t\t\tret = max;\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow MathRuntimeException.createIllegalArgumentException(\n+\t\t\t\t\t\t\tNON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n+\t\t\t\t}\n+\t\t\t}\n         } else if (sign < 0){\n             // solve using only the first endpoint as initial guess\n             ret = solve(f, min, yMin, max, yMax, min, yMin);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java", 
          "line": 209, 
          "faulty": "throw MathRuntimeException.createIllegalArgumentException(\"endpoints do not specify an interval: [{0}, {1}]\",lower,upper);", 
          "type": "Replace", 
          "seed": "throw MathRuntimeException.createIllegalArgumentException(\"endpoints do not specify an interval: [{0}, {1}]\",lower,upper);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 126, 
          "faulty": "if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(yMax,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "this.iterationCount=iterationCount;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 06:00:06.853104067 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1285/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 07:03:44.112794449 -0500\n@@ -207,8 +207,8 @@\n     protected void verifyInterval(final double lower, final double upper) {\n         if (lower >= upper) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"endpoints do not specify an interval: [{0}, {1}]\",\n-                    lower, upper);\n+\t\t\t\t\t\"endpoints do not specify an interval: [{0}, {1}]\", lower,\n+\t\t\t\t\tupper);\n         }\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1285/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 07:03:44.112794449 -0500\n@@ -123,15 +123,7 @@\n \n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n-        if (Math.abs(yMax) <= functionValueAccuracy) {\n-            setResult(yMax, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 300, 
          "faulty": "x1=x1 + 0.5 * tolerance;", 
          "type": "InsertBefore", 
          "seed": "if ((Math.abs(oldDelta) < tolerance) || (Math.abs(y0) <= Math.abs(y1))) {\n  delta=0.5 * dx;\n  oldDelta=delta;\n}\n else {\n  double r3=y1 / y0;\n  double p;\n  double p1;\n  if (x0 == x2) {\n    p=dx * r3;\n    p1=1.0 - r3;\n  }\n else {\n    double r1=y0 / y2;\n    double r2=y1 / y2;\n    p=r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));\n    p1=(r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);\n  }\n  if (p > 0.0) {\n    p1=-p1;\n  }\n else {\n    p=-p;\n  }\n  if (2.0 * p >= 1.5 * dx * p1 - Math.abs(tolerance * p1) || p >= Math.abs(0.5 * oldDelta * p1)) {\n    delta=0.5 * dx;\n    oldDelta=delta;\n  }\n else {\n    oldDelta=delta;\n    delta=p / p1;\n  }\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_354/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:18:45.777262073 -0500\n@@ -128,10 +128,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -297,7 +294,38 @@\n             if (Math.abs(delta) > tolerance) {\n                 x1 = x1 + delta;\n             } else if (dx > 0.0) {\n-                x1 = x1 + 0.5 * tolerance;\n+                if ((Math.abs(oldDelta) < tolerance)\n+\t\t\t\t\t\t|| (Math.abs(y0) <= Math.abs(y1))) {\n+\t\t\t\t\tdelta = 0.5 * dx;\n+\t\t\t\t\toldDelta = delta;\n+\t\t\t\t} else {\n+\t\t\t\t\tdouble r3 = y1 / y0;\n+\t\t\t\t\tdouble p;\n+\t\t\t\t\tdouble p1;\n+\t\t\t\t\tif (x0 == x2) {\n+\t\t\t\t\t\tp = dx * r3;\n+\t\t\t\t\t\tp1 = 1.0 - r3;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tdouble r1 = y0 / y2;\n+\t\t\t\t\t\tdouble r2 = y1 / y2;\n+\t\t\t\t\t\tp = r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));\n+\t\t\t\t\t\tp1 = (r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);\n+\t\t\t\t\t}\n+\t\t\t\t\tif (p > 0.0) {\n+\t\t\t\t\t\tp1 = -p1;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tp = -p;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (2.0 * p >= 1.5 * dx * p1 - Math.abs(tolerance * p1)\n+\t\t\t\t\t\t\t|| p >= Math.abs(0.5 * oldDelta * p1)) {\n+\t\t\t\t\t\tdelta = 0.5 * dx;\n+\t\t\t\t\t\toldDelta = delta;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\toldDelta = delta;\n+\t\t\t\t\t\tdelta = p / p1;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tx1 = x1 + 0.5 * tolerance;\n             } else if (dx <= 0.0) {\n                 x1 = x1 - 0.5 * tolerance;\n             }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 250, 
          "faulty": "setResult(x1,i);", 
          "type": "InsertBefore", 
          "seed": "if (Math.abs(y1) <= functionValueAccuracy) {\n  setResult(x1,i);\n  return result;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 126, 
          "faulty": "if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(yMax,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "if (f == null) {\n  throw MathRuntimeException.createIllegalArgumentException(\"function to solve cannot be null\");\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_301/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:16:15.416919803 -0500\n@@ -123,15 +123,7 @@\n \n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n-        if (Math.abs(yMax) <= functionValueAccuracy) {\n-            setResult(yMax, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -247,7 +239,11 @@\n             double tolerance =\n                 Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\n             if (Math.abs(dx) <= tolerance) {\n-                setResult(x1, i);\n+                if (Math.abs(y1) <= functionValueAccuracy) {\n+\t\t\t\t\tsetResult(x1, i);\n+\t\t\t\t\treturn result;\n+\t\t\t\t}\n+\t\t\t\tsetResult(x1, i);\n                 return result;\n             }\n             if ((Math.abs(oldDelta) < tolerance) ||\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 102, 
          "faulty": "clearResult();", 
          "type": "Replace", 
          "seed": "setResult(max,0);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "if (!resultComputed) {\n  throw MathRuntimeException.createIllegalStateException(\"no result available\");\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1888/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 07:34:06.170110260 -0500\n@@ -99,7 +99,7 @@\n                         final double min, final double max, final double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n \n-        clearResult();\n+        setResult(max, 0);\n         verifySequence(min, initial, max);\n \n         // return the initial guess if it is good enough\n@@ -111,11 +111,6 @@\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n-\n         // reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n@@ -128,10 +123,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "Replace", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_802/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:40:16.220649024 -0500\n@@ -128,10 +128,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -284,7 +281,7 @@\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n+                    clearResult();\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 250, 
          "faulty": "setResult(x1,i);", 
          "type": "InsertBefore", 
          "seed": "if (Math.abs(y1) <= functionValueAccuracy) {\n  setResult(x1,i);\n  return result;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "Delete", 
          "seed": "p=dx * r3;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_724/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:36:29.592012270 -0500\n@@ -128,10 +128,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -247,7 +244,11 @@\n             double tolerance =\n                 Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\n             if (Math.abs(dx) <= tolerance) {\n-                setResult(x1, i);\n+                if (Math.abs(y1) <= functionValueAccuracy) {\n+\t\t\t\t\tsetResult(x1, i);\n+\t\t\t\t\treturn result;\n+\t\t\t\t}\n+\t\t\t\tsetResult(x1, i);\n                 return result;\n             }\n             if ((Math.abs(oldDelta) < tolerance) ||\n@@ -284,7 +285,6 @@\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "Replace", 
          "seed": "p1=1.0 - r3;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 300, 
          "faulty": "x1=x1 + 0.5 * tolerance;", 
          "type": "InsertBefore", 
          "seed": "if ((Math.abs(oldDelta) < tolerance) || (Math.abs(y0) <= Math.abs(y1))) {\n  delta=0.5 * dx;\n  oldDelta=delta;\n}\n else {\n  double r3=y1 / y0;\n  double p;\n  double p1;\n  if (x0 == x2) {\n    p=dx * r3;\n    p1=1.0 - r3;\n  }\n else {\n    double r1=y0 / y2;\n    double r2=y1 / y2;\n    p=r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));\n    p1=(r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);\n  }\n  if (p > 0.0) {\n    p1=-p1;\n  }\n else {\n    p=-p;\n  }\n  if (2.0 * p >= 1.5 * dx * p1 - Math.abs(tolerance * p1) || p >= Math.abs(0.5 * oldDelta * p1)) {\n    delta=0.5 * dx;\n    oldDelta=delta;\n  }\n else {\n    oldDelta=delta;\n    delta=p / p1;\n  }\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 126, 
          "faulty": "if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(yMax,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "this.iterationCount=iterationCount;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_278/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:15:12.980711339 -0500\n@@ -123,15 +123,7 @@\n \n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n-        if (Math.abs(yMax) <= functionValueAccuracy) {\n-            setResult(yMax, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -284,7 +276,7 @@\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n+                    p1 = 1.0 - r3;\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n@@ -297,7 +289,38 @@\n             if (Math.abs(delta) > tolerance) {\n                 x1 = x1 + delta;\n             } else if (dx > 0.0) {\n-                x1 = x1 + 0.5 * tolerance;\n+                if ((Math.abs(oldDelta) < tolerance)\n+\t\t\t\t\t\t|| (Math.abs(y0) <= Math.abs(y1))) {\n+\t\t\t\t\tdelta = 0.5 * dx;\n+\t\t\t\t\toldDelta = delta;\n+\t\t\t\t} else {\n+\t\t\t\t\tdouble r3 = y1 / y0;\n+\t\t\t\t\tdouble p;\n+\t\t\t\t\tdouble p1;\n+\t\t\t\t\tif (x0 == x2) {\n+\t\t\t\t\t\tp = dx * r3;\n+\t\t\t\t\t\tp1 = 1.0 - r3;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tdouble r1 = y0 / y2;\n+\t\t\t\t\t\tdouble r2 = y1 / y2;\n+\t\t\t\t\t\tp = r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));\n+\t\t\t\t\t\tp1 = (r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);\n+\t\t\t\t\t}\n+\t\t\t\t\tif (p > 0.0) {\n+\t\t\t\t\t\tp1 = -p1;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tp = -p;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (2.0 * p >= 1.5 * dx * p1 - Math.abs(tolerance * p1)\n+\t\t\t\t\t\t\t|| p >= Math.abs(0.5 * oldDelta * p1)) {\n+\t\t\t\t\t\tdelta = 0.5 * dx;\n+\t\t\t\t\t\toldDelta = delta;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\toldDelta = delta;\n+\t\t\t\t\t\tdelta = p / p1;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tx1 = x1 + 0.5 * tolerance;\n             } else if (dx <= 0.0) {\n                 x1 = x1 - 0.5 * tolerance;\n             }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "Replace", 
          "seed": "if (Math.abs(yInitial) <= functionValueAccuracy) {\n  setResult(initial,0);\n  return result;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 126, 
          "faulty": "if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(yMax,0);\n  return result;\n}", 
          "type": "Replace", 
          "seed": "this.resultComputed=false;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "Replace", 
          "seed": "return solve(f,min,max);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_197/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:11:26.987944249 -0500\n@@ -116,17 +116,14 @@\n             return result;\n         }\n \n-        // reduce interval if min and initial bracket the root\n-        if (yInitial * yMin < 0) {\n-            return solve(f, min, yMin, initial, yInitial, min, yMin);\n-        }\n+        if (Math.abs(yInitial) <= functionValueAccuracy) {\n+\t\t\tsetResult(initial, 0);\n+\t\t\treturn result;\n+\t\t}\n \n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n-        if (Math.abs(yMax) <= functionValueAccuracy) {\n-            setResult(yMax, 0);\n-            return result;\n-        }\n+        this.resultComputed = false;\n \n         // reduce interval if initial and max bracket the root\n         if (yInitial * yMax < 0) {\n@@ -134,8 +131,7 @@\n         }\n \n \n-        // full Brent algorithm starting with provided initial guess\n-        return solve(f, min, yMin, max, yMax, initial, yInitial);\n+        return solve(f, min, max);\n \n     }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 184, 
          "faulty": "throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);", 
          "type": "Replace", 
          "seed": "if (sign > 0) {\n  if (Math.abs(yMin) <= functionValueAccuracy) {\n    setResult(min,0);\n    ret=min;\n  }\n else   if (Math.abs(yMax) <= functionValueAccuracy) {\n    setResult(max,0);\n    ret=max;\n  }\n else {\n    throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n  }\n}\n else if (sign < 0) {\n  ret=solve(f,min,yMin,max,yMax,min,yMin);\n}\n else {\n  if (yMin == 0.0) {\n    ret=min;\n  }\n else {\n    ret=max;\n  }\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_166/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:10:04.071693461 -0500\n@@ -128,10 +128,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -180,9 +177,28 @@\n                 setResult(max, 0);\n                 ret = max;\n             } else {\n-                // neither value is close to zero and min and max do not bracket root.\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                        NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n+                if (sign > 0) {\n+\t\t\t\t\tif (Math.abs(yMin) <= functionValueAccuracy) {\n+\t\t\t\t\t\tsetResult(min, 0);\n+\t\t\t\t\t\tret = min;\n+\t\t\t\t\t} else if (Math.abs(yMax) <= functionValueAccuracy) {\n+\t\t\t\t\t\tsetResult(max, 0);\n+\t\t\t\t\t\tret = max;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tthrow MathRuntimeException\n+\t\t\t\t\t\t\t\t.createIllegalArgumentException(\n+\t\t\t\t\t\t\t\t\t\tNON_BRACKETING_MESSAGE, min, max, yMin,\n+\t\t\t\t\t\t\t\t\t\tyMax);\n+\t\t\t\t\t}\n+\t\t\t\t} else if (sign < 0) {\n+\t\t\t\t\tret = solve(f, min, yMin, max, yMax, min, yMin);\n+\t\t\t\t} else {\n+\t\t\t\t\tif (yMin == 0.0) {\n+\t\t\t\t\t\tret = min;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tret = max;\n+\t\t\t\t\t}\n+\t\t\t\t}\n             }\n         } else if (sign < 0){\n             // solve using only the first endpoint as initial guess\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 250, 
          "faulty": "setResult(x1,i);", 
          "type": "InsertBefore", 
          "seed": "x0=x1;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1324/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 07:05:42.261136808 -0500\n@@ -128,10 +128,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -247,7 +244,8 @@\n             double tolerance =\n                 Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\n             if (Math.abs(dx) <= tolerance) {\n-                setResult(x1, i);\n+                x0 = x1;\n+\t\t\t\tsetResult(x1, i);\n                 return result;\n             }\n             if ((Math.abs(oldDelta) < tolerance) ||\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "Replace", 
          "seed": "p=dx * r3;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "Replace", 
          "seed": "iterationCount+=this.iterationCount;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_502/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:25:49.406436257 -0500\n@@ -116,10 +116,7 @@\n             return result;\n         }\n \n-        // reduce interval if min and initial bracket the root\n-        if (yInitial * yMin < 0) {\n-            return solve(f, min, yMin, initial, yInitial, min, yMin);\n-        }\n+        iterationCount += this.iterationCount;\n \n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n@@ -128,10 +125,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -284,7 +278,7 @@\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n+                    p = dx * r3;\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "Replace", 
          "seed": "return solve(f,min,max);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_74/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:05:33.458938803 -0500\n@@ -134,8 +134,7 @@\n         }\n \n \n-        // full Brent algorithm starting with provided initial guess\n-        return solve(f, min, yMin, max, yMax, initial, yInitial);\n+        return solve(f, min, max);\n \n     }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "Replace", 
          "seed": "if (Math.abs(dx) <= tolerance) {\n  setResult(x1,i);\n  return result;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 286, 
          "faulty": "delta=0.5 * dx;", 
          "type": "InsertBefore", 
          "seed": "if ((y1 > 0) == (y2 > 0)) {\n  x2=x0;\n  y2=y0;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_593/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:30:03.523045424 -0500\n@@ -128,10 +128,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -280,11 +277,18 @@\n                 }\n                 if (2.0 * p >= 1.5 * dx * p1 - Math.abs(tolerance * p1) ||\n                         p >= Math.abs(0.5 * oldDelta * p1)) {\n-                    // Inverse quadratic interpolation gives a value\n+                    if ((y1 > 0) == (y2 > 0)) {\n+\t\t\t\t\t\t\t\tx2 = x0;\n+\t\t\t\t\t\t\t\ty2 = y0;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t// Inverse quadratic interpolation gives a value\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n+                    if (Math.abs(dx) <= tolerance) {\n+\t\t\t\t\t\tsetResult(x1, i);\n+\t\t\t\t\t\treturn result;\n+\t\t\t\t\t}\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 179, 
          "faulty": "if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "this.iterationCount=0;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_201/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:11:36.403975265 -0500\n@@ -128,10 +128,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -176,14 +173,16 @@\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n-            } else if (Math.abs(yMax) <= functionValueAccuracy) {\n-                setResult(max, 0);\n-                ret = max;\n             } else {\n-                // neither value is close to zero and min and max do not bracket root.\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                        NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n-            }\n+\t\t\t\tthis.iterationCount = 0;\n+\t\t\t\tif (Math.abs(yMax) <= functionValueAccuracy) {\n+\t\t\t\t\tsetResult(max, 0);\n+\t\t\t\t\tret = max;\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow MathRuntimeException.createIllegalArgumentException(\n+\t\t\t\t\t\t\tNON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n+\t\t\t\t}\n+\t\t\t}\n         } else if (sign < 0){\n             // solve using only the first endpoint as initial guess\n             ret = solve(f, min, yMin, max, yMax, min, yMin);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java", 
          "line": 196, 
          "faulty": "return (start < mid) && (mid < end);", 
          "type": "InsertBefore", 
          "seed": "this.iterationCount=0;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java", 
          "line": 209, 
          "faulty": "throw MathRuntimeException.createIllegalArgumentException(\"endpoints do not specify an interval: [{0}, {1}]\",lower,upper);", 
          "type": "Replace", 
          "seed": "throw MathRuntimeException.createIllegalArgumentException(\"endpoints do not specify an interval: [{0}, {1}]\",lower,upper);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 06:00:06.853104067 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_649/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 06:32:47.307443972 -0500\n@@ -193,7 +193,8 @@\n      * @return true if the arguments form an increasing sequence\n      */\n     protected boolean isSequence(final double start, final double mid, final double end) {\n-        return (start < mid) && (mid < end);\n+        this.iterationCount = 0;\n+\t\treturn (start < mid) && (mid < end);\n     }\n \n     /**\n@@ -207,8 +208,8 @@\n     protected void verifyInterval(final double lower, final double upper) {\n         if (lower >= upper) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"endpoints do not specify an interval: [{0}, {1}]\",\n-                    lower, upper);\n+\t\t\t\t\t\"endpoints do not specify an interval: [{0}, {1}]\", lower,\n+\t\t\t\t\tupper);\n         }\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_649/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:32:47.311443981 -0500\n@@ -128,10 +128,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 286, 
          "faulty": "delta=0.5 * dx;", 
          "type": "InsertBefore", 
          "seed": "x1=x1 + 0.5 * tolerance;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_403/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:20:51.785588031 -0500\n@@ -128,10 +128,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -280,7 +277,8 @@\n                 }\n                 if (2.0 * p >= 1.5 * dx * p1 - Math.abs(tolerance * p1) ||\n                         p >= Math.abs(0.5 * oldDelta * p1)) {\n-                    // Inverse quadratic interpolation gives a value\n+                    x1 = x1 + 0.5 * tolerance;\n+\t\t\t\t\t// Inverse quadratic interpolation gives a value\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java", 
          "line": 196, 
          "faulty": "return (start < mid) && (mid < end);", 
          "type": "InsertBefore", 
          "seed": "this.iterationCount=0;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 06:00:06.853104067 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_383/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 06:20:01.461453600 -0500\n@@ -193,7 +193,8 @@\n      * @return true if the arguments form an increasing sequence\n      */\n     protected boolean isSequence(final double start, final double mid, final double end) {\n-        return (start < mid) && (mid < end);\n+        this.iterationCount = 0;\n+\t\treturn (start < mid) && (mid < end);\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_383/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:20:01.461453600 -0500\n@@ -128,10 +128,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "Replace", 
          "seed": "if (Math.abs(dx) <= tolerance) {\n  setResult(x1,i);\n  return result;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_764/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:38:32.724356472 -0500\n@@ -128,10 +128,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -284,7 +281,10 @@\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n+                    if (Math.abs(dx) <= tolerance) {\n+\t\t\t\t\t\tsetResult(x1, i);\n+\t\t\t\t\t\treturn result;\n+\t\t\t\t\t}\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "Delete", 
          "seed": "clearResult();"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "InsertBefore", 
          "seed": "iterationCount+=this.iterationCount;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_333/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:17:47.925126645 -0500\n@@ -116,7 +116,8 @@\n             return result;\n         }\n \n-        // reduce interval if min and initial bracket the root\n+        iterationCount += this.iterationCount;\n+\t\t// reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n@@ -128,10 +129,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -284,7 +282,6 @@\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 125, 
          "faulty": "double yMax=f.value(max);", 
          "type": "InsertBefore", 
          "seed": "verifySequence(min,initial,max);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_474/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:24:25.418199919 -0500\n@@ -121,17 +121,15 @@\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n \n-        // return the second endpoint if it is good enough\n+        verifySequence(min, initial, max);\n+\t\t// return the second endpoint if it is good enough\n         double yMax = f.value(max);\n         if (Math.abs(yMax) <= functionValueAccuracy) {\n             setResult(yMax, 0);\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "InsertBefore", 
          "seed": "iterationCount+=this.iterationCount;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_220/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:12:29.652158711 -0500\n@@ -116,7 +116,8 @@\n             return result;\n         }\n \n-        // reduce interval if min and initial bracket the root\n+        iterationCount += this.iterationCount;\n+\t\t// reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n@@ -128,7 +129,8 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n+        verifyBracketing(min, max, f);\n+\t\t// reduce interval if initial and max bracket the root\n         if (yInitial * yMax < 0) {\n             return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n         }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "if (!resultComputed) {\n  throw MathRuntimeException.createIllegalStateException(\"no result available\");\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 179, 
          "faulty": "if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "ret=min;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_890/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:44:25.333368536 -0500\n@@ -111,11 +111,6 @@\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n-\n         // reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n@@ -128,10 +123,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -176,14 +168,16 @@\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n-            } else if (Math.abs(yMax) <= functionValueAccuracy) {\n-                setResult(max, 0);\n-                ret = max;\n             } else {\n-                // neither value is close to zero and min and max do not bracket root.\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                        NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n-            }\n+\t\t\t\tret = min;\n+\t\t\t\tif (Math.abs(yMax) <= functionValueAccuracy) {\n+\t\t\t\t\tsetResult(max, 0);\n+\t\t\t\t\tret = max;\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow MathRuntimeException.createIllegalArgumentException(\n+\t\t\t\t\t\t\tNON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n+\t\t\t\t}\n+\t\t\t}\n         } else if (sign < 0){\n             // solve using only the first endpoint as initial guess\n             ret = solve(f, min, yMin, max, yMax, min, yMin);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 126, 
          "faulty": "if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(yMax,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "this.iterationCount=iterationCount;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1426/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 07:10:41.341999218 -0500\n@@ -111,11 +111,6 @@\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n-\n         // reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n@@ -123,15 +118,13 @@\n \n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n-        if (Math.abs(yMax) <= functionValueAccuracy) {\n+        this.iterationCount = iterationCount;\n+\t\tif (Math.abs(yMax) <= functionValueAccuracy) {\n             setResult(yMax, 0);\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java", 
          "line": 196, 
          "faulty": "return (start < mid) && (mid < end);", 
          "type": "InsertBefore", 
          "seed": "this.resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 126, 
          "faulty": "if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(yMax,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "this.iterationCount=iterationCount;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 06:00:06.853104067 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_971/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 06:48:23.886073574 -0500\n@@ -193,7 +193,8 @@\n      * @return true if the arguments form an increasing sequence\n      */\n     protected boolean isSequence(final double start, final double mid, final double end) {\n-        return (start < mid) && (mid < end);\n+        this.resultComputed = true;\n+\t\treturn (start < mid) && (mid < end);\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_971/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:48:23.890073587 -0500\n@@ -123,15 +123,7 @@\n \n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n-        if (Math.abs(yMax) <= functionValueAccuracy) {\n-            setResult(yMax, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 113, 
          "faulty": "double yMin=f.value(min);", 
          "type": "InsertBefore", 
          "seed": "setResult(max,0);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1814/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 07:30:26.589463762 -0500\n@@ -109,7 +109,8 @@\n             return result;\n         }\n \n-        // return the first endpoint if it is good enough\n+        setResult(max, 0);\n+\t\t// return the first endpoint if it is good enough\n         double yMin = f.value(min);\n         if (Math.abs(yMin) <= functionValueAccuracy) {\n             setResult(yMin, 0);\n@@ -128,10 +129,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 106, 
          "faulty": "double yInitial=f.value(initial);", 
          "type": "InsertBefore", 
          "seed": "iterationCount+=this.iterationCount;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1818/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 07:30:35.981491419 -0500\n@@ -102,7 +102,8 @@\n         clearResult();\n         verifySequence(min, initial, max);\n \n-        // return the initial guess if it is good enough\n+        iterationCount += this.iterationCount;\n+\t\t// return the initial guess if it is good enough\n         double yInitial = f.value(initial);\n         if (Math.abs(yInitial) <= functionValueAccuracy) {\n             setResult(initial, 0);\n@@ -128,10 +129,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "Replace", 
          "seed": "if (Math.abs(dx) <= tolerance) {\n  setResult(x1,i);\n  return result;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "InsertBefore", 
          "seed": "iterationCount+=this.iterationCount;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_868/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:43:20.953178517 -0500\n@@ -116,7 +116,8 @@\n             return result;\n         }\n \n-        // reduce interval if min and initial bracket the root\n+        iterationCount += this.iterationCount;\n+\t\t// reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n@@ -128,10 +129,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -284,7 +282,10 @@\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n+                    if (Math.abs(dx) <= tolerance) {\n+\t\t\t\t\t\tsetResult(x1, i);\n+\t\t\t\t\t\treturn result;\n+\t\t\t\t\t}\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 299, 
          "faulty": "if (dx > 0.0) {\n  x1=x1 + 0.5 * tolerance;\n}\n else if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}", 
          "type": "InsertBefore", 
          "seed": "if (Math.abs(dx) <= tolerance) {\n  setResult(x1,i);\n  return result;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_242/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:13:27.972357534 -0500\n@@ -128,10 +128,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -296,11 +293,17 @@\n             // Compute new X1, Y1\n             if (Math.abs(delta) > tolerance) {\n                 x1 = x1 + delta;\n-            } else if (dx > 0.0) {\n-                x1 = x1 + 0.5 * tolerance;\n-            } else if (dx <= 0.0) {\n-                x1 = x1 - 0.5 * tolerance;\n-            }\n+            } else {\n+\t\t\t\tif (Math.abs(dx) <= tolerance) {\n+\t\t\t\t\tsetResult(x1, i);\n+\t\t\t\t\treturn result;\n+\t\t\t\t}\n+\t\t\t\tif (dx > 0.0) {\n+\t\t\t\t\tx1 = x1 + 0.5 * tolerance;\n+\t\t\t\t} else if (dx <= 0.0) {\n+\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t}\n+\t\t\t}\n             y1 = f.value(x1);\n             if ((y1 > 0) == (y2 > 0)) {\n                 x2 = x0;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java", 
          "line": 209, 
          "faulty": "throw MathRuntimeException.createIllegalArgumentException(\"endpoints do not specify an interval: [{0}, {1}]\",lower,upper);", 
          "type": "Replace", 
          "seed": "throw MathRuntimeException.createIllegalArgumentException(\"endpoints do not specify an interval: [{0}, {1}]\",lower,upper);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 06:00:06.853104067 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1450/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 07:11:56.926218558 -0500\n@@ -207,8 +207,8 @@\n     protected void verifyInterval(final double lower, final double upper) {\n         if (lower >= upper) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"endpoints do not specify an interval: [{0}, {1}]\",\n-                    lower, upper);\n+\t\t\t\t\t\"endpoints do not specify an interval: [{0}, {1}]\", lower,\n+\t\t\t\t\tupper);\n         }\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1450/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 07:11:56.926218558 -0500\n@@ -128,7 +128,8 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n+        verifyBracketing(min, max, f);\n+\t\t// reduce interval if initial and max bracket the root\n         if (yInitial * yMax < 0) {\n             return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n         }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "Delete", 
          "seed": "p=dx * r3;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 113, 
          "faulty": "double yMin=f.value(min);", 
          "type": "InsertBefore", 
          "seed": "this.resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "Replace", 
          "seed": "iterationCount+=this.iterationCount;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_514/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:26:24.062508792 -0500\n@@ -109,17 +109,15 @@\n             return result;\n         }\n \n-        // return the first endpoint if it is good enough\n+        this.resultComputed = true;\n+\t\t// return the first endpoint if it is good enough\n         double yMin = f.value(min);\n         if (Math.abs(yMin) <= functionValueAccuracy) {\n             setResult(yMin, 0);\n             return result;\n         }\n \n-        // reduce interval if min and initial bracket the root\n-        if (yInitial * yMin < 0) {\n-            return solve(f, min, yMin, initial, yInitial, min, yMin);\n-        }\n+        iterationCount += this.iterationCount;\n \n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n@@ -128,10 +126,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -284,7 +279,6 @@\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java", 
          "line": 196, 
          "faulty": "return (start < mid) && (mid < end);", 
          "type": "InsertBefore", 
          "seed": "this.iterationCount=0;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 286, 
          "faulty": "delta=0.5 * dx;", 
          "type": "InsertBefore", 
          "seed": "x1=x1 + 0.5 * tolerance;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 06:00:06.853104067 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1117/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 06:55:26.675324441 -0500\n@@ -193,7 +193,8 @@\n      * @return true if the arguments form an increasing sequence\n      */\n     protected boolean isSequence(final double start, final double mid, final double end) {\n-        return (start < mid) && (mid < end);\n+        this.iterationCount = 0;\n+\t\treturn (start < mid) && (mid < end);\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1117/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:55:26.679324453 -0500\n@@ -128,10 +128,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -280,7 +277,8 @@\n                 }\n                 if (2.0 * p >= 1.5 * dx * p1 - Math.abs(tolerance * p1) ||\n                         p >= Math.abs(0.5 * oldDelta * p1)) {\n-                    // Inverse quadratic interpolation gives a value\n+                    x1 = x1 + 0.5 * tolerance;\n+\t\t\t\t\t// Inverse quadratic interpolation gives a value\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java", 
          "line": 209, 
          "faulty": "throw MathRuntimeException.createIllegalArgumentException(\"endpoints do not specify an interval: [{0}, {1}]\",lower,upper);", 
          "type": "Replace", 
          "seed": "throw MathRuntimeException.createIllegalArgumentException(\"endpoints do not specify an interval: [{0}, {1}]\",lower,upper);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "Replace", 
          "seed": "iterationCount+=this.iterationCount;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 06:00:06.853104067 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1084/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 06:53:56.747058536 -0500\n@@ -207,8 +207,8 @@\n     protected void verifyInterval(final double lower, final double upper) {\n         if (lower >= upper) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"endpoints do not specify an interval: [{0}, {1}]\",\n-                    lower, upper);\n+\t\t\t\t\t\"endpoints do not specify an interval: [{0}, {1}]\", lower,\n+\t\t\t\t\tupper);\n         }\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1084/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:53:56.751058547 -0500\n@@ -116,10 +116,7 @@\n             return result;\n         }\n \n-        // reduce interval if min and initial bracket the root\n-        if (yInitial * yMin < 0) {\n-            return solve(f, min, yMin, initial, yInitial, min, yMin);\n-        }\n+        iterationCount += this.iterationCount;\n \n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n@@ -128,10 +125,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 102, 
          "faulty": "clearResult();", 
          "type": "Replace", 
          "seed": "setResult(max,0);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_223/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:12:35.744179575 -0500\n@@ -99,7 +99,7 @@\n                         final double min, final double max, final double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n \n-        clearResult();\n+        setResult(max, 0);\n         verifySequence(min, initial, max);\n \n         // return the initial guess if it is good enough\n@@ -128,10 +128,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 250, 
          "faulty": "setResult(x1,i);", 
          "type": "InsertBefore", 
          "seed": "if (Math.abs(y1) <= functionValueAccuracy) {\n  setResult(x1,i);\n  return result;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "InsertBefore", 
          "seed": "iterationCount+=this.iterationCount;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_529/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:27:05.382600649 -0500\n@@ -116,7 +116,8 @@\n             return result;\n         }\n \n-        // reduce interval if min and initial bracket the root\n+        iterationCount += this.iterationCount;\n+\t\t// reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n@@ -128,10 +129,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -247,7 +245,11 @@\n             double tolerance =\n                 Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\n             if (Math.abs(dx) <= tolerance) {\n-                setResult(x1, i);\n+                if (Math.abs(y1) <= functionValueAccuracy) {\n+\t\t\t\t\tsetResult(x1, i);\n+\t\t\t\t\treturn result;\n+\t\t\t\t}\n+\t\t\t\tsetResult(x1, i);\n                 return result;\n             }\n             if ((Math.abs(oldDelta) < tolerance) ||\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 102, 
          "faulty": "clearResult();", 
          "type": "InsertBefore", 
          "seed": "setResult(max,0);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1853/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 07:32:21.773802919 -0500\n@@ -99,7 +99,8 @@\n                         final double min, final double max, final double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n \n-        clearResult();\n+        setResult(max, 0);\n+\t\tclearResult();\n         verifySequence(min, initial, max);\n \n         // return the initial guess if it is good enough\n@@ -128,10 +129,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 251, 
          "faulty": "return result;", 
          "type": "InsertBefore", 
          "seed": "x1=0.5 * (x0 + x2);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1015/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:50:36.746466885 -0500\n@@ -128,10 +128,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -248,7 +245,8 @@\n                 Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\n             if (Math.abs(dx) <= tolerance) {\n                 setResult(x1, i);\n-                return result;\n+                x1 = 0.5 * (x0 + x2);\n+\t\t\t\treturn result;\n             }\n             if ((Math.abs(oldDelta) < tolerance) ||\n                     (Math.abs(y0) <= Math.abs(y1))) {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 250, 
          "faulty": "setResult(x1,i);", 
          "type": "InsertBefore", 
          "seed": "if (Math.abs(y1) <= functionValueAccuracy) {\n  setResult(x1,i);\n  return result;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java", 
          "line": 196, 
          "faulty": "return (start < mid) && (mid < end);", 
          "type": "InsertBefore", 
          "seed": "this.resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 06:00:06.853104067 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_737/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 06:37:11.636129270 -0500\n@@ -193,7 +193,8 @@\n      * @return true if the arguments form an increasing sequence\n      */\n     protected boolean isSequence(final double start, final double mid, final double end) {\n-        return (start < mid) && (mid < end);\n+        this.resultComputed = true;\n+\t\treturn (start < mid) && (mid < end);\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_737/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:37:11.636129270 -0500\n@@ -128,10 +128,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -247,7 +244,11 @@\n             double tolerance =\n                 Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\n             if (Math.abs(dx) <= tolerance) {\n-                setResult(x1, i);\n+                if (Math.abs(y1) <= functionValueAccuracy) {\n+\t\t\t\t\tsetResult(x1, i);\n+\t\t\t\t\treturn result;\n+\t\t\t\t}\n+\t\t\t\tsetResult(x1, i);\n                 return result;\n             }\n             if ((Math.abs(oldDelta) < tolerance) ||\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java", 
          "line": 196, 
          "faulty": "return (start < mid) && (mid < end);", 
          "type": "InsertBefore", 
          "seed": "this.iterationCount=0;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java", 
          "line": 209, 
          "faulty": "throw MathRuntimeException.createIllegalArgumentException(\"endpoints do not specify an interval: [{0}, {1}]\",lower,upper);", 
          "type": "Replace", 
          "seed": "throw MathRuntimeException.createIllegalArgumentException(\"endpoints do not specify an interval: [{0}, {1}]\",lower,upper);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 300, 
          "faulty": "x1=x1 + 0.5 * tolerance;", 
          "type": "InsertBefore", 
          "seed": "if ((Math.abs(oldDelta) < tolerance) || (Math.abs(y0) <= Math.abs(y1))) {\n  delta=0.5 * dx;\n  oldDelta=delta;\n}\n else {\n  double r3=y1 / y0;\n  double p;\n  double p1;\n  if (x0 == x2) {\n    p=dx * r3;\n    p1=1.0 - r3;\n  }\n else {\n    double r1=y0 / y2;\n    double r2=y1 / y2;\n    p=r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));\n    p1=(r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);\n  }\n  if (p > 0.0) {\n    p1=-p1;\n  }\n else {\n    p=-p;\n  }\n  if (2.0 * p >= 1.5 * dx * p1 - Math.abs(tolerance * p1) || p >= Math.abs(0.5 * oldDelta * p1)) {\n    delta=0.5 * dx;\n    oldDelta=delta;\n  }\n else {\n    oldDelta=delta;\n    delta=p / p1;\n  }\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 06:00:06.853104067 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_533/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 06:27:11.554614820 -0500\n@@ -193,7 +193,8 @@\n      * @return true if the arguments form an increasing sequence\n      */\n     protected boolean isSequence(final double start, final double mid, final double end) {\n-        return (start < mid) && (mid < end);\n+        this.iterationCount = 0;\n+\t\treturn (start < mid) && (mid < end);\n     }\n \n     /**\n@@ -207,8 +208,8 @@\n     protected void verifyInterval(final double lower, final double upper) {\n         if (lower >= upper) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"endpoints do not specify an interval: [{0}, {1}]\",\n-                    lower, upper);\n+\t\t\t\t\t\"endpoints do not specify an interval: [{0}, {1}]\", lower,\n+\t\t\t\t\tupper);\n         }\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_533/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:27:11.558614829 -0500\n@@ -128,10 +128,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -297,7 +294,38 @@\n             if (Math.abs(delta) > tolerance) {\n                 x1 = x1 + delta;\n             } else if (dx > 0.0) {\n-                x1 = x1 + 0.5 * tolerance;\n+                if ((Math.abs(oldDelta) < tolerance)\n+\t\t\t\t\t\t|| (Math.abs(y0) <= Math.abs(y1))) {\n+\t\t\t\t\tdelta = 0.5 * dx;\n+\t\t\t\t\toldDelta = delta;\n+\t\t\t\t} else {\n+\t\t\t\t\tdouble r3 = y1 / y0;\n+\t\t\t\t\tdouble p;\n+\t\t\t\t\tdouble p1;\n+\t\t\t\t\tif (x0 == x2) {\n+\t\t\t\t\t\tp = dx * r3;\n+\t\t\t\t\t\tp1 = 1.0 - r3;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tdouble r1 = y0 / y2;\n+\t\t\t\t\t\tdouble r2 = y1 / y2;\n+\t\t\t\t\t\tp = r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));\n+\t\t\t\t\t\tp1 = (r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);\n+\t\t\t\t\t}\n+\t\t\t\t\tif (p > 0.0) {\n+\t\t\t\t\t\tp1 = -p1;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tp = -p;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (2.0 * p >= 1.5 * dx * p1 - Math.abs(tolerance * p1)\n+\t\t\t\t\t\t\t|| p >= Math.abs(0.5 * oldDelta * p1)) {\n+\t\t\t\t\t\tdelta = 0.5 * dx;\n+\t\t\t\t\t\toldDelta = delta;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\toldDelta = delta;\n+\t\t\t\t\t\tdelta = p / p1;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tx1 = x1 + 0.5 * tolerance;\n             } else if (dx <= 0.0) {\n                 x1 = x1 - 0.5 * tolerance;\n             }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java", 
          "line": 209, 
          "faulty": "throw MathRuntimeException.createIllegalArgumentException(\"endpoints do not specify an interval: [{0}, {1}]\",lower,upper);", 
          "type": "InsertBefore", 
          "seed": "this.resultComputed=false;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 06:00:06.853104067 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1414/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 07:10:06.597898550 -0500\n@@ -206,7 +206,8 @@\n      */\n     protected void verifyInterval(final double lower, final double upper) {\n         if (lower >= upper) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n+            this.resultComputed = false;\n+\t\t\tthrow MathRuntimeException.createIllegalArgumentException(\n                     \"endpoints do not specify an interval: [{0}, {1}]\",\n                     lower, upper);\n         }\n\n\n--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1414/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 07:10:06.597898550 -0500\n@@ -128,10 +128,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 126, 
          "faulty": "if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(yMax,0);\n  return result;\n}", 
          "type": "InsertBefore", 
          "seed": "this.iterationCount=iterationCount;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_401/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:20:48.725579720 -0500\n@@ -123,15 +123,13 @@\n \n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n-        if (Math.abs(yMax) <= functionValueAccuracy) {\n+        this.iterationCount = iterationCount;\n+\t\tif (Math.abs(yMax) <= functionValueAccuracy) {\n             setResult(yMax, 0);\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java", 
          "line": 209, 
          "faulty": "throw MathRuntimeException.createIllegalArgumentException(\"endpoints do not specify an interval: [{0}, {1}]\",lower,upper);", 
          "type": "Replace", 
          "seed": "throw MathRuntimeException.createIllegalArgumentException(\"endpoints do not specify an interval: [{0}, {1}]\",lower,upper);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 126, 
          "faulty": "if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(yMax,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "this.iterationCount=iterationCount;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 179, 
          "faulty": "if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "this.iterationCount=0;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 06:00:06.853104067 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_390/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 06:20:20.341503451 -0500\n@@ -207,8 +207,8 @@\n     protected void verifyInterval(final double lower, final double upper) {\n         if (lower >= upper) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"endpoints do not specify an interval: [{0}, {1}]\",\n-                    lower, upper);\n+\t\t\t\t\t\"endpoints do not specify an interval: [{0}, {1}]\", lower,\n+\t\t\t\t\tupper);\n         }\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_390/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:20:20.341503451 -0500\n@@ -123,15 +123,7 @@\n \n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n-        if (Math.abs(yMax) <= functionValueAccuracy) {\n-            setResult(yMax, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -176,14 +168,16 @@\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n-            } else if (Math.abs(yMax) <= functionValueAccuracy) {\n-                setResult(max, 0);\n-                ret = max;\n             } else {\n-                // neither value is close to zero and min and max do not bracket root.\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                        NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n-            }\n+\t\t\t\tthis.iterationCount = 0;\n+\t\t\t\tif (Math.abs(yMax) <= functionValueAccuracy) {\n+\t\t\t\t\tsetResult(max, 0);\n+\t\t\t\t\tret = max;\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow MathRuntimeException.createIllegalArgumentException(\n+\t\t\t\t\t\t\tNON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n+\t\t\t\t}\n+\t\t\t}\n         } else if (sign < 0){\n             // solve using only the first endpoint as initial guess\n             ret = solve(f, min, yMin, max, yMax, min, yMin);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java", 
          "line": 196, 
          "faulty": "return (start < mid) && (mid < end);", 
          "type": "InsertBefore", 
          "seed": "this.iterationCount=0;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 300, 
          "faulty": "x1=x1 + 0.5 * tolerance;", 
          "type": "InsertBefore", 
          "seed": "if (Math.abs(y1) > Math.abs(y0)) {\n  delta=0.5 * oldDelta;\n}\n else {\n  delta=(x0 - x1) / (1 - y0 / y1);\n  if (delta / oldDelta > 1) {\n    delta=0.5 * oldDelta;\n  }\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 06:00:06.853104067 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_535/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 06:27:14.762622228 -0500\n@@ -193,7 +193,8 @@\n      * @return true if the arguments form an increasing sequence\n      */\n     protected boolean isSequence(final double start, final double mid, final double end) {\n-        return (start < mid) && (mid < end);\n+        this.iterationCount = 0;\n+\t\treturn (start < mid) && (mid < end);\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_535/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:27:14.762622228 -0500\n@@ -128,10 +128,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -297,7 +294,15 @@\n             if (Math.abs(delta) > tolerance) {\n                 x1 = x1 + delta;\n             } else if (dx > 0.0) {\n-                x1 = x1 + 0.5 * tolerance;\n+                if (Math.abs(y1) > Math.abs(y0)) {\n+\t\t\t\t\tdelta = 0.5 * oldDelta;\n+\t\t\t\t} else {\n+\t\t\t\t\tdelta = (x0 - x1) / (1 - y0 / y1);\n+\t\t\t\t\tif (delta / oldDelta > 1) {\n+\t\t\t\t\t\tdelta = 0.5 * oldDelta;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tx1 = x1 + 0.5 * tolerance;\n             } else if (dx <= 0.0) {\n                 x1 = x1 - 0.5 * tolerance;\n             }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 102, 
          "faulty": "clearResult();", 
          "type": "Delete", 
          "seed": "this.iterationCount=iterationCount;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1669/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 07:23:13.924194010 -0500\n@@ -99,7 +99,6 @@\n                         final double min, final double max, final double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n \n-        clearResult();\n         verifySequence(min, initial, max);\n \n         // return the initial guess if it is good enough\n@@ -128,10 +127,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "InsertBefore", 
          "seed": "verifyInterval(min,max);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1756/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 07:27:30.400945789 -0500\n@@ -128,13 +128,11 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n-        // full Brent algorithm starting with provided initial guess\n+        verifyInterval(min, max);\n+\t\t// full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n \n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java", 
          "line": 209, 
          "faulty": "throw MathRuntimeException.createIllegalArgumentException(\"endpoints do not specify an interval: [{0}, {1}]\",lower,upper);", 
          "type": "Replace", 
          "seed": "throw MathRuntimeException.createIllegalArgumentException(\"endpoints do not specify an interval: [{0}, {1}]\",lower,upper);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "InsertBefore", 
          "seed": "iterationCount+=this.iterationCount;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 06:00:06.853104067 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_716/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 06:36:08.331954442 -0500\n@@ -207,8 +207,8 @@\n     protected void verifyInterval(final double lower, final double upper) {\n         if (lower >= upper) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"endpoints do not specify an interval: [{0}, {1}]\",\n-                    lower, upper);\n+\t\t\t\t\t\"endpoints do not specify an interval: [{0}, {1}]\", lower,\n+\t\t\t\t\tupper);\n         }\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_716/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:36:08.331954442 -0500\n@@ -116,7 +116,8 @@\n             return result;\n         }\n \n-        // reduce interval if min and initial bracket the root\n+        iterationCount += this.iterationCount;\n+\t\t// reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n@@ -128,10 +129,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 184, 
          "faulty": "throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);", 
          "type": "Delete", 
          "seed": "if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(yMax,0);\n  return result;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 179, 
          "faulty": "if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "this.iterationCount=0;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1087/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:54:02.911076763 -0500\n@@ -128,10 +128,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -176,14 +173,16 @@\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n-            } else if (Math.abs(yMax) <= functionValueAccuracy) {\n-                setResult(max, 0);\n-                ret = max;\n             } else {\n-                // neither value is close to zero and min and max do not bracket root.\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                        NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n-            }\n+\t\t\t\tthis.iterationCount = 0;\n+\t\t\t\tif (Math.abs(yMax) <= functionValueAccuracy) {\n+\t\t\t\t\tsetResult(max, 0);\n+\t\t\t\t\tret = max;\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow MathRuntimeException.createIllegalArgumentException(\n+\t\t\t\t\t\t\tNON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n+\t\t\t\t}\n+\t\t\t}\n         } else if (sign < 0){\n             // solve using only the first endpoint as initial guess\n             ret = solve(f, min, yMin, max, yMax, min, yMin);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 179, 
          "faulty": "if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(min,0);\n  ret=min;\n}\n else if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1154/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:57:10.375630996 -0500\n@@ -128,10 +128,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -176,14 +173,25 @@\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n-            } else if (Math.abs(yMax) <= functionValueAccuracy) {\n-                setResult(max, 0);\n-                ret = max;\n             } else {\n-                // neither value is close to zero and min and max do not bracket root.\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                        NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n-            }\n+\t\t\t\tif (Math.abs(yMin) <= functionValueAccuracy) {\n+\t\t\t\t\tsetResult(min, 0);\n+\t\t\t\t\tret = min;\n+\t\t\t\t} else if (Math.abs(yMax) <= functionValueAccuracy) {\n+\t\t\t\t\tsetResult(max, 0);\n+\t\t\t\t\tret = max;\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow MathRuntimeException.createIllegalArgumentException(\n+\t\t\t\t\t\t\tNON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n+\t\t\t\t}\n+\t\t\t\tif (Math.abs(yMax) <= functionValueAccuracy) {\n+\t\t\t\t\tsetResult(max, 0);\n+\t\t\t\t\tret = max;\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow MathRuntimeException.createIllegalArgumentException(\n+\t\t\t\t\t\t\tNON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n+\t\t\t\t}\n+\t\t\t}\n         } else if (sign < 0){\n             // solve using only the first endpoint as initial guess\n             ret = solve(f, min, yMin, max, yMax, min, yMin);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 250, 
          "faulty": "setResult(x1,i);", 
          "type": "InsertBefore", 
          "seed": "if (Math.abs(y1) <= functionValueAccuracy) {\n  setResult(x1,i);\n  return result;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_470/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:24:16.206172551 -0500\n@@ -128,10 +128,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -247,7 +244,11 @@\n             double tolerance =\n                 Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\n             if (Math.abs(dx) <= tolerance) {\n-                setResult(x1, i);\n+                if (Math.abs(y1) <= functionValueAccuracy) {\n+\t\t\t\t\tsetResult(x1, i);\n+\t\t\t\t\treturn result;\n+\t\t\t\t}\n+\t\t\t\tsetResult(x1, i);\n                 return result;\n             }\n             if ((Math.abs(oldDelta) < tolerance) ||\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 286, 
          "faulty": "delta=0.5 * dx;", 
          "type": "InsertBefore", 
          "seed": "if (Math.abs(y1) <= functionValueAccuracy) {\n  setResult(x1,i);\n  return result;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_580/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:29:26.966949094 -0500\n@@ -128,10 +128,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -280,7 +277,11 @@\n                 }\n                 if (2.0 * p >= 1.5 * dx * p1 - Math.abs(tolerance * p1) ||\n                         p >= Math.abs(0.5 * oldDelta * p1)) {\n-                    // Inverse quadratic interpolation gives a value\n+                    if (Math.abs(y1) <= functionValueAccuracy) {\n+\t\t\t\t\t\t\t\tsetResult(x1, i);\n+\t\t\t\t\t\t\t\treturn result;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t// Inverse quadratic interpolation gives a value\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java", 
          "line": 196, 
          "faulty": "return (start < mid) && (mid < end);", 
          "type": "InsertBefore", 
          "seed": "this.resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 06:00:06.853104067 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_245/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 06:13:34.376379252 -0500\n@@ -193,7 +193,8 @@\n      * @return true if the arguments form an increasing sequence\n      */\n     protected boolean isSequence(final double start, final double mid, final double end) {\n-        return (start < mid) && (mid < end);\n+        this.resultComputed = true;\n+\t\treturn (start < mid) && (mid < end);\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_245/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:13:34.376379252 -0500\n@@ -128,10 +128,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java", 
          "line": 209, 
          "faulty": "throw MathRuntimeException.createIllegalArgumentException(\"endpoints do not specify an interval: [{0}, {1}]\",lower,upper);", 
          "type": "Replace", 
          "seed": "throw MathRuntimeException.createIllegalArgumentException(\"endpoints do not specify an interval: [{0}, {1}]\",lower,upper);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 299, 
          "faulty": "if (dx > 0.0) {\n  x1=x1 + 0.5 * tolerance;\n}\n else if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}", 
          "type": "InsertBefore", 
          "seed": "if (Math.abs(dx) <= tolerance) {\n  setResult(x1,i);\n  return result;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 06:00:06.853104067 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_814/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 06:40:50.404746199 -0500\n@@ -207,8 +207,8 @@\n     protected void verifyInterval(final double lower, final double upper) {\n         if (lower >= upper) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"endpoints do not specify an interval: [{0}, {1}]\",\n-                    lower, upper);\n+\t\t\t\t\t\"endpoints do not specify an interval: [{0}, {1}]\", lower,\n+\t\t\t\t\tupper);\n         }\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_814/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:40:50.404746199 -0500\n@@ -111,11 +111,6 @@\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n-\n         // reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n@@ -128,10 +123,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -296,11 +288,17 @@\n             // Compute new X1, Y1\n             if (Math.abs(delta) > tolerance) {\n                 x1 = x1 + delta;\n-            } else if (dx > 0.0) {\n-                x1 = x1 + 0.5 * tolerance;\n-            } else if (dx <= 0.0) {\n-                x1 = x1 - 0.5 * tolerance;\n-            }\n+            } else {\n+\t\t\t\tif (Math.abs(dx) <= tolerance) {\n+\t\t\t\t\tsetResult(x1, i);\n+\t\t\t\t\treturn result;\n+\t\t\t\t}\n+\t\t\t\tif (dx > 0.0) {\n+\t\t\t\t\tx1 = x1 + 0.5 * tolerance;\n+\t\t\t\t} else if (dx <= 0.0) {\n+\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t}\n+\t\t\t}\n             y1 = f.value(x1);\n             if ((y1 > 0) == (y2 > 0)) {\n                 x2 = x0;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "Delete", 
          "seed": "p=dx * r3;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 126, 
          "faulty": "if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(yMax,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "this.iterationCount=iterationCount;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1079/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:53:44.275021652 -0500\n@@ -123,15 +123,7 @@\n \n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n-        if (Math.abs(yMax) <= functionValueAccuracy) {\n-            setResult(yMax, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -284,7 +276,6 @@\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java", 
          "line": 209, 
          "faulty": "throw MathRuntimeException.createIllegalArgumentException(\"endpoints do not specify an interval: [{0}, {1}]\",lower,upper);", 
          "type": "Replace", 
          "seed": "throw MathRuntimeException.createIllegalArgumentException(\"endpoints do not specify an interval: [{0}, {1}]\",lower,upper);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 286, 
          "faulty": "delta=0.5 * dx;", 
          "type": "InsertBefore", 
          "seed": "x1=x1 + 0.5 * tolerance;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 06:00:06.853104067 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_626/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 06:31:37.299285540 -0500\n@@ -207,8 +207,8 @@\n     protected void verifyInterval(final double lower, final double upper) {\n         if (lower >= upper) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"endpoints do not specify an interval: [{0}, {1}]\",\n-                    lower, upper);\n+\t\t\t\t\t\"endpoints do not specify an interval: [{0}, {1}]\", lower,\n+\t\t\t\t\tupper);\n         }\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_626/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:31:37.303285549 -0500\n@@ -128,10 +128,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -280,7 +277,8 @@\n                 }\n                 if (2.0 * p >= 1.5 * dx * p1 - Math.abs(tolerance * p1) ||\n                         p >= Math.abs(0.5 * oldDelta * p1)) {\n-                    // Inverse quadratic interpolation gives a value\n+                    x1 = x1 + 0.5 * tolerance;\n+\t\t\t\t\t// Inverse quadratic interpolation gives a value\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java", 
          "line": 209, 
          "faulty": "throw MathRuntimeException.createIllegalArgumentException(\"endpoints do not specify an interval: [{0}, {1}]\",lower,upper);", 
          "type": "InsertBefore", 
          "seed": "resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 06:00:06.853104067 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1989/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 07:39:01.186978573 -0500\n@@ -206,7 +206,8 @@\n      */\n     protected void verifyInterval(final double lower, final double upper) {\n         if (lower >= upper) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n+            resultComputed = true;\n+\t\t\tthrow MathRuntimeException.createIllegalArgumentException(\n                     \"endpoints do not specify an interval: [{0}, {1}]\",\n                     lower, upper);\n         }\n\n\n--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1989/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 07:39:01.190978585 -0500\n@@ -128,10 +128,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java", 
          "line": 209, 
          "faulty": "throw MathRuntimeException.createIllegalArgumentException(\"endpoints do not specify an interval: [{0}, {1}]\",lower,upper);", 
          "type": "InsertBefore", 
          "seed": "iterationCount+=this.iterationCount;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 06:00:06.853104067 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1959/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 07:37:31.058713331 -0500\n@@ -206,7 +206,8 @@\n      */\n     protected void verifyInterval(final double lower, final double upper) {\n         if (lower >= upper) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n+            iterationCount += this.iterationCount;\n+\t\t\tthrow MathRuntimeException.createIllegalArgumentException(\n                     \"endpoints do not specify an interval: [{0}, {1}]\",\n                     lower, upper);\n         }\n\n\n--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1959/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 07:37:31.058713331 -0500\n@@ -128,10 +128,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java", 
          "line": 196, 
          "faulty": "return (start < mid) && (mid < end);", 
          "type": "InsertBefore", 
          "seed": "this.iterationCount=0;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 138, 
          "faulty": "return solve(f,min,yMin,max,yMax,initial,yInitial);", 
          "type": "Replace", 
          "seed": "return solve(f,min,max);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 06:00:06.853104067 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_851/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\t2018-12-01 06:42:35.801047269 -0500\n@@ -193,7 +193,8 @@\n      * @return true if the arguments form an increasing sequence\n      */\n     protected boolean isSequence(final double start, final double mid, final double end) {\n-        return (start < mid) && (mid < end);\n+        this.iterationCount = 0;\n+\t\treturn (start < mid) && (mid < end);\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_851/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:42:35.801047269 -0500\n@@ -134,8 +134,7 @@\n         }\n \n \n-        // full Brent algorithm starting with provided initial guess\n-        return solve(f, min, yMin, max, yMax, initial, yInitial);\n+        return solve(f, min, max);\n \n     }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 300, 
          "faulty": "x1=x1 + 0.5 * tolerance;", 
          "type": "InsertBefore", 
          "seed": "if ((Math.abs(oldDelta) < tolerance) || (Math.abs(y0) <= Math.abs(y1))) {\n  delta=0.5 * dx;\n  oldDelta=delta;\n}\n else {\n  double r3=y1 / y0;\n  double p;\n  double p1;\n  if (x0 == x2) {\n    p=dx * r3;\n    p1=1.0 - r3;\n  }\n else {\n    double r1=y0 / y2;\n    double r2=y1 / y2;\n    p=r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));\n    p1=(r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);\n  }\n  if (p > 0.0) {\n    p1=-p1;\n  }\n else {\n    p=-p;\n  }\n  if (2.0 * p >= 1.5 * dx * p1 - Math.abs(tolerance * p1) || p >= Math.abs(0.5 * oldDelta * p1)) {\n    delta=0.5 * dx;\n    oldDelta=delta;\n  }\n else {\n    oldDelta=delta;\n    delta=p / p1;\n  }\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "Replace", 
          "seed": "iterationCount+=this.iterationCount;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_365/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:19:10.933324120 -0500\n@@ -116,10 +116,7 @@\n             return result;\n         }\n \n-        // reduce interval if min and initial bracket the root\n-        if (yInitial * yMin < 0) {\n-            return solve(f, min, yMin, initial, yInitial, min, yMin);\n-        }\n+        iterationCount += this.iterationCount;\n \n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n@@ -128,10 +125,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -297,7 +291,38 @@\n             if (Math.abs(delta) > tolerance) {\n                 x1 = x1 + delta;\n             } else if (dx > 0.0) {\n-                x1 = x1 + 0.5 * tolerance;\n+                if ((Math.abs(oldDelta) < tolerance)\n+\t\t\t\t\t\t|| (Math.abs(y0) <= Math.abs(y1))) {\n+\t\t\t\t\tdelta = 0.5 * dx;\n+\t\t\t\t\toldDelta = delta;\n+\t\t\t\t} else {\n+\t\t\t\t\tdouble r3 = y1 / y0;\n+\t\t\t\t\tdouble p;\n+\t\t\t\t\tdouble p1;\n+\t\t\t\t\tif (x0 == x2) {\n+\t\t\t\t\t\tp = dx * r3;\n+\t\t\t\t\t\tp1 = 1.0 - r3;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tdouble r1 = y0 / y2;\n+\t\t\t\t\t\tdouble r2 = y1 / y2;\n+\t\t\t\t\t\tp = r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));\n+\t\t\t\t\t\tp1 = (r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);\n+\t\t\t\t\t}\n+\t\t\t\t\tif (p > 0.0) {\n+\t\t\t\t\t\tp1 = -p1;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tp = -p;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (2.0 * p >= 1.5 * dx * p1 - Math.abs(tolerance * p1)\n+\t\t\t\t\t\t\t|| p >= Math.abs(0.5 * oldDelta * p1)) {\n+\t\t\t\t\t\tdelta = 0.5 * dx;\n+\t\t\t\t\t\toldDelta = delta;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\toldDelta = delta;\n+\t\t\t\t\t\tdelta = p / p1;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tx1 = x1 + 0.5 * tolerance;\n             } else if (dx <= 0.0) {\n                 x1 = x1 - 0.5 * tolerance;\n             }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "Replace", 
          "seed": "iterationCount+=this.iterationCount;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_347/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:18:29.673223304 -0500\n@@ -116,10 +116,7 @@\n             return result;\n         }\n \n-        // reduce interval if min and initial bracket the root\n-        if (yInitial * yMin < 0) {\n-            return solve(f, min, yMin, initial, yInitial, min, yMin);\n-        }\n+        iterationCount += this.iterationCount;\n \n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n@@ -128,10 +125,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_8/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:02:08.117106834 -0500\n@@ -128,10 +128,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "Replace", 
          "seed": "p=dx * r3;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 113, 
          "faulty": "double yMin=f.value(min);", 
          "type": "InsertBefore", 
          "seed": "this.resultComputed=true;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_832/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:41:38.896884460 -0500\n@@ -109,7 +109,8 @@\n             return result;\n         }\n \n-        // return the first endpoint if it is good enough\n+        this.resultComputed = true;\n+\t\t// return the first endpoint if it is good enough\n         double yMin = f.value(min);\n         if (Math.abs(yMin) <= functionValueAccuracy) {\n             setResult(yMin, 0);\n@@ -128,10 +129,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -284,7 +282,7 @@\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n+                    p = dx * r3;\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "Replace", 
          "seed": "p=dx * r3;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_352/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:18:42.617254405 -0500\n@@ -128,10 +128,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -284,7 +281,7 @@\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n+                    p = dx * r3;\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 250, 
          "faulty": "setResult(x1,i);", 
          "type": "InsertBefore", 
          "seed": "x0=x1;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 120, 
          "faulty": "if (yInitial * yMin < 0) {\n  return solve(f,min,yMin,initial,yInitial,min,yMin);\n}", 
          "type": "InsertBefore", 
          "seed": "iterationCount+=this.iterationCount;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "InsertBefore", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_992/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:49:27.302261340 -0500\n@@ -116,7 +116,8 @@\n             return result;\n         }\n \n-        // reduce interval if min and initial bracket the root\n+        iterationCount += this.iterationCount;\n+\t\t// reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n@@ -128,7 +129,8 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n+        verifyBracketing(min, max, f);\n+\t\t// reduce interval if initial and max bracket the root\n         if (yInitial * yMax < 0) {\n             return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n         }\n@@ -247,7 +249,8 @@\n             double tolerance =\n                 Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\n             if (Math.abs(dx) <= tolerance) {\n-                setResult(x1, i);\n+                x0 = x1;\n+\t\t\t\tsetResult(x1, i);\n                 return result;\n             }\n             if ((Math.abs(oldDelta) < tolerance) ||\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 126, 
          "faulty": "if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(yMax,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "this.iterationCount=iterationCount;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_62/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:05:00.658797233 -0500\n@@ -123,15 +123,7 @@\n \n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n-        if (Math.abs(yMax) <= functionValueAccuracy) {\n-            setResult(yMax, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 299, 
          "faulty": "if (dx > 0.0) {\n  x1=x1 + 0.5 * tolerance;\n}\n else if (dx <= 0.0) {\n  x1=x1 - 0.5 * tolerance;\n}", 
          "type": "InsertBefore", 
          "seed": "if (Math.abs(dx) <= tolerance) {\n  setResult(x1,i);\n  return result;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 114, 
          "faulty": "if (Math.abs(yMin) <= functionValueAccuracy) {\n  setResult(yMin,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_935/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:46:41.053769138 -0500\n@@ -111,11 +111,6 @@\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n-\n         // reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n             return solve(f, min, yMin, initial, yInitial, min, yMin);\n@@ -128,10 +123,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -296,11 +288,17 @@\n             // Compute new X1, Y1\n             if (Math.abs(delta) > tolerance) {\n                 x1 = x1 + delta;\n-            } else if (dx > 0.0) {\n-                x1 = x1 + 0.5 * tolerance;\n-            } else if (dx <= 0.0) {\n-                x1 = x1 - 0.5 * tolerance;\n-            }\n+            } else {\n+\t\t\t\tif (Math.abs(dx) <= tolerance) {\n+\t\t\t\t\tsetResult(x1, i);\n+\t\t\t\t\treturn result;\n+\t\t\t\t}\n+\t\t\t\tif (dx > 0.0) {\n+\t\t\t\t\tx1 = x1 + 0.5 * tolerance;\n+\t\t\t\t} else if (dx <= 0.0) {\n+\t\t\t\t\tx1 = x1 - 0.5 * tolerance;\n+\t\t\t\t}\n+\t\t\t}\n             y1 = f.value(x1);\n             if ((y1 > 0) == (y2 > 0)) {\n                 x2 = x0;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 184, 
          "faulty": "throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);", 
          "type": "Replace", 
          "seed": "if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(yMax,0);\n  return result;\n}"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 179, 
          "faulty": "if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(max,0);\n  ret=max;\n}\n else {\n  throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);\n}", 
          "type": "InsertBefore", 
          "seed": "this.iterationCount=0;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_256/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:14:02.944475891 -0500\n@@ -128,10 +128,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -176,14 +173,16 @@\n             if (Math.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n-            } else if (Math.abs(yMax) <= functionValueAccuracy) {\n-                setResult(max, 0);\n-                ret = max;\n             } else {\n-                // neither value is close to zero and min and max do not bracket root.\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                        NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n-            }\n+\t\t\t\tthis.iterationCount = 0;\n+\t\t\t\tif (Math.abs(yMax) <= functionValueAccuracy) {\n+\t\t\t\t\tsetResult(max, 0);\n+\t\t\t\t\tret = max;\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow MathRuntimeException.createIllegalArgumentException(\n+\t\t\t\t\t\t\tNON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n+\t\t\t\t}\n+\t\t\t}\n         } else if (sign < 0){\n             // solve using only the first endpoint as initial guess\n             ret = solve(f, min, yMin, max, yMax, min, yMin);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 102, 
          "faulty": "clearResult();", 
          "type": "Replace", 
          "seed": "setResult(max,0);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 126, 
          "faulty": "if (Math.abs(yMax) <= functionValueAccuracy) {\n  setResult(yMax,0);\n  return result;\n}", 
          "type": "Delete", 
          "seed": "this.iterationCount=iterationCount;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1331/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 07:05:57.681181002 -0500\n@@ -99,7 +99,7 @@\n                         final double min, final double max, final double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n \n-        clearResult();\n+        setResult(max, 0);\n         verifySequence(min, initial, max);\n \n         // return the initial guess if it is good enough\n@@ -123,15 +123,7 @@\n \n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n-        if (Math.abs(yMax) <= functionValueAccuracy) {\n-            setResult(yMax, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 102, 
          "faulty": "clearResult();", 
          "type": "Replace", 
          "seed": "setResult(max,0);"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 287, 
          "faulty": "oldDelta=delta;", 
          "type": "Delete", 
          "seed": "p=dx * r3;"
        }, 
        {
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java", 
          "line": 132, 
          "faulty": "if (yInitial * yMax < 0) {\n  return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n}", 
          "type": "Replace", 
          "seed": "verifyBracketing(min,max,f);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 06:00:09.289104123 -0500\n+++ /tmp/Arja_Defects4J_Math_73/patches_pxsy/Patch_1621/patched/tmp/Arja_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\t2018-12-01 07:20:50.967775538 -0500\n@@ -99,7 +99,7 @@\n                         final double min, final double max, final double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n \n-        clearResult();\n+        setResult(max, 0);\n         verifySequence(min, initial, max);\n \n         // return the initial guess if it is good enough\n@@ -128,10 +128,7 @@\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        verifyBracketing(min, max, f);\n \n \n         // full Brent algorithm starting with provided initial guess\n@@ -284,7 +281,6 @@\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n                     delta = 0.5 * dx;\n-                    oldDelta = delta;\n                 } else {\n                     oldDelta = delta;\n                     delta = p / p1;\n\n\n"
    }
  ]
}