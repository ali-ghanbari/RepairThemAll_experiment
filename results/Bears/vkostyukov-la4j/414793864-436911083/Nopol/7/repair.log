cd /tmp/Nopol_Bears_vkostyukov-la4j_414793864-436911083;
export JAVA_TOOL_OPTIONS=-Dfile.encoding=UTF8;
TZ="America/New_York"; export TZ;
export PATH="/usr/lib/jvm/java-1.8.0-openjdk-amd64/bin/:$PATH";
export JAVA_HOME="/usr/lib/jvm/java-1.8.0-openjdk-amd64/bin/";
time java -Xmx4048m -cp /home/tdurieux/defects4j4repair/script/../repair_tools/nopol.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/bin//../lib/tools.jar fr.inria.lille.repair.Main \
	--mode repair \
	--type pre_then_cond \
	--oracle angelic \
	--synthesis smt \
	--flocal gzoltar \
	--json \
	--solver z3 \
	--solver-path /home/tdurieux/defects4j4repair/script/../libs/z3/build/z3 \
	--complianceLevel 8 \
	--source src/main \
	--classpath "target/classes:target/test-classes:/home/tdurieux/.m2/repository/junit/junit/4.11/junit-4.11.jar:/home/tdurieux/.m2/repository/org/hamcrest/hamcrest-core/1.3/hamcrest-core-1.3.jar";
	echo "\n\nNode: `hostname`\n";
	echo "\n\nDate: `date`\n";
Picked up JAVA_TOOL_OPTIONS: -Dfile.encoding=UTF8
18:08:16.055 [main] INFO  fr.inria.lille.repair.nopol.NoPol - Source files: [src/main]
18:08:16.066 [main] INFO  fr.inria.lille.repair.nopol.NoPol - Classpath: [file:/tmp/Nopol_Bears_vkostyukov-la4j_414793864-436911083/target/classes/, file:/tmp/Nopol_Bears_vkostyukov-la4j_414793864-436911083/target/test-classes/, file:/home/tdurieux/.m2/repository/junit/junit/4.11/junit-4.11.jar, file:/home/tdurieux/.m2/repository/org/hamcrest/hamcrest-core/1.3/hamcrest-core-1.3.jar]
18:08:16.066 [main] INFO  fr.inria.lille.repair.nopol.NoPol - Statement type: PRE_THEN_COND
18:08:16.066 [main] INFO  fr.inria.lille.repair.nopol.NoPol - Args: [org.la4j.decomposition.CholeskyDecompositorTest, org.la4j.decomposition.EigenDecompositorTest, org.la4j.decomposition.LUDecompositorTest, org.la4j.decomposition.QRDecompositorTest, org.la4j.decomposition.SingularValueDecompositorTest, org.la4j.inversion.GaussJordanInverterTest, org.la4j.inversion.NoPivotGaussInverterTest, org.la4j.linear.ForwardBackSubstitutionSolverTest, org.la4j.linear.GaussianSolverTest, org.la4j.linear.JacobiSolverTest, org.la4j.linear.LeastSquaresSolverTest, org.la4j.linear.SeidelSolverTest, org.la4j.linear.SquareRootSolverTest, org.la4j.linear.SweepSolverTest, org.la4j.matrix.dense.Basic1DMatrixTest, org.la4j.matrix.dense.Basic2DMatrixTest, org.la4j.matrix.sparse.CCSMatrixTest, org.la4j.matrix.sparse.CRSMatrixTest, org.la4j.vector.dense.BasicVectorTest, org.la4j.vector.sparse.CompressedVectorTest]
18:08:16.069 [main] INFO  fr.inria.lille.repair.nopol.NoPol - Config: Config{synthesisDepth=3, collectStaticMethods=true, collectStaticFields=false, collectLiterals=false, onlyOneSynthesisResult=true, sortExpressions=true, maxLineInvocationPerTest=250, timeoutMethodInvocation=2000, dataCollectionTimeoutInSecondForSynthesis=900, addWeight=0.19478, subWeight=0.04554, mulWeight=0.0102, divWeight=0.00613, andWeight=0.10597, orWeight=0.05708, eqWeight=0.22798, nEqWeight=0.0, lessEqWeight=0.0255, lessWeight=0.0947, methodCallWeight=0.1, fieldAccessWeight=0.08099, constantWeight=0.14232, variableWeight=0.05195, mode=REPAIR, type=PRE_THEN_COND, synthesis=SMT, oracle=ANGELIC, solver=Z3, solverPath='/home/tdurieux/defects4j4repair/script/../libs/z3/build/z3', projectSources=[src/main], projectClasspath='[Ljava.net.URL;@66d33a', projectTests=[org.la4j.decomposition.CholeskyDecompositorTest, org.la4j.decomposition.EigenDecompositorTest, org.la4j.decomposition.LUDecompositorTest, org.la4j.decomposition.QRDecompositorTest, org.la4j.decomposition.SingularValueDecompositorTest, org.la4j.inversion.GaussJordanInverterTest, org.la4j.inversion.NoPivotGaussInverterTest, org.la4j.linear.ForwardBackSubstitutionSolverTest, org.la4j.linear.GaussianSolverTest, org.la4j.linear.JacobiSolverTest, org.la4j.linear.LeastSquaresSolverTest, org.la4j.linear.SeidelSolverTest, org.la4j.linear.SquareRootSolverTest, org.la4j.linear.SweepSolverTest, org.la4j.matrix.dense.Basic1DMatrixTest, org.la4j.matrix.dense.Basic2DMatrixTest, org.la4j.matrix.sparse.CCSMatrixTest, org.la4j.matrix.sparse.CRSMatrixTest, org.la4j.vector.dense.BasicVectorTest, org.la4j.vector.sparse.CompressedVectorTest], complianceLevel=8, outputFolder=., json=true}
18:08:16.069 [main] INFO  fr.inria.lille.repair.nopol.NoPol - Available processors (cores): 8
18:08:16.084 [main] INFO  fr.inria.lille.repair.nopol.NoPol - Free memory: 225 MB
18:08:16.084 [main] INFO  fr.inria.lille.repair.nopol.NoPol - Maximum memory: 3 GB
18:08:16.085 [main] INFO  fr.inria.lille.repair.nopol.NoPol - Total memory available to JVM: 241 MB
18:08:16.085 [main] INFO  fr.inria.lille.repair.nopol.NoPol - Java version: 1.8.0_181
18:08:16.086 [main] INFO  fr.inria.lille.repair.nopol.NoPol - JAVA_HOME: /usr/lib/jvm/java-1.8.0-openjdk-amd64/bin/
18:08:16.086 [main] INFO  fr.inria.lille.repair.nopol.NoPol - PATH: /usr/lib/jvm/java-1.8.0-openjdk-amd64/bin/:/usr/lib/oar/oardodo:/usr/lib/oar/oardodo:/usr/local/bin:/usr/bin:/bin:/usr/games
18:08:57.519 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - statement #1
18:08:57.520 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - Analysing SourceLocation org.la4j.Vector:857 which is executed by 2 tests
-1736520348
18:08:57.974 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - statement #2
18:08:57.975 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - Analysing SourceLocation org.la4j.Vector:847 which is executed by 2 tests
-1736520348
18:08:58.182 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - statement #3
18:08:58.183 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - Analysing SourceLocation org.la4j.Vector:845 which is executed by 2 tests
-1736520348
18:08:58.300 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - statement #4
18:08:58.300 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - Analysing SourceLocation org.la4j.Vector:844 which is executed by 2 tests
-1736520348
18:08:58.413 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - statement #5
18:08:58.414 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - Analysing SourceLocation org.la4j.Vector:843 which is executed by 2 tests
-1736520348
18:08:58.546 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - looking with class fr.inria.lille.repair.nopol.spoon.smt.ConditionalAdder
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
18:08:58.724 [pool-4-thread-1] INFO  xxl.java.junit.TestCasesListener - Tests run finished (116 ms)
<> Total tests run: 143
<> Ignored tests: 0
<> Failed tests: 2
~ testFromMap_unordered(org.la4j.vector.sparse.CompressedVectorTest)
[expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>]
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
~ testFromMap_unordered(org.la4j.vector.dense.BasicVectorTest)
[expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>]
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)

java.lang.AssertionError: expected: org.la4j.vector.dense.BasicVector<> but was: org.la4j.vector.sparse.CompressedVector<>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
18:09:00.139 [pool-5-thread-1] INFO  f.i.l.c.t.SpecificationTestCasesListener - Tests run finished (41 ms)
<> Total tests run: 1
<> Ignored tests: 0
<> Failed tests: 1
~ testFromMap_unordered(org.la4j.vector.sparse.CompressedVectorTest)
[expected: org.la4j.vector.dense.BasicVector<> but was: org.la4j.vector.sparse.CompressedVector<>]
java.lang.AssertionError: expected: org.la4j.vector.dense.BasicVector<> but was: org.la4j.vector.sparse.CompressedVector<>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)

java.lang.AssertionError: expected: org.la4j.vector.dense.BasicVector<> but was: org.la4j.vector.sparse.CompressedVector<>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
18:09:00.146 [pool-6-thread-1] INFO  f.i.l.c.t.SpecificationTestCasesListener - Tests run finished (2 ms)
<> Total tests run: 1
<> Ignored tests: 0
<> Failed tests: 1
~ testFromMap_unordered(org.la4j.vector.dense.BasicVectorTest)
[expected: org.la4j.vector.dense.BasicVector<> but was: org.la4j.vector.sparse.CompressedVector<>]
java.lang.AssertionError: expected: org.la4j.vector.dense.BasicVector<> but was: org.la4j.vector.sparse.CompressedVector<>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)

java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
18:09:00.151 [pool-7-thread-1] INFO  f.i.l.c.t.SpecificationTestCasesListener - Tests run finished (2 ms)
<> Total tests run: 1
<> Ignored tests: 0
<> Failed tests: 1
~ testFromMap_unordered(org.la4j.vector.sparse.CompressedVectorTest)
[expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>]
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)

java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
18:09:00.161 [pool-8-thread-1] INFO  f.i.l.c.t.SpecificationTestCasesListener - Tests run finished (3 ms)
<> Total tests run: 1
<> Ignored tests: 0
<> Failed tests: 1
~ testFromMap_unordered(org.la4j.vector.dense.BasicVectorTest)
[expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>]
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)

18:09:00.162 [pool-3-thread-1] DEBUG tests.output - Failing tests with false: 
[testFromMap_unordered(org.la4j.vector.sparse.CompressedVectorTest): expected: org.la4j.vector.dense.BasicVector<> but was: org.la4j.vector.sparse.CompressedVector<>, testFromMap_unordered(org.la4j.vector.dense.BasicVectorTest): expected: org.la4j.vector.dense.BasicVector<> but was: org.la4j.vector.sparse.CompressedVector<>]
18:09:00.163 [pool-3-thread-1] DEBUG tests.output - Failing tests with true: 
[testFromMap_unordered(org.la4j.vector.sparse.CompressedVectorTest): expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>, testFromMap_unordered(org.la4j.vector.dense.BasicVectorTest): expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>]
18:09:00.163 [pool-3-thread-1] INFO  f.i.l.r.n.synth.SMTNopolSynthesizer - Not enough specifications: 0. A trivial patch is "true" or "false", please write new tests specifying SourceLocation org.la4j.Vector:843.
18:09:00.163 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - statement #6
18:09:00.163 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - Analysing SourceLocation org.la4j.Vector:842 which is executed by 2 tests
-1736520348
18:09:00.276 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - statement #7
18:09:00.277 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - Analysing SourceLocation org.la4j.Vector:841 which is executed by 2 tests
-1736520348
18:09:00.386 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - statement #8
18:09:00.386 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - Analysing SourceLocation org.la4j.Vector:840 which is executed by 2 tests
-1736520348
18:09:00.495 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - looking with class fr.inria.lille.repair.nopol.spoon.smt.ConditionalAdder
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
18:09:00.600 [pool-10-thread-1] INFO  xxl.java.junit.TestCasesListener - Tests run finished (89 ms)
<> Total tests run: 143
<> Ignored tests: 0
<> Failed tests: 2
~ testFromMap_unordered(org.la4j.vector.sparse.CompressedVectorTest)
[expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>]
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
~ testFromMap_unordered(org.la4j.vector.dense.BasicVectorTest)
[expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>]
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)

java.lang.AssertionError: expected: org.la4j.vector.dense.BasicVector<> but was: org.la4j.vector.sparse.CompressedVector<>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
18:09:01.492 [pool-11-thread-1] INFO  f.i.l.c.t.SpecificationTestCasesListener - Tests run finished (32 ms)
<> Total tests run: 1
<> Ignored tests: 0
<> Failed tests: 1
~ testFromMap_unordered(org.la4j.vector.sparse.CompressedVectorTest)
[expected: org.la4j.vector.dense.BasicVector<> but was: org.la4j.vector.sparse.CompressedVector<>]
java.lang.AssertionError: expected: org.la4j.vector.dense.BasicVector<> but was: org.la4j.vector.sparse.CompressedVector<>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)

java.lang.AssertionError: expected: org.la4j.vector.dense.BasicVector<> but was: org.la4j.vector.sparse.CompressedVector<>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
18:09:01.498 [pool-12-thread-1] INFO  f.i.l.c.t.SpecificationTestCasesListener - Tests run finished (2 ms)
<> Total tests run: 1
<> Ignored tests: 0
<> Failed tests: 1
~ testFromMap_unordered(org.la4j.vector.dense.BasicVectorTest)
[expected: org.la4j.vector.dense.BasicVector<> but was: org.la4j.vector.sparse.CompressedVector<>]
java.lang.AssertionError: expected: org.la4j.vector.dense.BasicVector<> but was: org.la4j.vector.sparse.CompressedVector<>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)

java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
18:09:01.501 [pool-13-thread-1] INFO  f.i.l.c.t.SpecificationTestCasesListener - Tests run finished (1 ms)
<> Total tests run: 1
<> Ignored tests: 0
<> Failed tests: 1
~ testFromMap_unordered(org.la4j.vector.sparse.CompressedVectorTest)
[expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>]
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)

java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
18:09:01.508 [pool-14-thread-1] INFO  f.i.l.c.t.SpecificationTestCasesListener - Tests run finished (2 ms)
<> Total tests run: 1
<> Ignored tests: 0
<> Failed tests: 1
~ testFromMap_unordered(org.la4j.vector.dense.BasicVectorTest)
[expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>]
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)

18:09:01.509 [pool-9-thread-1] DEBUG tests.output - Failing tests with false: 
[testFromMap_unordered(org.la4j.vector.sparse.CompressedVectorTest): expected: org.la4j.vector.dense.BasicVector<> but was: org.la4j.vector.sparse.CompressedVector<>, testFromMap_unordered(org.la4j.vector.dense.BasicVectorTest): expected: org.la4j.vector.dense.BasicVector<> but was: org.la4j.vector.sparse.CompressedVector<>]
18:09:01.509 [pool-9-thread-1] DEBUG tests.output - Failing tests with true: 
[testFromMap_unordered(org.la4j.vector.sparse.CompressedVectorTest): expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>, testFromMap_unordered(org.la4j.vector.dense.BasicVectorTest): expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>]
18:09:01.509 [pool-9-thread-1] INFO  f.i.l.r.n.synth.SMTNopolSynthesizer - Not enough specifications: 0. A trivial patch is "true" or "false", please write new tests specifying SourceLocation org.la4j.Vector:840.
18:09:01.509 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - statement #9
18:09:01.510 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - Analysing SourceLocation org.la4j.Vector:838 which is executed by 2 tests
-1736520348
18:09:01.648 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - statement #10
18:09:01.649 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - Analysing SourceLocation org.la4j.Vector:837 which is executed by 2 tests
-1736520348
18:09:01.751 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - statement #11
18:09:01.751 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - Analysing SourceLocation org.la4j.vector.VectorTest:735 which is executed by 2 tests
18:09:01.759 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - cannot spoon SourceLocation org.la4j.vector.VectorTest:735
18:09:01.759 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - statement #12
18:09:01.759 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - Analysing SourceLocation org.la4j.vector.VectorTest:734 which is executed by 2 tests
18:09:01.760 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - cannot spoon SourceLocation org.la4j.vector.VectorTest:734
18:09:01.760 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - statement #13
18:09:01.760 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - Analysing SourceLocation org.la4j.vector.VectorTest:733 which is executed by 2 tests
18:09:01.760 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - cannot spoon SourceLocation org.la4j.vector.VectorTest:733
18:09:01.760 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - statement #14
18:09:01.760 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - Analysing SourceLocation org.la4j.vector.VectorTest:732 which is executed by 2 tests
18:09:01.760 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - cannot spoon SourceLocation org.la4j.vector.VectorTest:732
18:09:01.760 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - statement #15
18:09:01.760 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - Analysing SourceLocation org.la4j.vector.VectorTest:731 which is executed by 2 tests
18:09:01.760 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - cannot spoon SourceLocation org.la4j.vector.VectorTest:731
18:09:01.761 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - statement #16
18:09:01.761 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - Analysing SourceLocation org.la4j.vector.VectorTest:730 which is executed by 2 tests
18:09:01.761 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - cannot spoon SourceLocation org.la4j.vector.VectorTest:730
18:09:01.761 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - statement #17
18:09:01.761 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - Analysing SourceLocation org.la4j.vector.sparse.CompressedVector$2:585 which is executed by 4 tests
1164465221
18:09:01.881 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - statement #18
18:09:01.881 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - Analysing SourceLocation org.la4j.vector.sparse.CompressedVector:54 which is executed by 255 tests
1164465221
18:09:01.983 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - statement #19
18:09:01.984 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - Analysing SourceLocation org.la4j.vector.sparse.CompressedVector:578 which is executed by 5 tests
1164465221
18:09:02.495 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - statement #20
18:09:02.496 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - Analysing SourceLocation org.la4j.vector.sparse.CompressedVector$2:578 which is executed by 5 tests
1164465221
18:09:03.065 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - statement #21
18:09:03.065 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - Analysing SourceLocation org.la4j.vector.sparse.CompressedVector$2:625 which is executed by 5 tests
1164465221
18:09:03.170 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - statement #22
18:09:03.170 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - Analysing SourceLocation org.la4j.vector.sparse.CompressedVector$2:623 which is executed by 5 tests
1164465221
18:09:03.368 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - looking with class fr.inria.lille.repair.nopol.spoon.smt.ConditionalAdder
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
18:09:03.465 [pool-16-thread-1] INFO  xxl.java.junit.TestCasesListener - Tests run finished (82 ms)
<> Total tests run: 143
<> Ignored tests: 0
<> Failed tests: 2
~ testFromMap_unordered(org.la4j.vector.sparse.CompressedVectorTest)
[expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>]
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
~ testFromMap_unordered(org.la4j.vector.dense.BasicVectorTest)
[expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>]
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)

18:09:04.406 [pool-15-thread-1] ERROR x.java.compiler.DynamicClassCompiler - [Compilation errors]
CompressedVector.java:444: error: ')' expected
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(2).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.k",org.la4j.vector.sparse.CompressedVector.2.this.k);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                      ^
CompressedVector.java:444: error: illegal start of expression
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(2).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.k",org.la4j.vector.sparse.CompressedVector.2.this.k);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                        ^
CompressedVector.java:444: error: ';' expected
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(2).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.k",org.la4j.vector.sparse.CompressedVector.2.this.k);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                         ^
CompressedVector.java:444: error: illegal start of expression
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(2).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.k",org.la4j.vector.sparse.CompressedVector.2.this.k);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                             ^
CompressedVector.java:444: error: ';' expected
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(2).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.k",org.la4j.vector.sparse.CompressedVector.2.this.k);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                               ^
CompressedVector.java:445: error: ')' expected
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(2).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero",org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                                   ^
CompressedVector.java:445: error: illegal start of expression
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(2).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero",org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                                     ^
CompressedVector.java:445: error: ';' expected
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(2).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero",org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                                      ^
CompressedVector.java:445: error: illegal start of expression
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(2).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero",org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                                          ^
CompressedVector.java:445: error: ';' expected
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(2).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero",org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                                                         ^
CompressedVector.java:446: error: ')' expected
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(2).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.i",org.la4j.vector.sparse.CompressedVector.2.this.i);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                      ^
CompressedVector.java:446: error: illegal start of expression
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(2).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.i",org.la4j.vector.sparse.CompressedVector.2.this.i);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                        ^
CompressedVector.java:446: error: ';' expected
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(2).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.i",org.la4j.vector.sparse.CompressedVector.2.this.i);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                         ^
CompressedVector.java:446: error: illegal start of expression
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(2).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.i",org.la4j.vector.sparse.CompressedVector.2.this.i);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                             ^
CompressedVector.java:446: error: ';' expected
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(2).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.i",org.la4j.vector.sparse.CompressedVector.2.this.i);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                               ^
18:09:04.954 [pool-15-thread-1] ERROR f.i.l.r.n.s.ConstraintModelBuilder - Unable to compile the change: 
public class CompressedVector extends org.la4j.vector.SparseVector {
    private static final byte VECTOR_TAG = ((byte) (16));

    private static final int MINIMUM_SIZE = 32;

    private double[] values;

    private int[] indices;

    public CompressedVector() {
        this(0);
    }

    public CompressedVector(int length) {
        this(length, 0);
    }

    public CompressedVector(int length, int capacity) {
        super(length);
        int alignedSize = align(length, capacity);
        this.values = new double[alignedSize];
        this.indices = new int[alignedSize];
    }

    public CompressedVector(int length, int cardinality, double[] values, int[] indices) {
        super(length, cardinality);
        this.values = values;
        this.indices = indices;
    }

    public static org.la4j.vector.sparse.CompressedVector zero(int length) {
        return new org.la4j.vector.sparse.CompressedVector(length);
    }

    public static org.la4j.vector.sparse.CompressedVector zero(int length, int capacity) {
        return new org.la4j.vector.sparse.CompressedVector(length, capacity);
    }

    public static org.la4j.vector.sparse.CompressedVector random(int length, double density, java.util.Random random) {
        if ((density < 0.0) || (density > 1.0)) {
            throw new java.lang.IllegalArgumentException("The density value should be between 0 and 1.0");
        }
        int cardinality = ((int) (length * density));
        double[] values = new double[cardinality];
        int[] indices = new int[cardinality];
        for (int i = 0; i < cardinality; i++) {
            values[i] = random.nextDouble();
            indices[i] = random.nextInt(length);
        }
        java.util.Arrays.sort(indices);
        return new org.la4j.vector.sparse.CompressedVector(length, cardinality, values, indices);
    }

    public static org.la4j.vector.sparse.CompressedVector fromArray(double[] array) {
        int length = array.length;
        org.la4j.vector.sparse.CompressedVector result = org.la4j.vector.sparse.CompressedVector.zero(length);
        for (int i = 0; i < length; i++) {
            if ((array[i]) != 0.0) {
                result.set(i, array[i]);
            }
        }
        return result;
    }

    public static org.la4j.vector.sparse.CompressedVector fromBinary(byte[] array) {
        java.nio.ByteBuffer buffer = java.nio.ByteBuffer.wrap(array);
        if ((buffer.get()) != (org.la4j.vector.sparse.CompressedVector.VECTOR_TAG)) {
            throw new java.lang.IllegalArgumentException("Can not decode CompressedVector from the given byte array.");
        }
        int length = buffer.getInt();
        int cardinality = buffer.getInt();
        double[] values = new double[cardinality];
        int[] indices = new int[cardinality];
        for (int i = 0; i < cardinality; i++) {
            indices[i] = buffer.getInt();
            values[i] = buffer.getDouble();
        }
        return new org.la4j.vector.sparse.CompressedVector(length, cardinality, values, indices);
    }

    public static org.la4j.vector.sparse.CompressedVector fromCSV(java.lang.String csv) {
        return org.la4j.Vector.fromCSV(csv).to(org.la4j.Vectors.COMPRESSED);
    }

    public static org.la4j.vector.sparse.CompressedVector fromMatrixMarket(java.lang.String mm) {
        return org.la4j.Vector.fromMatrixMarket(mm).to(org.la4j.Vectors.COMPRESSED);
    }

    public static org.la4j.vector.sparse.CompressedVector fromCollection(java.util.Collection<? extends java.lang.Number> list) {
        return org.la4j.Vector.fromCollection(list).to(org.la4j.Vectors.COMPRESSED);
    }

    public static org.la4j.vector.sparse.CompressedVector fromMap(java.util.Map<java.lang.Integer, ? extends java.lang.Number> map, int length) {
        int cardinality = map.size();
        int[] indices = new int[cardinality];
        double[] values = new double[cardinality];
        int i = 0;
        for (java.util.Map.Entry<java.lang.Integer, ? extends java.lang.Number> entry : map.entrySet()) {
            int index = entry.getKey();
            if ((index < 0) || (index >= length)) {
                throw new java.lang.IllegalArgumentException("Check your map: Index must be 0..n-1");
            }
            indices[i] = index;
            values[i] = entry.getValue().doubleValue();
            i++;
        }
        return new org.la4j.vector.sparse.CompressedVector(length, cardinality, values, indices);
    }

    @java.lang.Override
    public double getOrElse(int i, double defaultValue) {
        ensureIndexIsInBounds(i);
        int k = searchForIndex(i);
        if ((k < (cardinality)) && ((indices[k]) == i)) {
            return values[k];
        }
        return defaultValue;
    }

    @java.lang.Override
    public void set(int i, double value) {
        ensureIndexIsInBounds(i);
        int k = searchForIndex(i);
        if ((k < (cardinality)) && ((indices[k]) == i)) {
            if (value != 0.0) {
                values[k] = value;
            }else {
                remove(k);
            }
        }else {
            insert(k, i, value);
        }
    }

    @java.lang.Override
    public void setAll(double value) {
        if (value == 0.0) {
            cardinality = 0;
        }else {
            if ((values.length) < (length)) {
                values = new double[length];
                indices = new int[length];
            }
            for (int i = 0; i < (length); i++) {
                indices[i] = i;
                values[i] = value;
            }
            cardinality = length;
        }
    }

    @java.lang.Override
    public void swapElements(int i, int j) {
        if (i == j) {
            return;
        }
        int ii = searchForIndex(i);
        int jj = searchForIndex(j);
        boolean iiNotZero = (ii < (cardinality)) && (i == (indices[ii]));
        boolean jjNotZero = (jj < (cardinality)) && (j == (indices[jj]));
        if (iiNotZero && jjNotZero) {
            double sd = values[ii];
            values[ii] = values[jj];
            values[jj] = sd;
        }else {
            double notZero = values[(iiNotZero ? ii : jj)];
            int leftIndex = (ii < jj) ? ii : jj;
            int rightIndex = (ii > jj) ? ii : jj;
            if (((iiNotZero && (leftIndex == ii)) || (jjNotZero && (leftIndex == jj))) && (ii != jj)) {
                java.lang.System.arraycopy(values, (leftIndex + 1), values, leftIndex, ((cardinality) - leftIndex));
                java.lang.System.arraycopy(values, (rightIndex - 1), values, rightIndex, ((cardinality) - rightIndex));
                values[(rightIndex - 1)] = notZero;
                java.lang.System.arraycopy(indices, (leftIndex + 1), indices, leftIndex, ((cardinality) - leftIndex));
                java.lang.System.arraycopy(indices, (rightIndex - 1), indices, rightIndex, ((cardinality) - rightIndex));
                indices[(rightIndex - 1)] = (jjNotZero) ? i : j;
            }else
                if ((iiNotZero && (rightIndex == ii)) || (jjNotZero && (rightIndex == jj))) {
                    java.lang.System.arraycopy(values, (rightIndex + 1), values, rightIndex, ((cardinality) - rightIndex));
                    java.lang.System.arraycopy(values, leftIndex, values, (leftIndex + 1), ((cardinality) - leftIndex));
                    values[leftIndex] = notZero;
                    java.lang.System.arraycopy(indices, (rightIndex + 1), indices, rightIndex, ((cardinality) - rightIndex));
                    java.lang.System.arraycopy(indices, leftIndex, indices, (leftIndex + 1), ((cardinality) - leftIndex));
                    indices[leftIndex] = (jjNotZero) ? i : j;
                }

        }
    }

    @java.lang.Override
    public org.la4j.Vector copyOfLength(int length) {
        ensureLengthIsCorrect(length);
        int $cardinality = (length >= (this.length)) ? cardinality : searchForIndex(length);
        int capacity = align(length, $cardinality);
        double[] $values = new double[capacity];
        int[] $indices = new int[capacity];
        java.lang.System.arraycopy(values, 0, $values, 0, $cardinality);
        java.lang.System.arraycopy(indices, 0, $indices, 0, $cardinality);
        return new org.la4j.vector.sparse.CompressedVector(length, $cardinality, $values, $indices);
    }

    @java.lang.Override
    public void each(org.la4j.vector.functor.VectorProcedure procedure) {
        int k = 0;
        for (int i = 0; i < (length); i++) {
            if ((k < (cardinality)) && ((indices[k]) == i)) {
                procedure.apply(i, values[(k++)]);
            }else {
                procedure.apply(i, 0.0);
            }
        }
    }

    @java.lang.Override
    public void eachNonZero(org.la4j.vector.functor.VectorProcedure procedure) {
        for (int i = 0; i < (cardinality); i++) {
            procedure.apply(indices[i], values[i]);
        }
    }

    @java.lang.Override
    public void updateAt(int i, org.la4j.vector.functor.VectorFunction function) {
        int k = searchForIndex(i);
        if ((k < (cardinality)) && ((indices[k]) == i)) {
            double value = function.evaluate(i, values[k]);
            if (value != 0.0) {
                values[k] = value;
            }else {
                remove(k);
            }
        }else {
            insert(k, i, function.evaluate(i, 0.0));
        }
    }

    @java.lang.Override
    public boolean nonZeroAt(int i) {
        int k = searchForIndex(i);
        return (k < (cardinality)) && ((indices[k]) == i);
    }

    @java.lang.Override
    public <T extends org.la4j.Vector> T to(org.la4j.vector.VectorFactory<T> factory) {
        if ((factory.outputClass) == (org.la4j.vector.sparse.CompressedVector.class)) {
            return factory.outputClass.cast(this);
        }
        return super.to(factory);
    }

    @java.lang.Override
    public org.la4j.Vector blankOfLength(int length) {
        return org.la4j.vector.sparse.CompressedVector.zero(length);
    }

    @java.lang.Override
    public byte[] toBinary() {
        int size = (((1 + 4) + 4) + (8 * (cardinality))) + (8 * (cardinality));
        java.nio.ByteBuffer buffer = java.nio.ByteBuffer.allocate(size);
        buffer.put(org.la4j.vector.sparse.CompressedVector.VECTOR_TAG);
        buffer.putInt(length);
        buffer.putInt(cardinality);
        for (int i = 0; i < (cardinality); i++) {
            buffer.putInt(indices[i]);
            buffer.putDouble(values[i]);
        }
        return buffer.array();
    }

    private int searchForIndex(int i) {
        if (((cardinality) == 0) || (i > (indices[((cardinality) - 1)]))) {
            return cardinality;
        }
        int left = 0;
        int right = cardinality;
        while (left < right) {
            int p = (left + right) / 2;
            if ((indices[p]) > i) {
                right = p;
            }else
                if ((indices[p]) < i) {
                    left = p + 1;
                }else {
                    return p;
                }

        } 
        return left;
    }

    private void insert(int k, int i, double value) {
        if (value == 0.0) {
            return;
        }
        if ((values.length) < ((cardinality) + 1)) {
            growUp();
        }
        if (((cardinality) - k) > 0) {
            java.lang.System.arraycopy(values, k, values, (k + 1), ((cardinality) - k));
            java.lang.System.arraycopy(indices, k, indices, (k + 1), ((cardinality) - k));
        }
        values[k] = value;
        indices[k] = i;
        (cardinality)++;
    }

    private void remove(int k) {
        (cardinality)--;
        if (((cardinality) - k) > 0) {
            java.lang.System.arraycopy(values, (k + 1), values, k, ((cardinality) - k));
            java.lang.System.arraycopy(indices, (k + 1), indices, k, ((cardinality) - k));
        }
    }

    private void growUp() {
        if ((values.length) == (length)) {
            throw new java.lang.IllegalStateException("This vector can't grow up.");
        }
        int capacity = java.lang.Math.min(length, ((((cardinality) * 3) / 2) + 1));
        double[] $values = new double[capacity];
        int[] $indices = new int[capacity];
        java.lang.System.arraycopy(values, 0, $values, 0, cardinality);
        java.lang.System.arraycopy(indices, 0, $indices, 0, cardinality);
        values = $values;
        indices = $indices;
    }

    private int align(int length, int capacity) {
        if (capacity < 0) {
            fail((("Cardinality should be positive: " + capacity) + "."));
        }
        if (capacity > length) {
            fail((("Cardinality should be less then or equal to capacity: " + capacity) + "."));
        }
        return java.lang.Math.min(length, (((capacity / (org.la4j.vector.sparse.CompressedVector.MINIMUM_SIZE)) + 1) * (org.la4j.vector.sparse.CompressedVector.MINIMUM_SIZE)));
    }

    @java.lang.Override
    public org.la4j.iterator.VectorIterator nonZeroIterator() {
        return new org.la4j.iterator.VectorIterator(length) {
            private boolean currentIsRemoved = false;

            private int k = -1;

            private int removedIndex = -1;

            @java.lang.Override
            public int index() {
                return currentIsRemoved ? removedIndex : indices[k];
            }

            @java.lang.Override
            public double get() {
                return currentIsRemoved ? 0.0 : values[k];
            }

            @java.lang.Override
            public void set(double value) {
                if ((value == 0.0) && (!(currentIsRemoved))) {
                    currentIsRemoved = true;
                    removedIndex = indices[k];
                    org.la4j.vector.sparse.CompressedVector.this.remove(((k)--));
                }else
                    if ((value != 0.0) && (!(currentIsRemoved))) {
                        values[k] = value;
                    }else {
                        currentIsRemoved = false;
                        org.la4j.vector.sparse.CompressedVector.this.insert((++(k)), removedIndex, value);
                    }

            }

            @java.lang.Override
            public boolean hasNext() {
                return ((k) + 1) < (cardinality);
            }

            @java.lang.Override
            public java.lang.Double next() {
                if (!(hasNext())) {
                    throw new java.util.NoSuchElementException();
                }
                currentIsRemoved = false;
                return values[(++(k))];
            }
        };
    }

    @java.lang.Override
    public org.la4j.iterator.VectorIterator iterator() {
        return new org.la4j.iterator.VectorIterator(length) {
            private int k = 0;

            private int i = -1;

            private boolean currentNonZero = false;

            @java.lang.Override
            public int index() {
                return i;
            }

            @java.lang.Override
            public double get() {
                return currentNonZero ? values[k] : 0.0;
            }

            @java.lang.Override
            public void set(double value) {
                if (currentNonZero) {
                    if (value == 0.0) {
                        org.la4j.vector.sparse.CompressedVector.this.remove(k);
                        currentNonZero = false;
                    }else {
                        values[k] = value;
                    }
                }else {
                    org.la4j.vector.sparse.CompressedVector.this.insert(k, i, value);
                    currentNonZero = true;
                }
            }

            @java.lang.Override
            public boolean hasNext() {
                return ((i) + 1) < (length);
            }

            @java.lang.Override
            public java.lang.Double next() {
                if (!(hasNext())) {
                    throw new java.util.NoSuchElementException();
                }
                if (currentNonZero) {
                    (k)++;
                }
                (i)++;
                boolean spoonDefaultValue = false;
                try {
                    spoonDefaultValue = true;
                } catch (java.lang.Exception __NopolProcessorException) {
                }
                boolean runtimeAngelicValue = fr.inria.lille.repair.nopol.synth.AngelicExecution.angelicValue(spoonDefaultValue);
                if (fr.inria.lille.commons.trace.RuntimeValues.instance(2).isEnabled()) {
                    fr.inria.lille.commons.trace.RuntimeValues.instance(2).collectionStarts();
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(2).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.k",org.la4j.vector.sparse.CompressedVector.2.this.k);} catch (Exception ex1) {ex1.printStackTrace();};
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(2).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero",org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero);} catch (Exception ex1) {ex1.printStackTrace();};
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(2).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.i",org.la4j.vector.sparse.CompressedVector.2.this.i);} catch (Exception ex1) {ex1.printStackTrace();};
                    fr.inria.lille.commons.trace.RuntimeValues.instance(2).collectOutput(runtimeAngelicValue);
                    fr.inria.lille.commons.trace.RuntimeValues.instance(2).collectionEnds();
                }
                if (runtimeAngelicValue)
                    currentNonZero = ((k) < (cardinality)) && ((indices[k]) == (i));

                return get();
            }
        };
    }
}
18:09:04.956 [pool-2-thread-1] ERROR fr.inria.lille.repair.nopol.NoPol - Error ExecutionException java.util.concurrent.ExecutionException: xxl.java.compiler.DynamicCompilationException: Aborting: dynamic compilation failed
18:09:04.956 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - statement #23
18:09:04.956 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - Analysing SourceLocation org.la4j.vector.sparse.CompressedVector$2:622 which is executed by 5 tests
1164465221
18:09:05.068 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - looking with class fr.inria.lille.repair.nopol.spoon.smt.ConditionalAdder
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
18:09:05.164 [pool-18-thread-1] INFO  xxl.java.junit.TestCasesListener - Tests run finished (83 ms)
<> Total tests run: 143
<> Ignored tests: 0
<> Failed tests: 2
~ testFromMap_unordered(org.la4j.vector.sparse.CompressedVectorTest)
[expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>]
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
~ testFromMap_unordered(org.la4j.vector.dense.BasicVectorTest)
[expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>]
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)

18:09:06.186 [pool-17-thread-1] ERROR x.java.compiler.DynamicClassCompiler - [Compilation errors]
CompressedVector.java:443: error: ')' expected
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(3).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.k",org.la4j.vector.sparse.CompressedVector.2.this.k);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                      ^
CompressedVector.java:443: error: illegal start of expression
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(3).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.k",org.la4j.vector.sparse.CompressedVector.2.this.k);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                        ^
CompressedVector.java:443: error: ';' expected
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(3).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.k",org.la4j.vector.sparse.CompressedVector.2.this.k);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                         ^
CompressedVector.java:443: error: illegal start of expression
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(3).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.k",org.la4j.vector.sparse.CompressedVector.2.this.k);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                             ^
CompressedVector.java:443: error: ';' expected
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(3).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.k",org.la4j.vector.sparse.CompressedVector.2.this.k);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                               ^
CompressedVector.java:444: error: ')' expected
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(3).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero",org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                                   ^
CompressedVector.java:444: error: illegal start of expression
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(3).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero",org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                                     ^
CompressedVector.java:444: error: ';' expected
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(3).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero",org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                                      ^
CompressedVector.java:444: error: illegal start of expression
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(3).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero",org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                                          ^
CompressedVector.java:444: error: ';' expected
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(3).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero",org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                                                         ^
CompressedVector.java:445: error: ')' expected
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(3).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.i",org.la4j.vector.sparse.CompressedVector.2.this.i);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                      ^
CompressedVector.java:445: error: illegal start of expression
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(3).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.i",org.la4j.vector.sparse.CompressedVector.2.this.i);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                        ^
CompressedVector.java:445: error: ';' expected
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(3).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.i",org.la4j.vector.sparse.CompressedVector.2.this.i);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                         ^
CompressedVector.java:445: error: illegal start of expression
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(3).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.i",org.la4j.vector.sparse.CompressedVector.2.this.i);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                             ^
CompressedVector.java:445: error: ';' expected
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(3).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.i",org.la4j.vector.sparse.CompressedVector.2.this.i);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                               ^
18:09:06.703 [pool-17-thread-1] ERROR f.i.l.r.n.s.ConstraintModelBuilder - Unable to compile the change: 
public class CompressedVector extends org.la4j.vector.SparseVector {
    private static final byte VECTOR_TAG = ((byte) (16));

    private static final int MINIMUM_SIZE = 32;

    private double[] values;

    private int[] indices;

    public CompressedVector() {
        this(0);
    }

    public CompressedVector(int length) {
        this(length, 0);
    }

    public CompressedVector(int length, int capacity) {
        super(length);
        int alignedSize = align(length, capacity);
        this.values = new double[alignedSize];
        this.indices = new int[alignedSize];
    }

    public CompressedVector(int length, int cardinality, double[] values, int[] indices) {
        super(length, cardinality);
        this.values = values;
        this.indices = indices;
    }

    public static org.la4j.vector.sparse.CompressedVector zero(int length) {
        return new org.la4j.vector.sparse.CompressedVector(length);
    }

    public static org.la4j.vector.sparse.CompressedVector zero(int length, int capacity) {
        return new org.la4j.vector.sparse.CompressedVector(length, capacity);
    }

    public static org.la4j.vector.sparse.CompressedVector random(int length, double density, java.util.Random random) {
        if ((density < 0.0) || (density > 1.0)) {
            throw new java.lang.IllegalArgumentException("The density value should be between 0 and 1.0");
        }
        int cardinality = ((int) (length * density));
        double[] values = new double[cardinality];
        int[] indices = new int[cardinality];
        for (int i = 0; i < cardinality; i++) {
            values[i] = random.nextDouble();
            indices[i] = random.nextInt(length);
        }
        java.util.Arrays.sort(indices);
        return new org.la4j.vector.sparse.CompressedVector(length, cardinality, values, indices);
    }

    public static org.la4j.vector.sparse.CompressedVector fromArray(double[] array) {
        int length = array.length;
        org.la4j.vector.sparse.CompressedVector result = org.la4j.vector.sparse.CompressedVector.zero(length);
        for (int i = 0; i < length; i++) {
            if ((array[i]) != 0.0) {
                result.set(i, array[i]);
            }
        }
        return result;
    }

    public static org.la4j.vector.sparse.CompressedVector fromBinary(byte[] array) {
        java.nio.ByteBuffer buffer = java.nio.ByteBuffer.wrap(array);
        if ((buffer.get()) != (org.la4j.vector.sparse.CompressedVector.VECTOR_TAG)) {
            throw new java.lang.IllegalArgumentException("Can not decode CompressedVector from the given byte array.");
        }
        int length = buffer.getInt();
        int cardinality = buffer.getInt();
        double[] values = new double[cardinality];
        int[] indices = new int[cardinality];
        for (int i = 0; i < cardinality; i++) {
            indices[i] = buffer.getInt();
            values[i] = buffer.getDouble();
        }
        return new org.la4j.vector.sparse.CompressedVector(length, cardinality, values, indices);
    }

    public static org.la4j.vector.sparse.CompressedVector fromCSV(java.lang.String csv) {
        return org.la4j.Vector.fromCSV(csv).to(org.la4j.Vectors.COMPRESSED);
    }

    public static org.la4j.vector.sparse.CompressedVector fromMatrixMarket(java.lang.String mm) {
        return org.la4j.Vector.fromMatrixMarket(mm).to(org.la4j.Vectors.COMPRESSED);
    }

    public static org.la4j.vector.sparse.CompressedVector fromCollection(java.util.Collection<? extends java.lang.Number> list) {
        return org.la4j.Vector.fromCollection(list).to(org.la4j.Vectors.COMPRESSED);
    }

    public static org.la4j.vector.sparse.CompressedVector fromMap(java.util.Map<java.lang.Integer, ? extends java.lang.Number> map, int length) {
        int cardinality = map.size();
        int[] indices = new int[cardinality];
        double[] values = new double[cardinality];
        int i = 0;
        for (java.util.Map.Entry<java.lang.Integer, ? extends java.lang.Number> entry : map.entrySet()) {
            int index = entry.getKey();
            if ((index < 0) || (index >= length)) {
                throw new java.lang.IllegalArgumentException("Check your map: Index must be 0..n-1");
            }
            indices[i] = index;
            values[i] = entry.getValue().doubleValue();
            i++;
        }
        return new org.la4j.vector.sparse.CompressedVector(length, cardinality, values, indices);
    }

    @java.lang.Override
    public double getOrElse(int i, double defaultValue) {
        ensureIndexIsInBounds(i);
        int k = searchForIndex(i);
        if ((k < (cardinality)) && ((indices[k]) == i)) {
            return values[k];
        }
        return defaultValue;
    }

    @java.lang.Override
    public void set(int i, double value) {
        ensureIndexIsInBounds(i);
        int k = searchForIndex(i);
        if ((k < (cardinality)) && ((indices[k]) == i)) {
            if (value != 0.0) {
                values[k] = value;
            }else {
                remove(k);
            }
        }else {
            insert(k, i, value);
        }
    }

    @java.lang.Override
    public void setAll(double value) {
        if (value == 0.0) {
            cardinality = 0;
        }else {
            if ((values.length) < (length)) {
                values = new double[length];
                indices = new int[length];
            }
            for (int i = 0; i < (length); i++) {
                indices[i] = i;
                values[i] = value;
            }
            cardinality = length;
        }
    }

    @java.lang.Override
    public void swapElements(int i, int j) {
        if (i == j) {
            return;
        }
        int ii = searchForIndex(i);
        int jj = searchForIndex(j);
        boolean iiNotZero = (ii < (cardinality)) && (i == (indices[ii]));
        boolean jjNotZero = (jj < (cardinality)) && (j == (indices[jj]));
        if (iiNotZero && jjNotZero) {
            double sd = values[ii];
            values[ii] = values[jj];
            values[jj] = sd;
        }else {
            double notZero = values[(iiNotZero ? ii : jj)];
            int leftIndex = (ii < jj) ? ii : jj;
            int rightIndex = (ii > jj) ? ii : jj;
            if (((iiNotZero && (leftIndex == ii)) || (jjNotZero && (leftIndex == jj))) && (ii != jj)) {
                java.lang.System.arraycopy(values, (leftIndex + 1), values, leftIndex, ((cardinality) - leftIndex));
                java.lang.System.arraycopy(values, (rightIndex - 1), values, rightIndex, ((cardinality) - rightIndex));
                values[(rightIndex - 1)] = notZero;
                java.lang.System.arraycopy(indices, (leftIndex + 1), indices, leftIndex, ((cardinality) - leftIndex));
                java.lang.System.arraycopy(indices, (rightIndex - 1), indices, rightIndex, ((cardinality) - rightIndex));
                indices[(rightIndex - 1)] = (jjNotZero) ? i : j;
            }else
                if ((iiNotZero && (rightIndex == ii)) || (jjNotZero && (rightIndex == jj))) {
                    java.lang.System.arraycopy(values, (rightIndex + 1), values, rightIndex, ((cardinality) - rightIndex));
                    java.lang.System.arraycopy(values, leftIndex, values, (leftIndex + 1), ((cardinality) - leftIndex));
                    values[leftIndex] = notZero;
                    java.lang.System.arraycopy(indices, (rightIndex + 1), indices, rightIndex, ((cardinality) - rightIndex));
                    java.lang.System.arraycopy(indices, leftIndex, indices, (leftIndex + 1), ((cardinality) - leftIndex));
                    indices[leftIndex] = (jjNotZero) ? i : j;
                }

        }
    }

    @java.lang.Override
    public org.la4j.Vector copyOfLength(int length) {
        ensureLengthIsCorrect(length);
        int $cardinality = (length >= (this.length)) ? cardinality : searchForIndex(length);
        int capacity = align(length, $cardinality);
        double[] $values = new double[capacity];
        int[] $indices = new int[capacity];
        java.lang.System.arraycopy(values, 0, $values, 0, $cardinality);
        java.lang.System.arraycopy(indices, 0, $indices, 0, $cardinality);
        return new org.la4j.vector.sparse.CompressedVector(length, $cardinality, $values, $indices);
    }

    @java.lang.Override
    public void each(org.la4j.vector.functor.VectorProcedure procedure) {
        int k = 0;
        for (int i = 0; i < (length); i++) {
            if ((k < (cardinality)) && ((indices[k]) == i)) {
                procedure.apply(i, values[(k++)]);
            }else {
                procedure.apply(i, 0.0);
            }
        }
    }

    @java.lang.Override
    public void eachNonZero(org.la4j.vector.functor.VectorProcedure procedure) {
        for (int i = 0; i < (cardinality); i++) {
            procedure.apply(indices[i], values[i]);
        }
    }

    @java.lang.Override
    public void updateAt(int i, org.la4j.vector.functor.VectorFunction function) {
        int k = searchForIndex(i);
        if ((k < (cardinality)) && ((indices[k]) == i)) {
            double value = function.evaluate(i, values[k]);
            if (value != 0.0) {
                values[k] = value;
            }else {
                remove(k);
            }
        }else {
            insert(k, i, function.evaluate(i, 0.0));
        }
    }

    @java.lang.Override
    public boolean nonZeroAt(int i) {
        int k = searchForIndex(i);
        return (k < (cardinality)) && ((indices[k]) == i);
    }

    @java.lang.Override
    public <T extends org.la4j.Vector> T to(org.la4j.vector.VectorFactory<T> factory) {
        if ((factory.outputClass) == (org.la4j.vector.sparse.CompressedVector.class)) {
            return factory.outputClass.cast(this);
        }
        return super.to(factory);
    }

    @java.lang.Override
    public org.la4j.Vector blankOfLength(int length) {
        return org.la4j.vector.sparse.CompressedVector.zero(length);
    }

    @java.lang.Override
    public byte[] toBinary() {
        int size = (((1 + 4) + 4) + (8 * (cardinality))) + (8 * (cardinality));
        java.nio.ByteBuffer buffer = java.nio.ByteBuffer.allocate(size);
        buffer.put(org.la4j.vector.sparse.CompressedVector.VECTOR_TAG);
        buffer.putInt(length);
        buffer.putInt(cardinality);
        for (int i = 0; i < (cardinality); i++) {
            buffer.putInt(indices[i]);
            buffer.putDouble(values[i]);
        }
        return buffer.array();
    }

    private int searchForIndex(int i) {
        if (((cardinality) == 0) || (i > (indices[((cardinality) - 1)]))) {
            return cardinality;
        }
        int left = 0;
        int right = cardinality;
        while (left < right) {
            int p = (left + right) / 2;
            if ((indices[p]) > i) {
                right = p;
            }else
                if ((indices[p]) < i) {
                    left = p + 1;
                }else {
                    return p;
                }

        } 
        return left;
    }

    private void insert(int k, int i, double value) {
        if (value == 0.0) {
            return;
        }
        if ((values.length) < ((cardinality) + 1)) {
            growUp();
        }
        if (((cardinality) - k) > 0) {
            java.lang.System.arraycopy(values, k, values, (k + 1), ((cardinality) - k));
            java.lang.System.arraycopy(indices, k, indices, (k + 1), ((cardinality) - k));
        }
        values[k] = value;
        indices[k] = i;
        (cardinality)++;
    }

    private void remove(int k) {
        (cardinality)--;
        if (((cardinality) - k) > 0) {
            java.lang.System.arraycopy(values, (k + 1), values, k, ((cardinality) - k));
            java.lang.System.arraycopy(indices, (k + 1), indices, k, ((cardinality) - k));
        }
    }

    private void growUp() {
        if ((values.length) == (length)) {
            throw new java.lang.IllegalStateException("This vector can't grow up.");
        }
        int capacity = java.lang.Math.min(length, ((((cardinality) * 3) / 2) + 1));
        double[] $values = new double[capacity];
        int[] $indices = new int[capacity];
        java.lang.System.arraycopy(values, 0, $values, 0, cardinality);
        java.lang.System.arraycopy(indices, 0, $indices, 0, cardinality);
        values = $values;
        indices = $indices;
    }

    private int align(int length, int capacity) {
        if (capacity < 0) {
            fail((("Cardinality should be positive: " + capacity) + "."));
        }
        if (capacity > length) {
            fail((("Cardinality should be less then or equal to capacity: " + capacity) + "."));
        }
        return java.lang.Math.min(length, (((capacity / (org.la4j.vector.sparse.CompressedVector.MINIMUM_SIZE)) + 1) * (org.la4j.vector.sparse.CompressedVector.MINIMUM_SIZE)));
    }

    @java.lang.Override
    public org.la4j.iterator.VectorIterator nonZeroIterator() {
        return new org.la4j.iterator.VectorIterator(length) {
            private boolean currentIsRemoved = false;

            private int k = -1;

            private int removedIndex = -1;

            @java.lang.Override
            public int index() {
                return currentIsRemoved ? removedIndex : indices[k];
            }

            @java.lang.Override
            public double get() {
                return currentIsRemoved ? 0.0 : values[k];
            }

            @java.lang.Override
            public void set(double value) {
                if ((value == 0.0) && (!(currentIsRemoved))) {
                    currentIsRemoved = true;
                    removedIndex = indices[k];
                    org.la4j.vector.sparse.CompressedVector.this.remove(((k)--));
                }else
                    if ((value != 0.0) && (!(currentIsRemoved))) {
                        values[k] = value;
                    }else {
                        currentIsRemoved = false;
                        org.la4j.vector.sparse.CompressedVector.this.insert((++(k)), removedIndex, value);
                    }

            }

            @java.lang.Override
            public boolean hasNext() {
                return ((k) + 1) < (cardinality);
            }

            @java.lang.Override
            public java.lang.Double next() {
                if (!(hasNext())) {
                    throw new java.util.NoSuchElementException();
                }
                currentIsRemoved = false;
                return values[(++(k))];
            }
        };
    }

    @java.lang.Override
    public org.la4j.iterator.VectorIterator iterator() {
        return new org.la4j.iterator.VectorIterator(length) {
            private int k = 0;

            private int i = -1;

            private boolean currentNonZero = false;

            @java.lang.Override
            public int index() {
                return i;
            }

            @java.lang.Override
            public double get() {
                return currentNonZero ? values[k] : 0.0;
            }

            @java.lang.Override
            public void set(double value) {
                if (currentNonZero) {
                    if (value == 0.0) {
                        org.la4j.vector.sparse.CompressedVector.this.remove(k);
                        currentNonZero = false;
                    }else {
                        values[k] = value;
                    }
                }else {
                    org.la4j.vector.sparse.CompressedVector.this.insert(k, i, value);
                    currentNonZero = true;
                }
            }

            @java.lang.Override
            public boolean hasNext() {
                return ((i) + 1) < (length);
            }

            @java.lang.Override
            public java.lang.Double next() {
                if (!(hasNext())) {
                    throw new java.util.NoSuchElementException();
                }
                if (currentNonZero) {
                    (k)++;
                }
                boolean spoonDefaultValue = false;
                try {
                    spoonDefaultValue = true;
                } catch (java.lang.Exception __NopolProcessorException) {
                }
                boolean runtimeAngelicValue = fr.inria.lille.repair.nopol.synth.AngelicExecution.angelicValue(spoonDefaultValue);
                if (fr.inria.lille.commons.trace.RuntimeValues.instance(3).isEnabled()) {
                    fr.inria.lille.commons.trace.RuntimeValues.instance(3).collectionStarts();
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(3).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.k",org.la4j.vector.sparse.CompressedVector.2.this.k);} catch (Exception ex1) {ex1.printStackTrace();};
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(3).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero",org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero);} catch (Exception ex1) {ex1.printStackTrace();};
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(3).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.i",org.la4j.vector.sparse.CompressedVector.2.this.i);} catch (Exception ex1) {ex1.printStackTrace();};
                    fr.inria.lille.commons.trace.RuntimeValues.instance(3).collectOutput(runtimeAngelicValue);
                    fr.inria.lille.commons.trace.RuntimeValues.instance(3).collectionEnds();
                }
                if (runtimeAngelicValue)
                    (i)++;

                currentNonZero = ((k) < (cardinality)) && ((indices[k]) == (i));
                return get();
            }
        };
    }
}
18:09:06.704 [pool-2-thread-1] ERROR fr.inria.lille.repair.nopol.NoPol - Error ExecutionException java.util.concurrent.ExecutionException: xxl.java.compiler.DynamicCompilationException: Aborting: dynamic compilation failed
18:09:06.704 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - statement #24
18:09:06.704 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - Analysing SourceLocation org.la4j.vector.sparse.CompressedVector$2:619 which is executed by 5 tests
1164465221
18:09:06.813 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - looking with class fr.inria.lille.repair.nopol.spoon.smt.ConditionalAdder
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
18:09:06.910 [pool-20-thread-1] INFO  xxl.java.junit.TestCasesListener - Tests run finished (84 ms)
<> Total tests run: 143
<> Ignored tests: 0
<> Failed tests: 2
~ testFromMap_unordered(org.la4j.vector.sparse.CompressedVectorTest)
[expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>]
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
~ testFromMap_unordered(org.la4j.vector.dense.BasicVectorTest)
[expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>]
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)

18:09:07.673 [pool-19-thread-1] ERROR x.java.compiler.DynamicClassCompiler - [Compilation errors]
CompressedVector.java:441: error: ')' expected
                        try{fr.inria.lille.commons.trace.RuntimeValues.instance(4).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.k",org.la4j.vector.sparse.CompressedVector.2.this.k);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                          ^
CompressedVector.java:441: error: illegal start of expression
                        try{fr.inria.lille.commons.trace.RuntimeValues.instance(4).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.k",org.la4j.vector.sparse.CompressedVector.2.this.k);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                            ^
CompressedVector.java:441: error: ';' expected
                        try{fr.inria.lille.commons.trace.RuntimeValues.instance(4).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.k",org.la4j.vector.sparse.CompressedVector.2.this.k);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                             ^
CompressedVector.java:441: error: illegal start of expression
                        try{fr.inria.lille.commons.trace.RuntimeValues.instance(4).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.k",org.la4j.vector.sparse.CompressedVector.2.this.k);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                                 ^
CompressedVector.java:441: error: ';' expected
                        try{fr.inria.lille.commons.trace.RuntimeValues.instance(4).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.k",org.la4j.vector.sparse.CompressedVector.2.this.k);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                                   ^
CompressedVector.java:442: error: ')' expected
                        try{fr.inria.lille.commons.trace.RuntimeValues.instance(4).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero",org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                                       ^
CompressedVector.java:442: error: illegal start of expression
                        try{fr.inria.lille.commons.trace.RuntimeValues.instance(4).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero",org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                                         ^
CompressedVector.java:442: error: ';' expected
                        try{fr.inria.lille.commons.trace.RuntimeValues.instance(4).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero",org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                                          ^
CompressedVector.java:442: error: illegal start of expression
                        try{fr.inria.lille.commons.trace.RuntimeValues.instance(4).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero",org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                                              ^
CompressedVector.java:442: error: ';' expected
                        try{fr.inria.lille.commons.trace.RuntimeValues.instance(4).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero",org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                                                             ^
CompressedVector.java:443: error: ')' expected
                        try{fr.inria.lille.commons.trace.RuntimeValues.instance(4).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.i",org.la4j.vector.sparse.CompressedVector.2.this.i);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                          ^
CompressedVector.java:443: error: illegal start of expression
                        try{fr.inria.lille.commons.trace.RuntimeValues.instance(4).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.i",org.la4j.vector.sparse.CompressedVector.2.this.i);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                            ^
CompressedVector.java:443: error: ';' expected
                        try{fr.inria.lille.commons.trace.RuntimeValues.instance(4).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.i",org.la4j.vector.sparse.CompressedVector.2.this.i);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                             ^
CompressedVector.java:443: error: illegal start of expression
                        try{fr.inria.lille.commons.trace.RuntimeValues.instance(4).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.i",org.la4j.vector.sparse.CompressedVector.2.this.i);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                                 ^
CompressedVector.java:443: error: ';' expected
                        try{fr.inria.lille.commons.trace.RuntimeValues.instance(4).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.i",org.la4j.vector.sparse.CompressedVector.2.this.i);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                                   ^
18:09:08.429 [pool-19-thread-1] ERROR f.i.l.r.n.s.ConstraintModelBuilder - Unable to compile the change: 
public class CompressedVector extends org.la4j.vector.SparseVector {
    private static final byte VECTOR_TAG = ((byte) (16));

    private static final int MINIMUM_SIZE = 32;

    private double[] values;

    private int[] indices;

    public CompressedVector() {
        this(0);
    }

    public CompressedVector(int length) {
        this(length, 0);
    }

    public CompressedVector(int length, int capacity) {
        super(length);
        int alignedSize = align(length, capacity);
        this.values = new double[alignedSize];
        this.indices = new int[alignedSize];
    }

    public CompressedVector(int length, int cardinality, double[] values, int[] indices) {
        super(length, cardinality);
        this.values = values;
        this.indices = indices;
    }

    public static org.la4j.vector.sparse.CompressedVector zero(int length) {
        return new org.la4j.vector.sparse.CompressedVector(length);
    }

    public static org.la4j.vector.sparse.CompressedVector zero(int length, int capacity) {
        return new org.la4j.vector.sparse.CompressedVector(length, capacity);
    }

    public static org.la4j.vector.sparse.CompressedVector random(int length, double density, java.util.Random random) {
        if ((density < 0.0) || (density > 1.0)) {
            throw new java.lang.IllegalArgumentException("The density value should be between 0 and 1.0");
        }
        int cardinality = ((int) (length * density));
        double[] values = new double[cardinality];
        int[] indices = new int[cardinality];
        for (int i = 0; i < cardinality; i++) {
            values[i] = random.nextDouble();
            indices[i] = random.nextInt(length);
        }
        java.util.Arrays.sort(indices);
        return new org.la4j.vector.sparse.CompressedVector(length, cardinality, values, indices);
    }

    public static org.la4j.vector.sparse.CompressedVector fromArray(double[] array) {
        int length = array.length;
        org.la4j.vector.sparse.CompressedVector result = org.la4j.vector.sparse.CompressedVector.zero(length);
        for (int i = 0; i < length; i++) {
            if ((array[i]) != 0.0) {
                result.set(i, array[i]);
            }
        }
        return result;
    }

    public static org.la4j.vector.sparse.CompressedVector fromBinary(byte[] array) {
        java.nio.ByteBuffer buffer = java.nio.ByteBuffer.wrap(array);
        if ((buffer.get()) != (org.la4j.vector.sparse.CompressedVector.VECTOR_TAG)) {
            throw new java.lang.IllegalArgumentException("Can not decode CompressedVector from the given byte array.");
        }
        int length = buffer.getInt();
        int cardinality = buffer.getInt();
        double[] values = new double[cardinality];
        int[] indices = new int[cardinality];
        for (int i = 0; i < cardinality; i++) {
            indices[i] = buffer.getInt();
            values[i] = buffer.getDouble();
        }
        return new org.la4j.vector.sparse.CompressedVector(length, cardinality, values, indices);
    }

    public static org.la4j.vector.sparse.CompressedVector fromCSV(java.lang.String csv) {
        return org.la4j.Vector.fromCSV(csv).to(org.la4j.Vectors.COMPRESSED);
    }

    public static org.la4j.vector.sparse.CompressedVector fromMatrixMarket(java.lang.String mm) {
        return org.la4j.Vector.fromMatrixMarket(mm).to(org.la4j.Vectors.COMPRESSED);
    }

    public static org.la4j.vector.sparse.CompressedVector fromCollection(java.util.Collection<? extends java.lang.Number> list) {
        return org.la4j.Vector.fromCollection(list).to(org.la4j.Vectors.COMPRESSED);
    }

    public static org.la4j.vector.sparse.CompressedVector fromMap(java.util.Map<java.lang.Integer, ? extends java.lang.Number> map, int length) {
        int cardinality = map.size();
        int[] indices = new int[cardinality];
        double[] values = new double[cardinality];
        int i = 0;
        for (java.util.Map.Entry<java.lang.Integer, ? extends java.lang.Number> entry : map.entrySet()) {
            int index = entry.getKey();
            if ((index < 0) || (index >= length)) {
                throw new java.lang.IllegalArgumentException("Check your map: Index must be 0..n-1");
            }
            indices[i] = index;
            values[i] = entry.getValue().doubleValue();
            i++;
        }
        return new org.la4j.vector.sparse.CompressedVector(length, cardinality, values, indices);
    }

    @java.lang.Override
    public double getOrElse(int i, double defaultValue) {
        ensureIndexIsInBounds(i);
        int k = searchForIndex(i);
        if ((k < (cardinality)) && ((indices[k]) == i)) {
            return values[k];
        }
        return defaultValue;
    }

    @java.lang.Override
    public void set(int i, double value) {
        ensureIndexIsInBounds(i);
        int k = searchForIndex(i);
        if ((k < (cardinality)) && ((indices[k]) == i)) {
            if (value != 0.0) {
                values[k] = value;
            }else {
                remove(k);
            }
        }else {
            insert(k, i, value);
        }
    }

    @java.lang.Override
    public void setAll(double value) {
        if (value == 0.0) {
            cardinality = 0;
        }else {
            if ((values.length) < (length)) {
                values = new double[length];
                indices = new int[length];
            }
            for (int i = 0; i < (length); i++) {
                indices[i] = i;
                values[i] = value;
            }
            cardinality = length;
        }
    }

    @java.lang.Override
    public void swapElements(int i, int j) {
        if (i == j) {
            return;
        }
        int ii = searchForIndex(i);
        int jj = searchForIndex(j);
        boolean iiNotZero = (ii < (cardinality)) && (i == (indices[ii]));
        boolean jjNotZero = (jj < (cardinality)) && (j == (indices[jj]));
        if (iiNotZero && jjNotZero) {
            double sd = values[ii];
            values[ii] = values[jj];
            values[jj] = sd;
        }else {
            double notZero = values[(iiNotZero ? ii : jj)];
            int leftIndex = (ii < jj) ? ii : jj;
            int rightIndex = (ii > jj) ? ii : jj;
            if (((iiNotZero && (leftIndex == ii)) || (jjNotZero && (leftIndex == jj))) && (ii != jj)) {
                java.lang.System.arraycopy(values, (leftIndex + 1), values, leftIndex, ((cardinality) - leftIndex));
                java.lang.System.arraycopy(values, (rightIndex - 1), values, rightIndex, ((cardinality) - rightIndex));
                values[(rightIndex - 1)] = notZero;
                java.lang.System.arraycopy(indices, (leftIndex + 1), indices, leftIndex, ((cardinality) - leftIndex));
                java.lang.System.arraycopy(indices, (rightIndex - 1), indices, rightIndex, ((cardinality) - rightIndex));
                indices[(rightIndex - 1)] = (jjNotZero) ? i : j;
            }else
                if ((iiNotZero && (rightIndex == ii)) || (jjNotZero && (rightIndex == jj))) {
                    java.lang.System.arraycopy(values, (rightIndex + 1), values, rightIndex, ((cardinality) - rightIndex));
                    java.lang.System.arraycopy(values, leftIndex, values, (leftIndex + 1), ((cardinality) - leftIndex));
                    values[leftIndex] = notZero;
                    java.lang.System.arraycopy(indices, (rightIndex + 1), indices, rightIndex, ((cardinality) - rightIndex));
                    java.lang.System.arraycopy(indices, leftIndex, indices, (leftIndex + 1), ((cardinality) - leftIndex));
                    indices[leftIndex] = (jjNotZero) ? i : j;
                }

        }
    }

    @java.lang.Override
    public org.la4j.Vector copyOfLength(int length) {
        ensureLengthIsCorrect(length);
        int $cardinality = (length >= (this.length)) ? cardinality : searchForIndex(length);
        int capacity = align(length, $cardinality);
        double[] $values = new double[capacity];
        int[] $indices = new int[capacity];
        java.lang.System.arraycopy(values, 0, $values, 0, $cardinality);
        java.lang.System.arraycopy(indices, 0, $indices, 0, $cardinality);
        return new org.la4j.vector.sparse.CompressedVector(length, $cardinality, $values, $indices);
    }

    @java.lang.Override
    public void each(org.la4j.vector.functor.VectorProcedure procedure) {
        int k = 0;
        for (int i = 0; i < (length); i++) {
            if ((k < (cardinality)) && ((indices[k]) == i)) {
                procedure.apply(i, values[(k++)]);
            }else {
                procedure.apply(i, 0.0);
            }
        }
    }

    @java.lang.Override
    public void eachNonZero(org.la4j.vector.functor.VectorProcedure procedure) {
        for (int i = 0; i < (cardinality); i++) {
            procedure.apply(indices[i], values[i]);
        }
    }

    @java.lang.Override
    public void updateAt(int i, org.la4j.vector.functor.VectorFunction function) {
        int k = searchForIndex(i);
        if ((k < (cardinality)) && ((indices[k]) == i)) {
            double value = function.evaluate(i, values[k]);
            if (value != 0.0) {
                values[k] = value;
            }else {
                remove(k);
            }
        }else {
            insert(k, i, function.evaluate(i, 0.0));
        }
    }

    @java.lang.Override
    public boolean nonZeroAt(int i) {
        int k = searchForIndex(i);
        return (k < (cardinality)) && ((indices[k]) == i);
    }

    @java.lang.Override
    public <T extends org.la4j.Vector> T to(org.la4j.vector.VectorFactory<T> factory) {
        if ((factory.outputClass) == (org.la4j.vector.sparse.CompressedVector.class)) {
            return factory.outputClass.cast(this);
        }
        return super.to(factory);
    }

    @java.lang.Override
    public org.la4j.Vector blankOfLength(int length) {
        return org.la4j.vector.sparse.CompressedVector.zero(length);
    }

    @java.lang.Override
    public byte[] toBinary() {
        int size = (((1 + 4) + 4) + (8 * (cardinality))) + (8 * (cardinality));
        java.nio.ByteBuffer buffer = java.nio.ByteBuffer.allocate(size);
        buffer.put(org.la4j.vector.sparse.CompressedVector.VECTOR_TAG);
        buffer.putInt(length);
        buffer.putInt(cardinality);
        for (int i = 0; i < (cardinality); i++) {
            buffer.putInt(indices[i]);
            buffer.putDouble(values[i]);
        }
        return buffer.array();
    }

    private int searchForIndex(int i) {
        if (((cardinality) == 0) || (i > (indices[((cardinality) - 1)]))) {
            return cardinality;
        }
        int left = 0;
        int right = cardinality;
        while (left < right) {
            int p = (left + right) / 2;
            if ((indices[p]) > i) {
                right = p;
            }else
                if ((indices[p]) < i) {
                    left = p + 1;
                }else {
                    return p;
                }

        } 
        return left;
    }

    private void insert(int k, int i, double value) {
        if (value == 0.0) {
            return;
        }
        if ((values.length) < ((cardinality) + 1)) {
            growUp();
        }
        if (((cardinality) - k) > 0) {
            java.lang.System.arraycopy(values, k, values, (k + 1), ((cardinality) - k));
            java.lang.System.arraycopy(indices, k, indices, (k + 1), ((cardinality) - k));
        }
        values[k] = value;
        indices[k] = i;
        (cardinality)++;
    }

    private void remove(int k) {
        (cardinality)--;
        if (((cardinality) - k) > 0) {
            java.lang.System.arraycopy(values, (k + 1), values, k, ((cardinality) - k));
            java.lang.System.arraycopy(indices, (k + 1), indices, k, ((cardinality) - k));
        }
    }

    private void growUp() {
        if ((values.length) == (length)) {
            throw new java.lang.IllegalStateException("This vector can't grow up.");
        }
        int capacity = java.lang.Math.min(length, ((((cardinality) * 3) / 2) + 1));
        double[] $values = new double[capacity];
        int[] $indices = new int[capacity];
        java.lang.System.arraycopy(values, 0, $values, 0, cardinality);
        java.lang.System.arraycopy(indices, 0, $indices, 0, cardinality);
        values = $values;
        indices = $indices;
    }

    private int align(int length, int capacity) {
        if (capacity < 0) {
            fail((("Cardinality should be positive: " + capacity) + "."));
        }
        if (capacity > length) {
            fail((("Cardinality should be less then or equal to capacity: " + capacity) + "."));
        }
        return java.lang.Math.min(length, (((capacity / (org.la4j.vector.sparse.CompressedVector.MINIMUM_SIZE)) + 1) * (org.la4j.vector.sparse.CompressedVector.MINIMUM_SIZE)));
    }

    @java.lang.Override
    public org.la4j.iterator.VectorIterator nonZeroIterator() {
        return new org.la4j.iterator.VectorIterator(length) {
            private boolean currentIsRemoved = false;

            private int k = -1;

            private int removedIndex = -1;

            @java.lang.Override
            public int index() {
                return currentIsRemoved ? removedIndex : indices[k];
            }

            @java.lang.Override
            public double get() {
                return currentIsRemoved ? 0.0 : values[k];
            }

            @java.lang.Override
            public void set(double value) {
                if ((value == 0.0) && (!(currentIsRemoved))) {
                    currentIsRemoved = true;
                    removedIndex = indices[k];
                    org.la4j.vector.sparse.CompressedVector.this.remove(((k)--));
                }else
                    if ((value != 0.0) && (!(currentIsRemoved))) {
                        values[k] = value;
                    }else {
                        currentIsRemoved = false;
                        org.la4j.vector.sparse.CompressedVector.this.insert((++(k)), removedIndex, value);
                    }

            }

            @java.lang.Override
            public boolean hasNext() {
                return ((k) + 1) < (cardinality);
            }

            @java.lang.Override
            public java.lang.Double next() {
                if (!(hasNext())) {
                    throw new java.util.NoSuchElementException();
                }
                currentIsRemoved = false;
                return values[(++(k))];
            }
        };
    }

    @java.lang.Override
    public org.la4j.iterator.VectorIterator iterator() {
        return new org.la4j.iterator.VectorIterator(length) {
            private int k = 0;

            private int i = -1;

            private boolean currentNonZero = false;

            @java.lang.Override
            public int index() {
                return i;
            }

            @java.lang.Override
            public double get() {
                return currentNonZero ? values[k] : 0.0;
            }

            @java.lang.Override
            public void set(double value) {
                if (currentNonZero) {
                    if (value == 0.0) {
                        org.la4j.vector.sparse.CompressedVector.this.remove(k);
                        currentNonZero = false;
                    }else {
                        values[k] = value;
                    }
                }else {
                    org.la4j.vector.sparse.CompressedVector.this.insert(k, i, value);
                    currentNonZero = true;
                }
            }

            @java.lang.Override
            public boolean hasNext() {
                return ((i) + 1) < (length);
            }

            @java.lang.Override
            public java.lang.Double next() {
                if (!(hasNext())) {
                    throw new java.util.NoSuchElementException();
                }
                if (currentNonZero) {
                    boolean spoonDefaultValue = false;
                    try {
                        spoonDefaultValue = true;
                    } catch (java.lang.Exception __NopolProcessorException) {
                    }
                    boolean runtimeAngelicValue = fr.inria.lille.repair.nopol.synth.AngelicExecution.angelicValue(spoonDefaultValue);
                    if (fr.inria.lille.commons.trace.RuntimeValues.instance(4).isEnabled()) {
                        fr.inria.lille.commons.trace.RuntimeValues.instance(4).collectionStarts();
                        try{fr.inria.lille.commons.trace.RuntimeValues.instance(4).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.k",org.la4j.vector.sparse.CompressedVector.2.this.k);} catch (Exception ex1) {ex1.printStackTrace();};
                        try{fr.inria.lille.commons.trace.RuntimeValues.instance(4).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero",org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero);} catch (Exception ex1) {ex1.printStackTrace();};
                        try{fr.inria.lille.commons.trace.RuntimeValues.instance(4).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.i",org.la4j.vector.sparse.CompressedVector.2.this.i);} catch (Exception ex1) {ex1.printStackTrace();};
                        fr.inria.lille.commons.trace.RuntimeValues.instance(4).collectOutput(runtimeAngelicValue);
                        fr.inria.lille.commons.trace.RuntimeValues.instance(4).collectionEnds();
                    }
                    if (runtimeAngelicValue)
                        (k)++;

                }
                (i)++;
                currentNonZero = ((k) < (cardinality)) && ((indices[k]) == (i));
                return get();
            }
        };
    }
}
18:09:08.430 [pool-2-thread-1] ERROR fr.inria.lille.repair.nopol.NoPol - Error ExecutionException java.util.concurrent.ExecutionException: xxl.java.compiler.DynamicCompilationException: Aborting: dynamic compilation failed
18:09:08.430 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - statement #25
18:09:08.430 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - Analysing SourceLocation org.la4j.vector.sparse.CompressedVector$2:618 which is executed by 5 tests
1164465221
18:09:08.576 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - looking with class fr.inria.lille.repair.nopol.spoon.smt.ConditionalAdder
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
18:09:08.672 [pool-22-thread-1] INFO  xxl.java.junit.TestCasesListener - Tests run finished (81 ms)
<> Total tests run: 143
<> Ignored tests: 0
<> Failed tests: 2
~ testFromMap_unordered(org.la4j.vector.sparse.CompressedVectorTest)
[expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>]
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
~ testFromMap_unordered(org.la4j.vector.dense.BasicVectorTest)
[expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>]
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)

18:09:09.390 [pool-21-thread-1] ERROR x.java.compiler.DynamicClassCompiler - [Compilation errors]
CompressedVector.java:440: error: ')' expected
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(5).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.k",org.la4j.vector.sparse.CompressedVector.2.this.k);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                      ^
CompressedVector.java:440: error: illegal start of expression
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(5).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.k",org.la4j.vector.sparse.CompressedVector.2.this.k);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                        ^
CompressedVector.java:440: error: ';' expected
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(5).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.k",org.la4j.vector.sparse.CompressedVector.2.this.k);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                         ^
CompressedVector.java:440: error: illegal start of expression
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(5).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.k",org.la4j.vector.sparse.CompressedVector.2.this.k);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                             ^
CompressedVector.java:440: error: ';' expected
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(5).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.k",org.la4j.vector.sparse.CompressedVector.2.this.k);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                               ^
CompressedVector.java:441: error: ')' expected
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(5).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero",org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                                   ^
CompressedVector.java:441: error: illegal start of expression
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(5).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero",org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                                     ^
CompressedVector.java:441: error: ';' expected
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(5).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero",org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                                      ^
CompressedVector.java:441: error: illegal start of expression
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(5).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero",org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                                          ^
CompressedVector.java:441: error: ';' expected
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(5).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero",org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                                                         ^
CompressedVector.java:442: error: ')' expected
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(5).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.i",org.la4j.vector.sparse.CompressedVector.2.this.i);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                      ^
CompressedVector.java:442: error: illegal start of expression
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(5).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.i",org.la4j.vector.sparse.CompressedVector.2.this.i);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                        ^
CompressedVector.java:442: error: ';' expected
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(5).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.i",org.la4j.vector.sparse.CompressedVector.2.this.i);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                         ^
CompressedVector.java:442: error: illegal start of expression
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(5).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.i",org.la4j.vector.sparse.CompressedVector.2.this.i);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                             ^
CompressedVector.java:442: error: ';' expected
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(5).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.i",org.la4j.vector.sparse.CompressedVector.2.this.i);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                               ^
18:09:09.897 [pool-21-thread-1] ERROR f.i.l.r.n.s.ConstraintModelBuilder - Unable to compile the change: 
public class CompressedVector extends org.la4j.vector.SparseVector {
    private static final byte VECTOR_TAG = ((byte) (16));

    private static final int MINIMUM_SIZE = 32;

    private double[] values;

    private int[] indices;

    public CompressedVector() {
        this(0);
    }

    public CompressedVector(int length) {
        this(length, 0);
    }

    public CompressedVector(int length, int capacity) {
        super(length);
        int alignedSize = align(length, capacity);
        this.values = new double[alignedSize];
        this.indices = new int[alignedSize];
    }

    public CompressedVector(int length, int cardinality, double[] values, int[] indices) {
        super(length, cardinality);
        this.values = values;
        this.indices = indices;
    }

    public static org.la4j.vector.sparse.CompressedVector zero(int length) {
        return new org.la4j.vector.sparse.CompressedVector(length);
    }

    public static org.la4j.vector.sparse.CompressedVector zero(int length, int capacity) {
        return new org.la4j.vector.sparse.CompressedVector(length, capacity);
    }

    public static org.la4j.vector.sparse.CompressedVector random(int length, double density, java.util.Random random) {
        if ((density < 0.0) || (density > 1.0)) {
            throw new java.lang.IllegalArgumentException("The density value should be between 0 and 1.0");
        }
        int cardinality = ((int) (length * density));
        double[] values = new double[cardinality];
        int[] indices = new int[cardinality];
        for (int i = 0; i < cardinality; i++) {
            values[i] = random.nextDouble();
            indices[i] = random.nextInt(length);
        }
        java.util.Arrays.sort(indices);
        return new org.la4j.vector.sparse.CompressedVector(length, cardinality, values, indices);
    }

    public static org.la4j.vector.sparse.CompressedVector fromArray(double[] array) {
        int length = array.length;
        org.la4j.vector.sparse.CompressedVector result = org.la4j.vector.sparse.CompressedVector.zero(length);
        for (int i = 0; i < length; i++) {
            if ((array[i]) != 0.0) {
                result.set(i, array[i]);
            }
        }
        return result;
    }

    public static org.la4j.vector.sparse.CompressedVector fromBinary(byte[] array) {
        java.nio.ByteBuffer buffer = java.nio.ByteBuffer.wrap(array);
        if ((buffer.get()) != (org.la4j.vector.sparse.CompressedVector.VECTOR_TAG)) {
            throw new java.lang.IllegalArgumentException("Can not decode CompressedVector from the given byte array.");
        }
        int length = buffer.getInt();
        int cardinality = buffer.getInt();
        double[] values = new double[cardinality];
        int[] indices = new int[cardinality];
        for (int i = 0; i < cardinality; i++) {
            indices[i] = buffer.getInt();
            values[i] = buffer.getDouble();
        }
        return new org.la4j.vector.sparse.CompressedVector(length, cardinality, values, indices);
    }

    public static org.la4j.vector.sparse.CompressedVector fromCSV(java.lang.String csv) {
        return org.la4j.Vector.fromCSV(csv).to(org.la4j.Vectors.COMPRESSED);
    }

    public static org.la4j.vector.sparse.CompressedVector fromMatrixMarket(java.lang.String mm) {
        return org.la4j.Vector.fromMatrixMarket(mm).to(org.la4j.Vectors.COMPRESSED);
    }

    public static org.la4j.vector.sparse.CompressedVector fromCollection(java.util.Collection<? extends java.lang.Number> list) {
        return org.la4j.Vector.fromCollection(list).to(org.la4j.Vectors.COMPRESSED);
    }

    public static org.la4j.vector.sparse.CompressedVector fromMap(java.util.Map<java.lang.Integer, ? extends java.lang.Number> map, int length) {
        int cardinality = map.size();
        int[] indices = new int[cardinality];
        double[] values = new double[cardinality];
        int i = 0;
        for (java.util.Map.Entry<java.lang.Integer, ? extends java.lang.Number> entry : map.entrySet()) {
            int index = entry.getKey();
            if ((index < 0) || (index >= length)) {
                throw new java.lang.IllegalArgumentException("Check your map: Index must be 0..n-1");
            }
            indices[i] = index;
            values[i] = entry.getValue().doubleValue();
            i++;
        }
        return new org.la4j.vector.sparse.CompressedVector(length, cardinality, values, indices);
    }

    @java.lang.Override
    public double getOrElse(int i, double defaultValue) {
        ensureIndexIsInBounds(i);
        int k = searchForIndex(i);
        if ((k < (cardinality)) && ((indices[k]) == i)) {
            return values[k];
        }
        return defaultValue;
    }

    @java.lang.Override
    public void set(int i, double value) {
        ensureIndexIsInBounds(i);
        int k = searchForIndex(i);
        if ((k < (cardinality)) && ((indices[k]) == i)) {
            if (value != 0.0) {
                values[k] = value;
            }else {
                remove(k);
            }
        }else {
            insert(k, i, value);
        }
    }

    @java.lang.Override
    public void setAll(double value) {
        if (value == 0.0) {
            cardinality = 0;
        }else {
            if ((values.length) < (length)) {
                values = new double[length];
                indices = new int[length];
            }
            for (int i = 0; i < (length); i++) {
                indices[i] = i;
                values[i] = value;
            }
            cardinality = length;
        }
    }

    @java.lang.Override
    public void swapElements(int i, int j) {
        if (i == j) {
            return;
        }
        int ii = searchForIndex(i);
        int jj = searchForIndex(j);
        boolean iiNotZero = (ii < (cardinality)) && (i == (indices[ii]));
        boolean jjNotZero = (jj < (cardinality)) && (j == (indices[jj]));
        if (iiNotZero && jjNotZero) {
            double sd = values[ii];
            values[ii] = values[jj];
            values[jj] = sd;
        }else {
            double notZero = values[(iiNotZero ? ii : jj)];
            int leftIndex = (ii < jj) ? ii : jj;
            int rightIndex = (ii > jj) ? ii : jj;
            if (((iiNotZero && (leftIndex == ii)) || (jjNotZero && (leftIndex == jj))) && (ii != jj)) {
                java.lang.System.arraycopy(values, (leftIndex + 1), values, leftIndex, ((cardinality) - leftIndex));
                java.lang.System.arraycopy(values, (rightIndex - 1), values, rightIndex, ((cardinality) - rightIndex));
                values[(rightIndex - 1)] = notZero;
                java.lang.System.arraycopy(indices, (leftIndex + 1), indices, leftIndex, ((cardinality) - leftIndex));
                java.lang.System.arraycopy(indices, (rightIndex - 1), indices, rightIndex, ((cardinality) - rightIndex));
                indices[(rightIndex - 1)] = (jjNotZero) ? i : j;
            }else
                if ((iiNotZero && (rightIndex == ii)) || (jjNotZero && (rightIndex == jj))) {
                    java.lang.System.arraycopy(values, (rightIndex + 1), values, rightIndex, ((cardinality) - rightIndex));
                    java.lang.System.arraycopy(values, leftIndex, values, (leftIndex + 1), ((cardinality) - leftIndex));
                    values[leftIndex] = notZero;
                    java.lang.System.arraycopy(indices, (rightIndex + 1), indices, rightIndex, ((cardinality) - rightIndex));
                    java.lang.System.arraycopy(indices, leftIndex, indices, (leftIndex + 1), ((cardinality) - leftIndex));
                    indices[leftIndex] = (jjNotZero) ? i : j;
                }

        }
    }

    @java.lang.Override
    public org.la4j.Vector copyOfLength(int length) {
        ensureLengthIsCorrect(length);
        int $cardinality = (length >= (this.length)) ? cardinality : searchForIndex(length);
        int capacity = align(length, $cardinality);
        double[] $values = new double[capacity];
        int[] $indices = new int[capacity];
        java.lang.System.arraycopy(values, 0, $values, 0, $cardinality);
        java.lang.System.arraycopy(indices, 0, $indices, 0, $cardinality);
        return new org.la4j.vector.sparse.CompressedVector(length, $cardinality, $values, $indices);
    }

    @java.lang.Override
    public void each(org.la4j.vector.functor.VectorProcedure procedure) {
        int k = 0;
        for (int i = 0; i < (length); i++) {
            if ((k < (cardinality)) && ((indices[k]) == i)) {
                procedure.apply(i, values[(k++)]);
            }else {
                procedure.apply(i, 0.0);
            }
        }
    }

    @java.lang.Override
    public void eachNonZero(org.la4j.vector.functor.VectorProcedure procedure) {
        for (int i = 0; i < (cardinality); i++) {
            procedure.apply(indices[i], values[i]);
        }
    }

    @java.lang.Override
    public void updateAt(int i, org.la4j.vector.functor.VectorFunction function) {
        int k = searchForIndex(i);
        if ((k < (cardinality)) && ((indices[k]) == i)) {
            double value = function.evaluate(i, values[k]);
            if (value != 0.0) {
                values[k] = value;
            }else {
                remove(k);
            }
        }else {
            insert(k, i, function.evaluate(i, 0.0));
        }
    }

    @java.lang.Override
    public boolean nonZeroAt(int i) {
        int k = searchForIndex(i);
        return (k < (cardinality)) && ((indices[k]) == i);
    }

    @java.lang.Override
    public <T extends org.la4j.Vector> T to(org.la4j.vector.VectorFactory<T> factory) {
        if ((factory.outputClass) == (org.la4j.vector.sparse.CompressedVector.class)) {
            return factory.outputClass.cast(this);
        }
        return super.to(factory);
    }

    @java.lang.Override
    public org.la4j.Vector blankOfLength(int length) {
        return org.la4j.vector.sparse.CompressedVector.zero(length);
    }

    @java.lang.Override
    public byte[] toBinary() {
        int size = (((1 + 4) + 4) + (8 * (cardinality))) + (8 * (cardinality));
        java.nio.ByteBuffer buffer = java.nio.ByteBuffer.allocate(size);
        buffer.put(org.la4j.vector.sparse.CompressedVector.VECTOR_TAG);
        buffer.putInt(length);
        buffer.putInt(cardinality);
        for (int i = 0; i < (cardinality); i++) {
            buffer.putInt(indices[i]);
            buffer.putDouble(values[i]);
        }
        return buffer.array();
    }

    private int searchForIndex(int i) {
        if (((cardinality) == 0) || (i > (indices[((cardinality) - 1)]))) {
            return cardinality;
        }
        int left = 0;
        int right = cardinality;
        while (left < right) {
            int p = (left + right) / 2;
            if ((indices[p]) > i) {
                right = p;
            }else
                if ((indices[p]) < i) {
                    left = p + 1;
                }else {
                    return p;
                }

        } 
        return left;
    }

    private void insert(int k, int i, double value) {
        if (value == 0.0) {
            return;
        }
        if ((values.length) < ((cardinality) + 1)) {
            growUp();
        }
        if (((cardinality) - k) > 0) {
            java.lang.System.arraycopy(values, k, values, (k + 1), ((cardinality) - k));
            java.lang.System.arraycopy(indices, k, indices, (k + 1), ((cardinality) - k));
        }
        values[k] = value;
        indices[k] = i;
        (cardinality)++;
    }

    private void remove(int k) {
        (cardinality)--;
        if (((cardinality) - k) > 0) {
            java.lang.System.arraycopy(values, (k + 1), values, k, ((cardinality) - k));
            java.lang.System.arraycopy(indices, (k + 1), indices, k, ((cardinality) - k));
        }
    }

    private void growUp() {
        if ((values.length) == (length)) {
            throw new java.lang.IllegalStateException("This vector can't grow up.");
        }
        int capacity = java.lang.Math.min(length, ((((cardinality) * 3) / 2) + 1));
        double[] $values = new double[capacity];
        int[] $indices = new int[capacity];
        java.lang.System.arraycopy(values, 0, $values, 0, cardinality);
        java.lang.System.arraycopy(indices, 0, $indices, 0, cardinality);
        values = $values;
        indices = $indices;
    }

    private int align(int length, int capacity) {
        if (capacity < 0) {
            fail((("Cardinality should be positive: " + capacity) + "."));
        }
        if (capacity > length) {
            fail((("Cardinality should be less then or equal to capacity: " + capacity) + "."));
        }
        return java.lang.Math.min(length, (((capacity / (org.la4j.vector.sparse.CompressedVector.MINIMUM_SIZE)) + 1) * (org.la4j.vector.sparse.CompressedVector.MINIMUM_SIZE)));
    }

    @java.lang.Override
    public org.la4j.iterator.VectorIterator nonZeroIterator() {
        return new org.la4j.iterator.VectorIterator(length) {
            private boolean currentIsRemoved = false;

            private int k = -1;

            private int removedIndex = -1;

            @java.lang.Override
            public int index() {
                return currentIsRemoved ? removedIndex : indices[k];
            }

            @java.lang.Override
            public double get() {
                return currentIsRemoved ? 0.0 : values[k];
            }

            @java.lang.Override
            public void set(double value) {
                if ((value == 0.0) && (!(currentIsRemoved))) {
                    currentIsRemoved = true;
                    removedIndex = indices[k];
                    org.la4j.vector.sparse.CompressedVector.this.remove(((k)--));
                }else
                    if ((value != 0.0) && (!(currentIsRemoved))) {
                        values[k] = value;
                    }else {
                        currentIsRemoved = false;
                        org.la4j.vector.sparse.CompressedVector.this.insert((++(k)), removedIndex, value);
                    }

            }

            @java.lang.Override
            public boolean hasNext() {
                return ((k) + 1) < (cardinality);
            }

            @java.lang.Override
            public java.lang.Double next() {
                if (!(hasNext())) {
                    throw new java.util.NoSuchElementException();
                }
                currentIsRemoved = false;
                return values[(++(k))];
            }
        };
    }

    @java.lang.Override
    public org.la4j.iterator.VectorIterator iterator() {
        return new org.la4j.iterator.VectorIterator(length) {
            private int k = 0;

            private int i = -1;

            private boolean currentNonZero = false;

            @java.lang.Override
            public int index() {
                return i;
            }

            @java.lang.Override
            public double get() {
                return currentNonZero ? values[k] : 0.0;
            }

            @java.lang.Override
            public void set(double value) {
                if (currentNonZero) {
                    if (value == 0.0) {
                        org.la4j.vector.sparse.CompressedVector.this.remove(k);
                        currentNonZero = false;
                    }else {
                        values[k] = value;
                    }
                }else {
                    org.la4j.vector.sparse.CompressedVector.this.insert(k, i, value);
                    currentNonZero = true;
                }
            }

            @java.lang.Override
            public boolean hasNext() {
                return ((i) + 1) < (length);
            }

            @java.lang.Override
            public java.lang.Double next() {
                if (!(hasNext())) {
                    throw new java.util.NoSuchElementException();
                }
                boolean spoonDefaultValue = false;
                try {
                    spoonDefaultValue = true;
                } catch (java.lang.Exception __NopolProcessorException) {
                }
                boolean runtimeAngelicValue = fr.inria.lille.repair.nopol.synth.AngelicExecution.angelicValue(spoonDefaultValue);
                if (fr.inria.lille.commons.trace.RuntimeValues.instance(5).isEnabled()) {
                    fr.inria.lille.commons.trace.RuntimeValues.instance(5).collectionStarts();
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(5).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.k",org.la4j.vector.sparse.CompressedVector.2.this.k);} catch (Exception ex1) {ex1.printStackTrace();};
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(5).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero",org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero);} catch (Exception ex1) {ex1.printStackTrace();};
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(5).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.i",org.la4j.vector.sparse.CompressedVector.2.this.i);} catch (Exception ex1) {ex1.printStackTrace();};
                    fr.inria.lille.commons.trace.RuntimeValues.instance(5).collectOutput(runtimeAngelicValue);
                    fr.inria.lille.commons.trace.RuntimeValues.instance(5).collectionEnds();
                }
                if (runtimeAngelicValue) if (currentNonZero) {
                    (k)++;
                }
                (i)++;
                currentNonZero = ((k) < (cardinality)) && ((indices[k]) == (i));
                return get();
            }
        };
    }
}
18:09:09.897 [pool-2-thread-1] ERROR fr.inria.lille.repair.nopol.NoPol - Error ExecutionException java.util.concurrent.ExecutionException: xxl.java.compiler.DynamicCompilationException: Aborting: dynamic compilation failed
18:09:09.898 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - looking with class fr.inria.lille.repair.nopol.spoon.smt.ConditionalReplacer
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
18:09:09.988 [pool-24-thread-1] INFO  xxl.java.junit.TestCasesListener - Tests run finished (79 ms)
<> Total tests run: 143
<> Ignored tests: 0
<> Failed tests: 2
~ testFromMap_unordered(org.la4j.vector.sparse.CompressedVectorTest)
[expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>]
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
~ testFromMap_unordered(org.la4j.vector.dense.BasicVectorTest)
[expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>]
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)

18:09:10.976 [pool-23-thread-1] ERROR x.java.compiler.DynamicClassCompiler - [Compilation errors]
CompressedVector.java:440: error: ')' expected
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(6).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.k",org.la4j.vector.sparse.CompressedVector.2.this.k);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                      ^
CompressedVector.java:440: error: illegal start of expression
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(6).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.k",org.la4j.vector.sparse.CompressedVector.2.this.k);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                        ^
CompressedVector.java:440: error: ';' expected
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(6).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.k",org.la4j.vector.sparse.CompressedVector.2.this.k);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                         ^
CompressedVector.java:440: error: illegal start of expression
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(6).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.k",org.la4j.vector.sparse.CompressedVector.2.this.k);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                             ^
CompressedVector.java:440: error: ';' expected
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(6).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.k",org.la4j.vector.sparse.CompressedVector.2.this.k);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                               ^
CompressedVector.java:441: error: ')' expected
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(6).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero",org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                                   ^
CompressedVector.java:441: error: illegal start of expression
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(6).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero",org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                                     ^
CompressedVector.java:441: error: ';' expected
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(6).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero",org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                                      ^
CompressedVector.java:441: error: illegal start of expression
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(6).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero",org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                                          ^
CompressedVector.java:441: error: ';' expected
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(6).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero",org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                                                         ^
CompressedVector.java:442: error: ')' expected
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(6).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.i",org.la4j.vector.sparse.CompressedVector.2.this.i);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                      ^
CompressedVector.java:442: error: illegal start of expression
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(6).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.i",org.la4j.vector.sparse.CompressedVector.2.this.i);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                        ^
CompressedVector.java:442: error: ';' expected
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(6).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.i",org.la4j.vector.sparse.CompressedVector.2.this.i);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                         ^
CompressedVector.java:442: error: illegal start of expression
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(6).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.i",org.la4j.vector.sparse.CompressedVector.2.this.i);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                             ^
CompressedVector.java:442: error: ';' expected
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(6).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.i",org.la4j.vector.sparse.CompressedVector.2.this.i);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                               ^
18:09:11.462 [pool-23-thread-1] ERROR f.i.l.r.n.s.ConstraintModelBuilder - Unable to compile the change: 
public class CompressedVector extends org.la4j.vector.SparseVector {
    private static final byte VECTOR_TAG = ((byte) (16));

    private static final int MINIMUM_SIZE = 32;

    private double[] values;

    private int[] indices;

    public CompressedVector() {
        this(0);
    }

    public CompressedVector(int length) {
        this(length, 0);
    }

    public CompressedVector(int length, int capacity) {
        super(length);
        int alignedSize = align(length, capacity);
        this.values = new double[alignedSize];
        this.indices = new int[alignedSize];
    }

    public CompressedVector(int length, int cardinality, double[] values, int[] indices) {
        super(length, cardinality);
        this.values = values;
        this.indices = indices;
    }

    public static org.la4j.vector.sparse.CompressedVector zero(int length) {
        return new org.la4j.vector.sparse.CompressedVector(length);
    }

    public static org.la4j.vector.sparse.CompressedVector zero(int length, int capacity) {
        return new org.la4j.vector.sparse.CompressedVector(length, capacity);
    }

    public static org.la4j.vector.sparse.CompressedVector random(int length, double density, java.util.Random random) {
        if ((density < 0.0) || (density > 1.0)) {
            throw new java.lang.IllegalArgumentException("The density value should be between 0 and 1.0");
        }
        int cardinality = ((int) (length * density));
        double[] values = new double[cardinality];
        int[] indices = new int[cardinality];
        for (int i = 0; i < cardinality; i++) {
            values[i] = random.nextDouble();
            indices[i] = random.nextInt(length);
        }
        java.util.Arrays.sort(indices);
        return new org.la4j.vector.sparse.CompressedVector(length, cardinality, values, indices);
    }

    public static org.la4j.vector.sparse.CompressedVector fromArray(double[] array) {
        int length = array.length;
        org.la4j.vector.sparse.CompressedVector result = org.la4j.vector.sparse.CompressedVector.zero(length);
        for (int i = 0; i < length; i++) {
            if ((array[i]) != 0.0) {
                result.set(i, array[i]);
            }
        }
        return result;
    }

    public static org.la4j.vector.sparse.CompressedVector fromBinary(byte[] array) {
        java.nio.ByteBuffer buffer = java.nio.ByteBuffer.wrap(array);
        if ((buffer.get()) != (org.la4j.vector.sparse.CompressedVector.VECTOR_TAG)) {
            throw new java.lang.IllegalArgumentException("Can not decode CompressedVector from the given byte array.");
        }
        int length = buffer.getInt();
        int cardinality = buffer.getInt();
        double[] values = new double[cardinality];
        int[] indices = new int[cardinality];
        for (int i = 0; i < cardinality; i++) {
            indices[i] = buffer.getInt();
            values[i] = buffer.getDouble();
        }
        return new org.la4j.vector.sparse.CompressedVector(length, cardinality, values, indices);
    }

    public static org.la4j.vector.sparse.CompressedVector fromCSV(java.lang.String csv) {
        return org.la4j.Vector.fromCSV(csv).to(org.la4j.Vectors.COMPRESSED);
    }

    public static org.la4j.vector.sparse.CompressedVector fromMatrixMarket(java.lang.String mm) {
        return org.la4j.Vector.fromMatrixMarket(mm).to(org.la4j.Vectors.COMPRESSED);
    }

    public static org.la4j.vector.sparse.CompressedVector fromCollection(java.util.Collection<? extends java.lang.Number> list) {
        return org.la4j.Vector.fromCollection(list).to(org.la4j.Vectors.COMPRESSED);
    }

    public static org.la4j.vector.sparse.CompressedVector fromMap(java.util.Map<java.lang.Integer, ? extends java.lang.Number> map, int length) {
        int cardinality = map.size();
        int[] indices = new int[cardinality];
        double[] values = new double[cardinality];
        int i = 0;
        for (java.util.Map.Entry<java.lang.Integer, ? extends java.lang.Number> entry : map.entrySet()) {
            int index = entry.getKey();
            if ((index < 0) || (index >= length)) {
                throw new java.lang.IllegalArgumentException("Check your map: Index must be 0..n-1");
            }
            indices[i] = index;
            values[i] = entry.getValue().doubleValue();
            i++;
        }
        return new org.la4j.vector.sparse.CompressedVector(length, cardinality, values, indices);
    }

    @java.lang.Override
    public double getOrElse(int i, double defaultValue) {
        ensureIndexIsInBounds(i);
        int k = searchForIndex(i);
        if ((k < (cardinality)) && ((indices[k]) == i)) {
            return values[k];
        }
        return defaultValue;
    }

    @java.lang.Override
    public void set(int i, double value) {
        ensureIndexIsInBounds(i);
        int k = searchForIndex(i);
        if ((k < (cardinality)) && ((indices[k]) == i)) {
            if (value != 0.0) {
                values[k] = value;
            }else {
                remove(k);
            }
        }else {
            insert(k, i, value);
        }
    }

    @java.lang.Override
    public void setAll(double value) {
        if (value == 0.0) {
            cardinality = 0;
        }else {
            if ((values.length) < (length)) {
                values = new double[length];
                indices = new int[length];
            }
            for (int i = 0; i < (length); i++) {
                indices[i] = i;
                values[i] = value;
            }
            cardinality = length;
        }
    }

    @java.lang.Override
    public void swapElements(int i, int j) {
        if (i == j) {
            return;
        }
        int ii = searchForIndex(i);
        int jj = searchForIndex(j);
        boolean iiNotZero = (ii < (cardinality)) && (i == (indices[ii]));
        boolean jjNotZero = (jj < (cardinality)) && (j == (indices[jj]));
        if (iiNotZero && jjNotZero) {
            double sd = values[ii];
            values[ii] = values[jj];
            values[jj] = sd;
        }else {
            double notZero = values[(iiNotZero ? ii : jj)];
            int leftIndex = (ii < jj) ? ii : jj;
            int rightIndex = (ii > jj) ? ii : jj;
            if (((iiNotZero && (leftIndex == ii)) || (jjNotZero && (leftIndex == jj))) && (ii != jj)) {
                java.lang.System.arraycopy(values, (leftIndex + 1), values, leftIndex, ((cardinality) - leftIndex));
                java.lang.System.arraycopy(values, (rightIndex - 1), values, rightIndex, ((cardinality) - rightIndex));
                values[(rightIndex - 1)] = notZero;
                java.lang.System.arraycopy(indices, (leftIndex + 1), indices, leftIndex, ((cardinality) - leftIndex));
                java.lang.System.arraycopy(indices, (rightIndex - 1), indices, rightIndex, ((cardinality) - rightIndex));
                indices[(rightIndex - 1)] = (jjNotZero) ? i : j;
            }else
                if ((iiNotZero && (rightIndex == ii)) || (jjNotZero && (rightIndex == jj))) {
                    java.lang.System.arraycopy(values, (rightIndex + 1), values, rightIndex, ((cardinality) - rightIndex));
                    java.lang.System.arraycopy(values, leftIndex, values, (leftIndex + 1), ((cardinality) - leftIndex));
                    values[leftIndex] = notZero;
                    java.lang.System.arraycopy(indices, (rightIndex + 1), indices, rightIndex, ((cardinality) - rightIndex));
                    java.lang.System.arraycopy(indices, leftIndex, indices, (leftIndex + 1), ((cardinality) - leftIndex));
                    indices[leftIndex] = (jjNotZero) ? i : j;
                }

        }
    }

    @java.lang.Override
    public org.la4j.Vector copyOfLength(int length) {
        ensureLengthIsCorrect(length);
        int $cardinality = (length >= (this.length)) ? cardinality : searchForIndex(length);
        int capacity = align(length, $cardinality);
        double[] $values = new double[capacity];
        int[] $indices = new int[capacity];
        java.lang.System.arraycopy(values, 0, $values, 0, $cardinality);
        java.lang.System.arraycopy(indices, 0, $indices, 0, $cardinality);
        return new org.la4j.vector.sparse.CompressedVector(length, $cardinality, $values, $indices);
    }

    @java.lang.Override
    public void each(org.la4j.vector.functor.VectorProcedure procedure) {
        int k = 0;
        for (int i = 0; i < (length); i++) {
            if ((k < (cardinality)) && ((indices[k]) == i)) {
                procedure.apply(i, values[(k++)]);
            }else {
                procedure.apply(i, 0.0);
            }
        }
    }

    @java.lang.Override
    public void eachNonZero(org.la4j.vector.functor.VectorProcedure procedure) {
        for (int i = 0; i < (cardinality); i++) {
            procedure.apply(indices[i], values[i]);
        }
    }

    @java.lang.Override
    public void updateAt(int i, org.la4j.vector.functor.VectorFunction function) {
        int k = searchForIndex(i);
        if ((k < (cardinality)) && ((indices[k]) == i)) {
            double value = function.evaluate(i, values[k]);
            if (value != 0.0) {
                values[k] = value;
            }else {
                remove(k);
            }
        }else {
            insert(k, i, function.evaluate(i, 0.0));
        }
    }

    @java.lang.Override
    public boolean nonZeroAt(int i) {
        int k = searchForIndex(i);
        return (k < (cardinality)) && ((indices[k]) == i);
    }

    @java.lang.Override
    public <T extends org.la4j.Vector> T to(org.la4j.vector.VectorFactory<T> factory) {
        if ((factory.outputClass) == (org.la4j.vector.sparse.CompressedVector.class)) {
            return factory.outputClass.cast(this);
        }
        return super.to(factory);
    }

    @java.lang.Override
    public org.la4j.Vector blankOfLength(int length) {
        return org.la4j.vector.sparse.CompressedVector.zero(length);
    }

    @java.lang.Override
    public byte[] toBinary() {
        int size = (((1 + 4) + 4) + (8 * (cardinality))) + (8 * (cardinality));
        java.nio.ByteBuffer buffer = java.nio.ByteBuffer.allocate(size);
        buffer.put(org.la4j.vector.sparse.CompressedVector.VECTOR_TAG);
        buffer.putInt(length);
        buffer.putInt(cardinality);
        for (int i = 0; i < (cardinality); i++) {
            buffer.putInt(indices[i]);
            buffer.putDouble(values[i]);
        }
        return buffer.array();
    }

    private int searchForIndex(int i) {
        if (((cardinality) == 0) || (i > (indices[((cardinality) - 1)]))) {
            return cardinality;
        }
        int left = 0;
        int right = cardinality;
        while (left < right) {
            int p = (left + right) / 2;
            if ((indices[p]) > i) {
                right = p;
            }else
                if ((indices[p]) < i) {
                    left = p + 1;
                }else {
                    return p;
                }

        } 
        return left;
    }

    private void insert(int k, int i, double value) {
        if (value == 0.0) {
            return;
        }
        if ((values.length) < ((cardinality) + 1)) {
            growUp();
        }
        if (((cardinality) - k) > 0) {
            java.lang.System.arraycopy(values, k, values, (k + 1), ((cardinality) - k));
            java.lang.System.arraycopy(indices, k, indices, (k + 1), ((cardinality) - k));
        }
        values[k] = value;
        indices[k] = i;
        (cardinality)++;
    }

    private void remove(int k) {
        (cardinality)--;
        if (((cardinality) - k) > 0) {
            java.lang.System.arraycopy(values, (k + 1), values, k, ((cardinality) - k));
            java.lang.System.arraycopy(indices, (k + 1), indices, k, ((cardinality) - k));
        }
    }

    private void growUp() {
        if ((values.length) == (length)) {
            throw new java.lang.IllegalStateException("This vector can't grow up.");
        }
        int capacity = java.lang.Math.min(length, ((((cardinality) * 3) / 2) + 1));
        double[] $values = new double[capacity];
        int[] $indices = new int[capacity];
        java.lang.System.arraycopy(values, 0, $values, 0, cardinality);
        java.lang.System.arraycopy(indices, 0, $indices, 0, cardinality);
        values = $values;
        indices = $indices;
    }

    private int align(int length, int capacity) {
        if (capacity < 0) {
            fail((("Cardinality should be positive: " + capacity) + "."));
        }
        if (capacity > length) {
            fail((("Cardinality should be less then or equal to capacity: " + capacity) + "."));
        }
        return java.lang.Math.min(length, (((capacity / (org.la4j.vector.sparse.CompressedVector.MINIMUM_SIZE)) + 1) * (org.la4j.vector.sparse.CompressedVector.MINIMUM_SIZE)));
    }

    @java.lang.Override
    public org.la4j.iterator.VectorIterator nonZeroIterator() {
        return new org.la4j.iterator.VectorIterator(length) {
            private boolean currentIsRemoved = false;

            private int k = -1;

            private int removedIndex = -1;

            @java.lang.Override
            public int index() {
                return currentIsRemoved ? removedIndex : indices[k];
            }

            @java.lang.Override
            public double get() {
                return currentIsRemoved ? 0.0 : values[k];
            }

            @java.lang.Override
            public void set(double value) {
                if ((value == 0.0) && (!(currentIsRemoved))) {
                    currentIsRemoved = true;
                    removedIndex = indices[k];
                    org.la4j.vector.sparse.CompressedVector.this.remove(((k)--));
                }else
                    if ((value != 0.0) && (!(currentIsRemoved))) {
                        values[k] = value;
                    }else {
                        currentIsRemoved = false;
                        org.la4j.vector.sparse.CompressedVector.this.insert((++(k)), removedIndex, value);
                    }

            }

            @java.lang.Override
            public boolean hasNext() {
                return ((k) + 1) < (cardinality);
            }

            @java.lang.Override
            public java.lang.Double next() {
                if (!(hasNext())) {
                    throw new java.util.NoSuchElementException();
                }
                currentIsRemoved = false;
                return values[(++(k))];
            }
        };
    }

    @java.lang.Override
    public org.la4j.iterator.VectorIterator iterator() {
        return new org.la4j.iterator.VectorIterator(length) {
            private int k = 0;

            private int i = -1;

            private boolean currentNonZero = false;

            @java.lang.Override
            public int index() {
                return i;
            }

            @java.lang.Override
            public double get() {
                return currentNonZero ? values[k] : 0.0;
            }

            @java.lang.Override
            public void set(double value) {
                if (currentNonZero) {
                    if (value == 0.0) {
                        org.la4j.vector.sparse.CompressedVector.this.remove(k);
                        currentNonZero = false;
                    }else {
                        values[k] = value;
                    }
                }else {
                    org.la4j.vector.sparse.CompressedVector.this.insert(k, i, value);
                    currentNonZero = true;
                }
            }

            @java.lang.Override
            public boolean hasNext() {
                return ((i) + 1) < (length);
            }

            @java.lang.Override
            public java.lang.Double next() {
                if (!(hasNext())) {
                    throw new java.util.NoSuchElementException();
                }
                boolean spoonDefaultValue = false;
                try {
                    spoonDefaultValue = currentNonZero;
                } catch (java.lang.Exception __NopolProcessorException) {
                }
                boolean runtimeAngelicValue = fr.inria.lille.repair.nopol.synth.AngelicExecution.angelicValue(spoonDefaultValue);
                if (fr.inria.lille.commons.trace.RuntimeValues.instance(6).isEnabled()) {
                    fr.inria.lille.commons.trace.RuntimeValues.instance(6).collectionStarts();
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(6).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.k",org.la4j.vector.sparse.CompressedVector.2.this.k);} catch (Exception ex1) {ex1.printStackTrace();};
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(6).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero",org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero);} catch (Exception ex1) {ex1.printStackTrace();};
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(6).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.i",org.la4j.vector.sparse.CompressedVector.2.this.i);} catch (Exception ex1) {ex1.printStackTrace();};
                    fr.inria.lille.commons.trace.RuntimeValues.instance(6).collectOutput(runtimeAngelicValue);
                    fr.inria.lille.commons.trace.RuntimeValues.instance(6).collectionEnds();
                }
                if (runtimeAngelicValue) {
                    (k)++;
                }
                (i)++;
                currentNonZero = ((k) < (cardinality)) && ((indices[k]) == (i));
                return get();
            }
        };
    }
}
18:09:11.463 [pool-2-thread-1] ERROR fr.inria.lille.repair.nopol.NoPol - Error ExecutionException java.util.concurrent.ExecutionException: xxl.java.compiler.DynamicCompilationException: Aborting: dynamic compilation failed
18:09:11.463 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - statement #26
18:09:11.464 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - Analysing SourceLocation org.la4j.vector.sparse.CompressedVector$2:615 which is executed by 5 tests
1164465221
18:09:11.555 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - looking with class fr.inria.lille.repair.nopol.spoon.smt.ConditionalAdder
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
18:09:11.651 [pool-26-thread-1] INFO  xxl.java.junit.TestCasesListener - Tests run finished (84 ms)
<> Total tests run: 143
<> Ignored tests: 0
<> Failed tests: 2
~ testFromMap_unordered(org.la4j.vector.sparse.CompressedVectorTest)
[expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>]
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
~ testFromMap_unordered(org.la4j.vector.dense.BasicVectorTest)
[expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>]
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)

18:09:12.330 [pool-25-thread-1] ERROR x.java.compiler.DynamicClassCompiler - [Compilation errors]
CompressedVector.java:437: error: ')' expected
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(7).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.k",org.la4j.vector.sparse.CompressedVector.2.this.k);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                      ^
CompressedVector.java:437: error: illegal start of expression
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(7).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.k",org.la4j.vector.sparse.CompressedVector.2.this.k);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                        ^
CompressedVector.java:437: error: ';' expected
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(7).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.k",org.la4j.vector.sparse.CompressedVector.2.this.k);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                         ^
CompressedVector.java:437: error: illegal start of expression
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(7).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.k",org.la4j.vector.sparse.CompressedVector.2.this.k);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                             ^
CompressedVector.java:437: error: ';' expected
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(7).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.k",org.la4j.vector.sparse.CompressedVector.2.this.k);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                               ^
CompressedVector.java:438: error: ')' expected
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(7).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero",org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                                   ^
CompressedVector.java:438: error: illegal start of expression
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(7).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero",org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                                     ^
CompressedVector.java:438: error: ';' expected
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(7).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero",org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                                      ^
CompressedVector.java:438: error: illegal start of expression
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(7).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero",org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                                          ^
CompressedVector.java:438: error: ';' expected
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(7).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero",org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                                                         ^
CompressedVector.java:439: error: ')' expected
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(7).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.i",org.la4j.vector.sparse.CompressedVector.2.this.i);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                      ^
CompressedVector.java:439: error: illegal start of expression
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(7).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.i",org.la4j.vector.sparse.CompressedVector.2.this.i);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                        ^
CompressedVector.java:439: error: ';' expected
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(7).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.i",org.la4j.vector.sparse.CompressedVector.2.this.i);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                         ^
CompressedVector.java:439: error: illegal start of expression
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(7).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.i",org.la4j.vector.sparse.CompressedVector.2.this.i);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                             ^
CompressedVector.java:439: error: ';' expected
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(7).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.i",org.la4j.vector.sparse.CompressedVector.2.this.i);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                               ^
18:09:12.832 [pool-25-thread-1] ERROR f.i.l.r.n.s.ConstraintModelBuilder - Unable to compile the change: 
public class CompressedVector extends org.la4j.vector.SparseVector {
    private static final byte VECTOR_TAG = ((byte) (16));

    private static final int MINIMUM_SIZE = 32;

    private double[] values;

    private int[] indices;

    public CompressedVector() {
        this(0);
    }

    public CompressedVector(int length) {
        this(length, 0);
    }

    public CompressedVector(int length, int capacity) {
        super(length);
        int alignedSize = align(length, capacity);
        this.values = new double[alignedSize];
        this.indices = new int[alignedSize];
    }

    public CompressedVector(int length, int cardinality, double[] values, int[] indices) {
        super(length, cardinality);
        this.values = values;
        this.indices = indices;
    }

    public static org.la4j.vector.sparse.CompressedVector zero(int length) {
        return new org.la4j.vector.sparse.CompressedVector(length);
    }

    public static org.la4j.vector.sparse.CompressedVector zero(int length, int capacity) {
        return new org.la4j.vector.sparse.CompressedVector(length, capacity);
    }

    public static org.la4j.vector.sparse.CompressedVector random(int length, double density, java.util.Random random) {
        if ((density < 0.0) || (density > 1.0)) {
            throw new java.lang.IllegalArgumentException("The density value should be between 0 and 1.0");
        }
        int cardinality = ((int) (length * density));
        double[] values = new double[cardinality];
        int[] indices = new int[cardinality];
        for (int i = 0; i < cardinality; i++) {
            values[i] = random.nextDouble();
            indices[i] = random.nextInt(length);
        }
        java.util.Arrays.sort(indices);
        return new org.la4j.vector.sparse.CompressedVector(length, cardinality, values, indices);
    }

    public static org.la4j.vector.sparse.CompressedVector fromArray(double[] array) {
        int length = array.length;
        org.la4j.vector.sparse.CompressedVector result = org.la4j.vector.sparse.CompressedVector.zero(length);
        for (int i = 0; i < length; i++) {
            if ((array[i]) != 0.0) {
                result.set(i, array[i]);
            }
        }
        return result;
    }

    public static org.la4j.vector.sparse.CompressedVector fromBinary(byte[] array) {
        java.nio.ByteBuffer buffer = java.nio.ByteBuffer.wrap(array);
        if ((buffer.get()) != (org.la4j.vector.sparse.CompressedVector.VECTOR_TAG)) {
            throw new java.lang.IllegalArgumentException("Can not decode CompressedVector from the given byte array.");
        }
        int length = buffer.getInt();
        int cardinality = buffer.getInt();
        double[] values = new double[cardinality];
        int[] indices = new int[cardinality];
        for (int i = 0; i < cardinality; i++) {
            indices[i] = buffer.getInt();
            values[i] = buffer.getDouble();
        }
        return new org.la4j.vector.sparse.CompressedVector(length, cardinality, values, indices);
    }

    public static org.la4j.vector.sparse.CompressedVector fromCSV(java.lang.String csv) {
        return org.la4j.Vector.fromCSV(csv).to(org.la4j.Vectors.COMPRESSED);
    }

    public static org.la4j.vector.sparse.CompressedVector fromMatrixMarket(java.lang.String mm) {
        return org.la4j.Vector.fromMatrixMarket(mm).to(org.la4j.Vectors.COMPRESSED);
    }

    public static org.la4j.vector.sparse.CompressedVector fromCollection(java.util.Collection<? extends java.lang.Number> list) {
        return org.la4j.Vector.fromCollection(list).to(org.la4j.Vectors.COMPRESSED);
    }

    public static org.la4j.vector.sparse.CompressedVector fromMap(java.util.Map<java.lang.Integer, ? extends java.lang.Number> map, int length) {
        int cardinality = map.size();
        int[] indices = new int[cardinality];
        double[] values = new double[cardinality];
        int i = 0;
        for (java.util.Map.Entry<java.lang.Integer, ? extends java.lang.Number> entry : map.entrySet()) {
            int index = entry.getKey();
            if ((index < 0) || (index >= length)) {
                throw new java.lang.IllegalArgumentException("Check your map: Index must be 0..n-1");
            }
            indices[i] = index;
            values[i] = entry.getValue().doubleValue();
            i++;
        }
        return new org.la4j.vector.sparse.CompressedVector(length, cardinality, values, indices);
    }

    @java.lang.Override
    public double getOrElse(int i, double defaultValue) {
        ensureIndexIsInBounds(i);
        int k = searchForIndex(i);
        if ((k < (cardinality)) && ((indices[k]) == i)) {
            return values[k];
        }
        return defaultValue;
    }

    @java.lang.Override
    public void set(int i, double value) {
        ensureIndexIsInBounds(i);
        int k = searchForIndex(i);
        if ((k < (cardinality)) && ((indices[k]) == i)) {
            if (value != 0.0) {
                values[k] = value;
            }else {
                remove(k);
            }
        }else {
            insert(k, i, value);
        }
    }

    @java.lang.Override
    public void setAll(double value) {
        if (value == 0.0) {
            cardinality = 0;
        }else {
            if ((values.length) < (length)) {
                values = new double[length];
                indices = new int[length];
            }
            for (int i = 0; i < (length); i++) {
                indices[i] = i;
                values[i] = value;
            }
            cardinality = length;
        }
    }

    @java.lang.Override
    public void swapElements(int i, int j) {
        if (i == j) {
            return;
        }
        int ii = searchForIndex(i);
        int jj = searchForIndex(j);
        boolean iiNotZero = (ii < (cardinality)) && (i == (indices[ii]));
        boolean jjNotZero = (jj < (cardinality)) && (j == (indices[jj]));
        if (iiNotZero && jjNotZero) {
            double sd = values[ii];
            values[ii] = values[jj];
            values[jj] = sd;
        }else {
            double notZero = values[(iiNotZero ? ii : jj)];
            int leftIndex = (ii < jj) ? ii : jj;
            int rightIndex = (ii > jj) ? ii : jj;
            if (((iiNotZero && (leftIndex == ii)) || (jjNotZero && (leftIndex == jj))) && (ii != jj)) {
                java.lang.System.arraycopy(values, (leftIndex + 1), values, leftIndex, ((cardinality) - leftIndex));
                java.lang.System.arraycopy(values, (rightIndex - 1), values, rightIndex, ((cardinality) - rightIndex));
                values[(rightIndex - 1)] = notZero;
                java.lang.System.arraycopy(indices, (leftIndex + 1), indices, leftIndex, ((cardinality) - leftIndex));
                java.lang.System.arraycopy(indices, (rightIndex - 1), indices, rightIndex, ((cardinality) - rightIndex));
                indices[(rightIndex - 1)] = (jjNotZero) ? i : j;
            }else
                if ((iiNotZero && (rightIndex == ii)) || (jjNotZero && (rightIndex == jj))) {
                    java.lang.System.arraycopy(values, (rightIndex + 1), values, rightIndex, ((cardinality) - rightIndex));
                    java.lang.System.arraycopy(values, leftIndex, values, (leftIndex + 1), ((cardinality) - leftIndex));
                    values[leftIndex] = notZero;
                    java.lang.System.arraycopy(indices, (rightIndex + 1), indices, rightIndex, ((cardinality) - rightIndex));
                    java.lang.System.arraycopy(indices, leftIndex, indices, (leftIndex + 1), ((cardinality) - leftIndex));
                    indices[leftIndex] = (jjNotZero) ? i : j;
                }

        }
    }

    @java.lang.Override
    public org.la4j.Vector copyOfLength(int length) {
        ensureLengthIsCorrect(length);
        int $cardinality = (length >= (this.length)) ? cardinality : searchForIndex(length);
        int capacity = align(length, $cardinality);
        double[] $values = new double[capacity];
        int[] $indices = new int[capacity];
        java.lang.System.arraycopy(values, 0, $values, 0, $cardinality);
        java.lang.System.arraycopy(indices, 0, $indices, 0, $cardinality);
        return new org.la4j.vector.sparse.CompressedVector(length, $cardinality, $values, $indices);
    }

    @java.lang.Override
    public void each(org.la4j.vector.functor.VectorProcedure procedure) {
        int k = 0;
        for (int i = 0; i < (length); i++) {
            if ((k < (cardinality)) && ((indices[k]) == i)) {
                procedure.apply(i, values[(k++)]);
            }else {
                procedure.apply(i, 0.0);
            }
        }
    }

    @java.lang.Override
    public void eachNonZero(org.la4j.vector.functor.VectorProcedure procedure) {
        for (int i = 0; i < (cardinality); i++) {
            procedure.apply(indices[i], values[i]);
        }
    }

    @java.lang.Override
    public void updateAt(int i, org.la4j.vector.functor.VectorFunction function) {
        int k = searchForIndex(i);
        if ((k < (cardinality)) && ((indices[k]) == i)) {
            double value = function.evaluate(i, values[k]);
            if (value != 0.0) {
                values[k] = value;
            }else {
                remove(k);
            }
        }else {
            insert(k, i, function.evaluate(i, 0.0));
        }
    }

    @java.lang.Override
    public boolean nonZeroAt(int i) {
        int k = searchForIndex(i);
        return (k < (cardinality)) && ((indices[k]) == i);
    }

    @java.lang.Override
    public <T extends org.la4j.Vector> T to(org.la4j.vector.VectorFactory<T> factory) {
        if ((factory.outputClass) == (org.la4j.vector.sparse.CompressedVector.class)) {
            return factory.outputClass.cast(this);
        }
        return super.to(factory);
    }

    @java.lang.Override
    public org.la4j.Vector blankOfLength(int length) {
        return org.la4j.vector.sparse.CompressedVector.zero(length);
    }

    @java.lang.Override
    public byte[] toBinary() {
        int size = (((1 + 4) + 4) + (8 * (cardinality))) + (8 * (cardinality));
        java.nio.ByteBuffer buffer = java.nio.ByteBuffer.allocate(size);
        buffer.put(org.la4j.vector.sparse.CompressedVector.VECTOR_TAG);
        buffer.putInt(length);
        buffer.putInt(cardinality);
        for (int i = 0; i < (cardinality); i++) {
            buffer.putInt(indices[i]);
            buffer.putDouble(values[i]);
        }
        return buffer.array();
    }

    private int searchForIndex(int i) {
        if (((cardinality) == 0) || (i > (indices[((cardinality) - 1)]))) {
            return cardinality;
        }
        int left = 0;
        int right = cardinality;
        while (left < right) {
            int p = (left + right) / 2;
            if ((indices[p]) > i) {
                right = p;
            }else
                if ((indices[p]) < i) {
                    left = p + 1;
                }else {
                    return p;
                }

        } 
        return left;
    }

    private void insert(int k, int i, double value) {
        if (value == 0.0) {
            return;
        }
        if ((values.length) < ((cardinality) + 1)) {
            growUp();
        }
        if (((cardinality) - k) > 0) {
            java.lang.System.arraycopy(values, k, values, (k + 1), ((cardinality) - k));
            java.lang.System.arraycopy(indices, k, indices, (k + 1), ((cardinality) - k));
        }
        values[k] = value;
        indices[k] = i;
        (cardinality)++;
    }

    private void remove(int k) {
        (cardinality)--;
        if (((cardinality) - k) > 0) {
            java.lang.System.arraycopy(values, (k + 1), values, k, ((cardinality) - k));
            java.lang.System.arraycopy(indices, (k + 1), indices, k, ((cardinality) - k));
        }
    }

    private void growUp() {
        if ((values.length) == (length)) {
            throw new java.lang.IllegalStateException("This vector can't grow up.");
        }
        int capacity = java.lang.Math.min(length, ((((cardinality) * 3) / 2) + 1));
        double[] $values = new double[capacity];
        int[] $indices = new int[capacity];
        java.lang.System.arraycopy(values, 0, $values, 0, cardinality);
        java.lang.System.arraycopy(indices, 0, $indices, 0, cardinality);
        values = $values;
        indices = $indices;
    }

    private int align(int length, int capacity) {
        if (capacity < 0) {
            fail((("Cardinality should be positive: " + capacity) + "."));
        }
        if (capacity > length) {
            fail((("Cardinality should be less then or equal to capacity: " + capacity) + "."));
        }
        return java.lang.Math.min(length, (((capacity / (org.la4j.vector.sparse.CompressedVector.MINIMUM_SIZE)) + 1) * (org.la4j.vector.sparse.CompressedVector.MINIMUM_SIZE)));
    }

    @java.lang.Override
    public org.la4j.iterator.VectorIterator nonZeroIterator() {
        return new org.la4j.iterator.VectorIterator(length) {
            private boolean currentIsRemoved = false;

            private int k = -1;

            private int removedIndex = -1;

            @java.lang.Override
            public int index() {
                return currentIsRemoved ? removedIndex : indices[k];
            }

            @java.lang.Override
            public double get() {
                return currentIsRemoved ? 0.0 : values[k];
            }

            @java.lang.Override
            public void set(double value) {
                if ((value == 0.0) && (!(currentIsRemoved))) {
                    currentIsRemoved = true;
                    removedIndex = indices[k];
                    org.la4j.vector.sparse.CompressedVector.this.remove(((k)--));
                }else
                    if ((value != 0.0) && (!(currentIsRemoved))) {
                        values[k] = value;
                    }else {
                        currentIsRemoved = false;
                        org.la4j.vector.sparse.CompressedVector.this.insert((++(k)), removedIndex, value);
                    }

            }

            @java.lang.Override
            public boolean hasNext() {
                return ((k) + 1) < (cardinality);
            }

            @java.lang.Override
            public java.lang.Double next() {
                if (!(hasNext())) {
                    throw new java.util.NoSuchElementException();
                }
                currentIsRemoved = false;
                return values[(++(k))];
            }
        };
    }

    @java.lang.Override
    public org.la4j.iterator.VectorIterator iterator() {
        return new org.la4j.iterator.VectorIterator(length) {
            private int k = 0;

            private int i = -1;

            private boolean currentNonZero = false;

            @java.lang.Override
            public int index() {
                return i;
            }

            @java.lang.Override
            public double get() {
                return currentNonZero ? values[k] : 0.0;
            }

            @java.lang.Override
            public void set(double value) {
                if (currentNonZero) {
                    if (value == 0.0) {
                        org.la4j.vector.sparse.CompressedVector.this.remove(k);
                        currentNonZero = false;
                    }else {
                        values[k] = value;
                    }
                }else {
                    org.la4j.vector.sparse.CompressedVector.this.insert(k, i, value);
                    currentNonZero = true;
                }
            }

            @java.lang.Override
            public boolean hasNext() {
                return ((i) + 1) < (length);
            }

            @java.lang.Override
            public java.lang.Double next() {
                boolean spoonDefaultValue = false;
                try {
                    spoonDefaultValue = true;
                } catch (java.lang.Exception __NopolProcessorException) {
                }
                boolean runtimeAngelicValue = fr.inria.lille.repair.nopol.synth.AngelicExecution.angelicValue(spoonDefaultValue);
                if (fr.inria.lille.commons.trace.RuntimeValues.instance(7).isEnabled()) {
                    fr.inria.lille.commons.trace.RuntimeValues.instance(7).collectionStarts();
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(7).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.k",org.la4j.vector.sparse.CompressedVector.2.this.k);} catch (Exception ex1) {ex1.printStackTrace();};
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(7).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero",org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero);} catch (Exception ex1) {ex1.printStackTrace();};
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(7).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.i",org.la4j.vector.sparse.CompressedVector.2.this.i);} catch (Exception ex1) {ex1.printStackTrace();};
                    fr.inria.lille.commons.trace.RuntimeValues.instance(7).collectOutput(runtimeAngelicValue);
                    fr.inria.lille.commons.trace.RuntimeValues.instance(7).collectionEnds();
                }
                if (runtimeAngelicValue) if (!(hasNext())) {
                    throw new java.util.NoSuchElementException();
                }
                if (currentNonZero) {
                    (k)++;
                }
                (i)++;
                currentNonZero = ((k) < (cardinality)) && ((indices[k]) == (i));
                return get();
            }
        };
    }
}
18:09:12.833 [pool-2-thread-1] ERROR fr.inria.lille.repair.nopol.NoPol - Error ExecutionException java.util.concurrent.ExecutionException: xxl.java.compiler.DynamicCompilationException: Aborting: dynamic compilation failed
18:09:12.833 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - looking with class fr.inria.lille.repair.nopol.spoon.smt.ConditionalReplacer
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
18:09:12.917 [pool-28-thread-1] INFO  xxl.java.junit.TestCasesListener - Tests run finished (74 ms)
<> Total tests run: 143
<> Ignored tests: 0
<> Failed tests: 2
~ testFromMap_unordered(org.la4j.vector.sparse.CompressedVectorTest)
[expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>]
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
~ testFromMap_unordered(org.la4j.vector.dense.BasicVectorTest)
[expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>]
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)

18:09:13.759 [pool-27-thread-1] ERROR x.java.compiler.DynamicClassCompiler - [Compilation errors]
CompressedVector.java:437: error: ')' expected
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(8).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.k",org.la4j.vector.sparse.CompressedVector.2.this.k);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                      ^
CompressedVector.java:437: error: illegal start of expression
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(8).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.k",org.la4j.vector.sparse.CompressedVector.2.this.k);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                        ^
CompressedVector.java:437: error: ';' expected
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(8).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.k",org.la4j.vector.sparse.CompressedVector.2.this.k);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                         ^
CompressedVector.java:437: error: illegal start of expression
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(8).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.k",org.la4j.vector.sparse.CompressedVector.2.this.k);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                             ^
CompressedVector.java:437: error: ';' expected
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(8).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.k",org.la4j.vector.sparse.CompressedVector.2.this.k);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                               ^
CompressedVector.java:438: error: ')' expected
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(8).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero",org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                                   ^
CompressedVector.java:438: error: illegal start of expression
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(8).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero",org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                                     ^
CompressedVector.java:438: error: ';' expected
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(8).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero",org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                                      ^
CompressedVector.java:438: error: illegal start of expression
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(8).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero",org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                                          ^
CompressedVector.java:438: error: ';' expected
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(8).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero",org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                                                         ^
CompressedVector.java:439: error: ')' expected
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(8).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.i",org.la4j.vector.sparse.CompressedVector.2.this.i);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                      ^
CompressedVector.java:439: error: illegal start of expression
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(8).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.i",org.la4j.vector.sparse.CompressedVector.2.this.i);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                        ^
CompressedVector.java:439: error: ';' expected
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(8).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.i",org.la4j.vector.sparse.CompressedVector.2.this.i);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                         ^
CompressedVector.java:439: error: illegal start of expression
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(8).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.i",org.la4j.vector.sparse.CompressedVector.2.this.i);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                             ^
CompressedVector.java:439: error: ';' expected
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(8).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.i",org.la4j.vector.sparse.CompressedVector.2.this.i);} catch (Exception ex1) {ex1.printStackTrace();};
                                                                                                                                                                                               ^
18:09:14.267 [pool-27-thread-1] ERROR f.i.l.r.n.s.ConstraintModelBuilder - Unable to compile the change: 
public class CompressedVector extends org.la4j.vector.SparseVector {
    private static final byte VECTOR_TAG = ((byte) (16));

    private static final int MINIMUM_SIZE = 32;

    private double[] values;

    private int[] indices;

    public CompressedVector() {
        this(0);
    }

    public CompressedVector(int length) {
        this(length, 0);
    }

    public CompressedVector(int length, int capacity) {
        super(length);
        int alignedSize = align(length, capacity);
        this.values = new double[alignedSize];
        this.indices = new int[alignedSize];
    }

    public CompressedVector(int length, int cardinality, double[] values, int[] indices) {
        super(length, cardinality);
        this.values = values;
        this.indices = indices;
    }

    public static org.la4j.vector.sparse.CompressedVector zero(int length) {
        return new org.la4j.vector.sparse.CompressedVector(length);
    }

    public static org.la4j.vector.sparse.CompressedVector zero(int length, int capacity) {
        return new org.la4j.vector.sparse.CompressedVector(length, capacity);
    }

    public static org.la4j.vector.sparse.CompressedVector random(int length, double density, java.util.Random random) {
        if ((density < 0.0) || (density > 1.0)) {
            throw new java.lang.IllegalArgumentException("The density value should be between 0 and 1.0");
        }
        int cardinality = ((int) (length * density));
        double[] values = new double[cardinality];
        int[] indices = new int[cardinality];
        for (int i = 0; i < cardinality; i++) {
            values[i] = random.nextDouble();
            indices[i] = random.nextInt(length);
        }
        java.util.Arrays.sort(indices);
        return new org.la4j.vector.sparse.CompressedVector(length, cardinality, values, indices);
    }

    public static org.la4j.vector.sparse.CompressedVector fromArray(double[] array) {
        int length = array.length;
        org.la4j.vector.sparse.CompressedVector result = org.la4j.vector.sparse.CompressedVector.zero(length);
        for (int i = 0; i < length; i++) {
            if ((array[i]) != 0.0) {
                result.set(i, array[i]);
            }
        }
        return result;
    }

    public static org.la4j.vector.sparse.CompressedVector fromBinary(byte[] array) {
        java.nio.ByteBuffer buffer = java.nio.ByteBuffer.wrap(array);
        if ((buffer.get()) != (org.la4j.vector.sparse.CompressedVector.VECTOR_TAG)) {
            throw new java.lang.IllegalArgumentException("Can not decode CompressedVector from the given byte array.");
        }
        int length = buffer.getInt();
        int cardinality = buffer.getInt();
        double[] values = new double[cardinality];
        int[] indices = new int[cardinality];
        for (int i = 0; i < cardinality; i++) {
            indices[i] = buffer.getInt();
            values[i] = buffer.getDouble();
        }
        return new org.la4j.vector.sparse.CompressedVector(length, cardinality, values, indices);
    }

    public static org.la4j.vector.sparse.CompressedVector fromCSV(java.lang.String csv) {
        return org.la4j.Vector.fromCSV(csv).to(org.la4j.Vectors.COMPRESSED);
    }

    public static org.la4j.vector.sparse.CompressedVector fromMatrixMarket(java.lang.String mm) {
        return org.la4j.Vector.fromMatrixMarket(mm).to(org.la4j.Vectors.COMPRESSED);
    }

    public static org.la4j.vector.sparse.CompressedVector fromCollection(java.util.Collection<? extends java.lang.Number> list) {
        return org.la4j.Vector.fromCollection(list).to(org.la4j.Vectors.COMPRESSED);
    }

    public static org.la4j.vector.sparse.CompressedVector fromMap(java.util.Map<java.lang.Integer, ? extends java.lang.Number> map, int length) {
        int cardinality = map.size();
        int[] indices = new int[cardinality];
        double[] values = new double[cardinality];
        int i = 0;
        for (java.util.Map.Entry<java.lang.Integer, ? extends java.lang.Number> entry : map.entrySet()) {
            int index = entry.getKey();
            if ((index < 0) || (index >= length)) {
                throw new java.lang.IllegalArgumentException("Check your map: Index must be 0..n-1");
            }
            indices[i] = index;
            values[i] = entry.getValue().doubleValue();
            i++;
        }
        return new org.la4j.vector.sparse.CompressedVector(length, cardinality, values, indices);
    }

    @java.lang.Override
    public double getOrElse(int i, double defaultValue) {
        ensureIndexIsInBounds(i);
        int k = searchForIndex(i);
        if ((k < (cardinality)) && ((indices[k]) == i)) {
            return values[k];
        }
        return defaultValue;
    }

    @java.lang.Override
    public void set(int i, double value) {
        ensureIndexIsInBounds(i);
        int k = searchForIndex(i);
        if ((k < (cardinality)) && ((indices[k]) == i)) {
            if (value != 0.0) {
                values[k] = value;
            }else {
                remove(k);
            }
        }else {
            insert(k, i, value);
        }
    }

    @java.lang.Override
    public void setAll(double value) {
        if (value == 0.0) {
            cardinality = 0;
        }else {
            if ((values.length) < (length)) {
                values = new double[length];
                indices = new int[length];
            }
            for (int i = 0; i < (length); i++) {
                indices[i] = i;
                values[i] = value;
            }
            cardinality = length;
        }
    }

    @java.lang.Override
    public void swapElements(int i, int j) {
        if (i == j) {
            return;
        }
        int ii = searchForIndex(i);
        int jj = searchForIndex(j);
        boolean iiNotZero = (ii < (cardinality)) && (i == (indices[ii]));
        boolean jjNotZero = (jj < (cardinality)) && (j == (indices[jj]));
        if (iiNotZero && jjNotZero) {
            double sd = values[ii];
            values[ii] = values[jj];
            values[jj] = sd;
        }else {
            double notZero = values[(iiNotZero ? ii : jj)];
            int leftIndex = (ii < jj) ? ii : jj;
            int rightIndex = (ii > jj) ? ii : jj;
            if (((iiNotZero && (leftIndex == ii)) || (jjNotZero && (leftIndex == jj))) && (ii != jj)) {
                java.lang.System.arraycopy(values, (leftIndex + 1), values, leftIndex, ((cardinality) - leftIndex));
                java.lang.System.arraycopy(values, (rightIndex - 1), values, rightIndex, ((cardinality) - rightIndex));
                values[(rightIndex - 1)] = notZero;
                java.lang.System.arraycopy(indices, (leftIndex + 1), indices, leftIndex, ((cardinality) - leftIndex));
                java.lang.System.arraycopy(indices, (rightIndex - 1), indices, rightIndex, ((cardinality) - rightIndex));
                indices[(rightIndex - 1)] = (jjNotZero) ? i : j;
            }else
                if ((iiNotZero && (rightIndex == ii)) || (jjNotZero && (rightIndex == jj))) {
                    java.lang.System.arraycopy(values, (rightIndex + 1), values, rightIndex, ((cardinality) - rightIndex));
                    java.lang.System.arraycopy(values, leftIndex, values, (leftIndex + 1), ((cardinality) - leftIndex));
                    values[leftIndex] = notZero;
                    java.lang.System.arraycopy(indices, (rightIndex + 1), indices, rightIndex, ((cardinality) - rightIndex));
                    java.lang.System.arraycopy(indices, leftIndex, indices, (leftIndex + 1), ((cardinality) - leftIndex));
                    indices[leftIndex] = (jjNotZero) ? i : j;
                }

        }
    }

    @java.lang.Override
    public org.la4j.Vector copyOfLength(int length) {
        ensureLengthIsCorrect(length);
        int $cardinality = (length >= (this.length)) ? cardinality : searchForIndex(length);
        int capacity = align(length, $cardinality);
        double[] $values = new double[capacity];
        int[] $indices = new int[capacity];
        java.lang.System.arraycopy(values, 0, $values, 0, $cardinality);
        java.lang.System.arraycopy(indices, 0, $indices, 0, $cardinality);
        return new org.la4j.vector.sparse.CompressedVector(length, $cardinality, $values, $indices);
    }

    @java.lang.Override
    public void each(org.la4j.vector.functor.VectorProcedure procedure) {
        int k = 0;
        for (int i = 0; i < (length); i++) {
            if ((k < (cardinality)) && ((indices[k]) == i)) {
                procedure.apply(i, values[(k++)]);
            }else {
                procedure.apply(i, 0.0);
            }
        }
    }

    @java.lang.Override
    public void eachNonZero(org.la4j.vector.functor.VectorProcedure procedure) {
        for (int i = 0; i < (cardinality); i++) {
            procedure.apply(indices[i], values[i]);
        }
    }

    @java.lang.Override
    public void updateAt(int i, org.la4j.vector.functor.VectorFunction function) {
        int k = searchForIndex(i);
        if ((k < (cardinality)) && ((indices[k]) == i)) {
            double value = function.evaluate(i, values[k]);
            if (value != 0.0) {
                values[k] = value;
            }else {
                remove(k);
            }
        }else {
            insert(k, i, function.evaluate(i, 0.0));
        }
    }

    @java.lang.Override
    public boolean nonZeroAt(int i) {
        int k = searchForIndex(i);
        return (k < (cardinality)) && ((indices[k]) == i);
    }

    @java.lang.Override
    public <T extends org.la4j.Vector> T to(org.la4j.vector.VectorFactory<T> factory) {
        if ((factory.outputClass) == (org.la4j.vector.sparse.CompressedVector.class)) {
            return factory.outputClass.cast(this);
        }
        return super.to(factory);
    }

    @java.lang.Override
    public org.la4j.Vector blankOfLength(int length) {
        return org.la4j.vector.sparse.CompressedVector.zero(length);
    }

    @java.lang.Override
    public byte[] toBinary() {
        int size = (((1 + 4) + 4) + (8 * (cardinality))) + (8 * (cardinality));
        java.nio.ByteBuffer buffer = java.nio.ByteBuffer.allocate(size);
        buffer.put(org.la4j.vector.sparse.CompressedVector.VECTOR_TAG);
        buffer.putInt(length);
        buffer.putInt(cardinality);
        for (int i = 0; i < (cardinality); i++) {
            buffer.putInt(indices[i]);
            buffer.putDouble(values[i]);
        }
        return buffer.array();
    }

    private int searchForIndex(int i) {
        if (((cardinality) == 0) || (i > (indices[((cardinality) - 1)]))) {
            return cardinality;
        }
        int left = 0;
        int right = cardinality;
        while (left < right) {
            int p = (left + right) / 2;
            if ((indices[p]) > i) {
                right = p;
            }else
                if ((indices[p]) < i) {
                    left = p + 1;
                }else {
                    return p;
                }

        } 
        return left;
    }

    private void insert(int k, int i, double value) {
        if (value == 0.0) {
            return;
        }
        if ((values.length) < ((cardinality) + 1)) {
            growUp();
        }
        if (((cardinality) - k) > 0) {
            java.lang.System.arraycopy(values, k, values, (k + 1), ((cardinality) - k));
            java.lang.System.arraycopy(indices, k, indices, (k + 1), ((cardinality) - k));
        }
        values[k] = value;
        indices[k] = i;
        (cardinality)++;
    }

    private void remove(int k) {
        (cardinality)--;
        if (((cardinality) - k) > 0) {
            java.lang.System.arraycopy(values, (k + 1), values, k, ((cardinality) - k));
            java.lang.System.arraycopy(indices, (k + 1), indices, k, ((cardinality) - k));
        }
    }

    private void growUp() {
        if ((values.length) == (length)) {
            throw new java.lang.IllegalStateException("This vector can't grow up.");
        }
        int capacity = java.lang.Math.min(length, ((((cardinality) * 3) / 2) + 1));
        double[] $values = new double[capacity];
        int[] $indices = new int[capacity];
        java.lang.System.arraycopy(values, 0, $values, 0, cardinality);
        java.lang.System.arraycopy(indices, 0, $indices, 0, cardinality);
        values = $values;
        indices = $indices;
    }

    private int align(int length, int capacity) {
        if (capacity < 0) {
            fail((("Cardinality should be positive: " + capacity) + "."));
        }
        if (capacity > length) {
            fail((("Cardinality should be less then or equal to capacity: " + capacity) + "."));
        }
        return java.lang.Math.min(length, (((capacity / (org.la4j.vector.sparse.CompressedVector.MINIMUM_SIZE)) + 1) * (org.la4j.vector.sparse.CompressedVector.MINIMUM_SIZE)));
    }

    @java.lang.Override
    public org.la4j.iterator.VectorIterator nonZeroIterator() {
        return new org.la4j.iterator.VectorIterator(length) {
            private boolean currentIsRemoved = false;

            private int k = -1;

            private int removedIndex = -1;

            @java.lang.Override
            public int index() {
                return currentIsRemoved ? removedIndex : indices[k];
            }

            @java.lang.Override
            public double get() {
                return currentIsRemoved ? 0.0 : values[k];
            }

            @java.lang.Override
            public void set(double value) {
                if ((value == 0.0) && (!(currentIsRemoved))) {
                    currentIsRemoved = true;
                    removedIndex = indices[k];
                    org.la4j.vector.sparse.CompressedVector.this.remove(((k)--));
                }else
                    if ((value != 0.0) && (!(currentIsRemoved))) {
                        values[k] = value;
                    }else {
                        currentIsRemoved = false;
                        org.la4j.vector.sparse.CompressedVector.this.insert((++(k)), removedIndex, value);
                    }

            }

            @java.lang.Override
            public boolean hasNext() {
                return ((k) + 1) < (cardinality);
            }

            @java.lang.Override
            public java.lang.Double next() {
                if (!(hasNext())) {
                    throw new java.util.NoSuchElementException();
                }
                currentIsRemoved = false;
                return values[(++(k))];
            }
        };
    }

    @java.lang.Override
    public org.la4j.iterator.VectorIterator iterator() {
        return new org.la4j.iterator.VectorIterator(length) {
            private int k = 0;

            private int i = -1;

            private boolean currentNonZero = false;

            @java.lang.Override
            public int index() {
                return i;
            }

            @java.lang.Override
            public double get() {
                return currentNonZero ? values[k] : 0.0;
            }

            @java.lang.Override
            public void set(double value) {
                if (currentNonZero) {
                    if (value == 0.0) {
                        org.la4j.vector.sparse.CompressedVector.this.remove(k);
                        currentNonZero = false;
                    }else {
                        values[k] = value;
                    }
                }else {
                    org.la4j.vector.sparse.CompressedVector.this.insert(k, i, value);
                    currentNonZero = true;
                }
            }

            @java.lang.Override
            public boolean hasNext() {
                return ((i) + 1) < (length);
            }

            @java.lang.Override
            public java.lang.Double next() {
                boolean spoonDefaultValue = false;
                try {
                    spoonDefaultValue = !(hasNext());
                } catch (java.lang.Exception __NopolProcessorException) {
                }
                boolean runtimeAngelicValue = fr.inria.lille.repair.nopol.synth.AngelicExecution.angelicValue(spoonDefaultValue);
                if (fr.inria.lille.commons.trace.RuntimeValues.instance(8).isEnabled()) {
                    fr.inria.lille.commons.trace.RuntimeValues.instance(8).collectionStarts();
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(8).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.k",org.la4j.vector.sparse.CompressedVector.2.this.k);} catch (Exception ex1) {ex1.printStackTrace();};
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(8).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero",org.la4j.vector.sparse.CompressedVector.2.this.currentNonZero);} catch (Exception ex1) {ex1.printStackTrace();};
                    try{fr.inria.lille.commons.trace.RuntimeValues.instance(8).collectInput("org.la4j.vector.sparse.CompressedVector.2.this.i",org.la4j.vector.sparse.CompressedVector.2.this.i);} catch (Exception ex1) {ex1.printStackTrace();};
                    fr.inria.lille.commons.trace.RuntimeValues.instance(8).collectOutput(runtimeAngelicValue);
                    fr.inria.lille.commons.trace.RuntimeValues.instance(8).collectionEnds();
                }
                if (runtimeAngelicValue) {
                    throw new java.util.NoSuchElementException();
                }
                if (currentNonZero) {
                    (k)++;
                }
                (i)++;
                currentNonZero = ((k) < (cardinality)) && ((indices[k]) == (i));
                return get();
            }
        };
    }
}
18:09:14.268 [pool-2-thread-1] ERROR fr.inria.lille.repair.nopol.NoPol - Error ExecutionException java.util.concurrent.ExecutionException: xxl.java.compiler.DynamicCompilationException: Aborting: dynamic compilation failed
18:09:14.268 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - statement #27
18:09:14.269 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - Analysing SourceLocation org.la4j.vector.sparse.CompressedVector$2:610 which is executed by 5 tests
1164465221
18:09:14.386 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - statement #28
18:09:14.387 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - Analysing SourceLocation org.la4j.vector.sparse.CompressedVector$2:590 which is executed by 5 tests
1164465221
18:09:14.515 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - statement #29
18:09:14.516 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - Analysing SourceLocation org.la4j.vector.sparse.CompressedVector:222 which is executed by 6 tests
1164465221
18:09:14.605 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - statement #30
18:09:14.606 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - Analysing SourceLocation org.la4j.vector.sparse.CompressedVector:221 which is executed by 6 tests
1164465221
18:09:14.694 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - looking with class fr.inria.lille.repair.nopol.spoon.smt.ConditionalAdder
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
18:09:14.777 [pool-30-thread-1] INFO  xxl.java.junit.TestCasesListener - Tests run finished (73 ms)
<> Total tests run: 143
<> Ignored tests: 0
<> Failed tests: 2
~ testFromMap_unordered(org.la4j.vector.sparse.CompressedVectorTest)
[expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>]
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
~ testFromMap_unordered(org.la4j.vector.dense.BasicVectorTest)
[expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>]
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)

java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 2.000 0.000 0.000 0.000>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
18:09:15.659 [pool-31-thread-1] INFO  f.i.l.c.t.SpecificationTestCasesListener - Tests run finished (28 ms)
<> Total tests run: 1
<> Ignored tests: 0
<> Failed tests: 1
~ testFromMap_unordered(org.la4j.vector.sparse.CompressedVectorTest)
[expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 2.000 0.000 0.000 0.000>]
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 2.000 0.000 0.000 0.000>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)

java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 2.000 0.000 0.000 0.000>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
18:09:15.663 [pool-32-thread-1] INFO  f.i.l.c.t.SpecificationTestCasesListener - Tests run finished (1 ms)
<> Total tests run: 1
<> Ignored tests: 0
<> Failed tests: 1
~ testFromMap_unordered(org.la4j.vector.dense.BasicVectorTest)
[expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 2.000 0.000 0.000 0.000>]
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 2.000 0.000 0.000 0.000>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)

java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
18:09:15.667 [pool-33-thread-1] INFO  f.i.l.c.t.SpecificationTestCasesListener - Tests run finished (1 ms)
<> Total tests run: 1
<> Ignored tests: 0
<> Failed tests: 1
~ testFromMap_unordered(org.la4j.vector.sparse.CompressedVectorTest)
[expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>]
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)

java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
18:09:15.670 [pool-34-thread-1] INFO  f.i.l.c.t.SpecificationTestCasesListener - Tests run finished (1 ms)
<> Total tests run: 1
<> Ignored tests: 0
<> Failed tests: 1
~ testFromMap_unordered(org.la4j.vector.dense.BasicVectorTest)
[expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>]
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)

18:09:15.671 [pool-29-thread-1] DEBUG tests.output - Failing tests with false: 
[testFromMap_unordered(org.la4j.vector.sparse.CompressedVectorTest): expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 2.000 0.000 0.000 0.000>, testFromMap_unordered(org.la4j.vector.dense.BasicVectorTest): expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 2.000 0.000 0.000 0.000>]
18:09:15.671 [pool-29-thread-1] DEBUG tests.output - Failing tests with true: 
[testFromMap_unordered(org.la4j.vector.sparse.CompressedVectorTest): expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>, testFromMap_unordered(org.la4j.vector.dense.BasicVectorTest): expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>]
18:09:15.671 [pool-29-thread-1] INFO  f.i.l.r.n.synth.SMTNopolSynthesizer - Not enough specifications: 0. A trivial patch is "true" or "false", please write new tests specifying SourceLocation org.la4j.vector.sparse.CompressedVector:221.
18:09:15.671 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - statement #31
18:09:15.672 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - Analysing SourceLocation org.la4j.vector.sparse.CompressedVector:220 which is executed by 6 tests
1164465221
18:09:15.762 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - looking with class fr.inria.lille.repair.nopol.spoon.smt.ConditionalAdder
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
18:09:15.842 [pool-36-thread-1] INFO  xxl.java.junit.TestCasesListener - Tests run finished (70 ms)
<> Total tests run: 143
<> Ignored tests: 0
<> Failed tests: 2
~ testFromMap_unordered(org.la4j.vector.sparse.CompressedVectorTest)
[expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>]
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
~ testFromMap_unordered(org.la4j.vector.dense.BasicVectorTest)
[expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>]
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)

java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 0.000 0.000>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
18:09:16.721 [pool-37-thread-1] INFO  f.i.l.c.t.SpecificationTestCasesListener - Tests run finished (27 ms)
<> Total tests run: 1
<> Ignored tests: 0
<> Failed tests: 1
~ testFromMap_unordered(org.la4j.vector.sparse.CompressedVectorTest)
[expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 0.000 0.000>]
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 0.000 0.000>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)

java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 0.000 0.000>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
18:09:16.724 [pool-38-thread-1] INFO  f.i.l.c.t.SpecificationTestCasesListener - Tests run finished (1 ms)
<> Total tests run: 1
<> Ignored tests: 0
<> Failed tests: 1
~ testFromMap_unordered(org.la4j.vector.dense.BasicVectorTest)
[expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 0.000 0.000>]
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 0.000 0.000>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)

java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
18:09:16.727 [pool-39-thread-1] INFO  f.i.l.c.t.SpecificationTestCasesListener - Tests run finished (1 ms)
<> Total tests run: 1
<> Ignored tests: 0
<> Failed tests: 1
~ testFromMap_unordered(org.la4j.vector.sparse.CompressedVectorTest)
[expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>]
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)

java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
18:09:16.729 [pool-40-thread-1] INFO  f.i.l.c.t.SpecificationTestCasesListener - Tests run finished (1 ms)
<> Total tests run: 1
<> Ignored tests: 0
<> Failed tests: 1
~ testFromMap_unordered(org.la4j.vector.dense.BasicVectorTest)
[expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>]
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)

18:09:16.732 [pool-35-thread-1] DEBUG tests.output - Failing tests with false: 
[testFromMap_unordered(org.la4j.vector.sparse.CompressedVectorTest): expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 0.000 0.000>, testFromMap_unordered(org.la4j.vector.dense.BasicVectorTest): expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 0.000 0.000>]
18:09:16.732 [pool-35-thread-1] DEBUG tests.output - Failing tests with true: 
[testFromMap_unordered(org.la4j.vector.sparse.CompressedVectorTest): expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>, testFromMap_unordered(org.la4j.vector.dense.BasicVectorTest): expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>]
18:09:16.732 [pool-35-thread-1] INFO  f.i.l.r.n.synth.SMTNopolSynthesizer - Not enough specifications: 0. A trivial patch is "true" or "false", please write new tests specifying SourceLocation org.la4j.vector.sparse.CompressedVector:220.
18:09:16.732 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - statement #32
18:09:16.733 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - Analysing SourceLocation org.la4j.vector.sparse.CompressedVector:219 which is executed by 6 tests
1164465221
18:09:16.818 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - looking with class fr.inria.lille.repair.nopol.spoon.smt.ConditionalAdder
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
18:09:16.895 [pool-42-thread-1] INFO  xxl.java.junit.TestCasesListener - Tests run finished (68 ms)
<> Total tests run: 143
<> Ignored tests: 0
<> Failed tests: 2
~ testFromMap_unordered(org.la4j.vector.sparse.CompressedVectorTest)
[expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>]
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
~ testFromMap_unordered(org.la4j.vector.dense.BasicVectorTest)
[expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>]
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)

java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<1.000 0.000 0.000 0.000 0.000 0.000 0.000>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
18:09:17.719 [pool-43-thread-1] INFO  f.i.l.c.t.SpecificationTestCasesListener - Tests run finished (31 ms)
<> Total tests run: 1
<> Ignored tests: 0
<> Failed tests: 1
~ testFromMap_unordered(org.la4j.vector.sparse.CompressedVectorTest)
[expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<1.000 0.000 0.000 0.000 0.000 0.000 0.000>]
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<1.000 0.000 0.000 0.000 0.000 0.000 0.000>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)

java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<1.000 0.000 0.000 0.000 0.000 0.000 0.000>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
18:09:17.722 [pool-44-thread-1] INFO  f.i.l.c.t.SpecificationTestCasesListener - Tests run finished (1 ms)
<> Total tests run: 1
<> Ignored tests: 0
<> Failed tests: 1
~ testFromMap_unordered(org.la4j.vector.dense.BasicVectorTest)
[expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<1.000 0.000 0.000 0.000 0.000 0.000 0.000>]
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<1.000 0.000 0.000 0.000 0.000 0.000 0.000>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)

java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
18:09:17.733 [pool-45-thread-1] INFO  f.i.l.c.t.SpecificationTestCasesListener - Tests run finished (1 ms)
<> Total tests run: 1
<> Ignored tests: 0
<> Failed tests: 1
~ testFromMap_unordered(org.la4j.vector.sparse.CompressedVectorTest)
[expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>]
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)

java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
18:09:17.735 [pool-46-thread-1] INFO  f.i.l.c.t.SpecificationTestCasesListener - Tests run finished (1 ms)
<> Total tests run: 1
<> Ignored tests: 0
<> Failed tests: 1
~ testFromMap_unordered(org.la4j.vector.dense.BasicVectorTest)
[expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>]
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)

18:09:17.736 [pool-41-thread-1] DEBUG tests.output - Failing tests with false: 
[testFromMap_unordered(org.la4j.vector.sparse.CompressedVectorTest): expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<1.000 0.000 0.000 0.000 0.000 0.000 0.000>, testFromMap_unordered(org.la4j.vector.dense.BasicVectorTest): expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<1.000 0.000 0.000 0.000 0.000 0.000 0.000>]
18:09:17.736 [pool-41-thread-1] DEBUG tests.output - Failing tests with true: 
[testFromMap_unordered(org.la4j.vector.sparse.CompressedVectorTest): expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>, testFromMap_unordered(org.la4j.vector.dense.BasicVectorTest): expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>]
18:09:17.736 [pool-41-thread-1] INFO  f.i.l.r.n.synth.SMTNopolSynthesizer - Not enough specifications: 0. A trivial patch is "true" or "false", please write new tests specifying SourceLocation org.la4j.vector.sparse.CompressedVector:219.
18:09:17.736 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - statement #33
18:09:17.736 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - Analysing SourceLocation org.la4j.vector.sparse.CompressedVector:216 which is executed by 6 tests
1164465221
18:09:17.823 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - looking with class fr.inria.lille.repair.nopol.spoon.smt.ConditionalAdder
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
18:09:17.900 [pool-48-thread-1] INFO  xxl.java.junit.TestCasesListener - Tests run finished (66 ms)
<> Total tests run: 143
<> Ignored tests: 0
<> Failed tests: 2
~ testFromMap_unordered(org.la4j.vector.sparse.CompressedVectorTest)
[expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>]
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
~ testFromMap_unordered(org.la4j.vector.dense.BasicVectorTest)
[expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>]
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)

java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
18:09:18.723 [pool-49-thread-1] INFO  f.i.l.c.t.SpecificationTestCasesListener - Tests run finished (35 ms)
<> Total tests run: 1
<> Ignored tests: 0
<> Failed tests: 1
~ testFromMap_unordered(org.la4j.vector.sparse.CompressedVectorTest)
[expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>]
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)

java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
18:09:18.727 [pool-50-thread-1] INFO  f.i.l.c.t.SpecificationTestCasesListener - Tests run finished (1 ms)
<> Total tests run: 1
<> Ignored tests: 0
<> Failed tests: 1
~ testFromMap_unordered(org.la4j.vector.dense.BasicVectorTest)
[expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>]
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)

java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
18:09:18.729 [pool-51-thread-1] INFO  f.i.l.c.t.SpecificationTestCasesListener - Tests run finished (1 ms)
<> Total tests run: 1
<> Ignored tests: 0
<> Failed tests: 1
~ testFromMap_unordered(org.la4j.vector.sparse.CompressedVectorTest)
[expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>]
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)

java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
18:09:18.731 [pool-52-thread-1] INFO  f.i.l.c.t.SpecificationTestCasesListener - Tests run finished (1 ms)
<> Total tests run: 1
<> Ignored tests: 0
<> Failed tests: 1
~ testFromMap_unordered(org.la4j.vector.dense.BasicVectorTest)
[expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>]
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)

18:09:18.732 [pool-47-thread-1] DEBUG tests.output - Failing tests with false: 
[testFromMap_unordered(org.la4j.vector.sparse.CompressedVectorTest): expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>, testFromMap_unordered(org.la4j.vector.dense.BasicVectorTest): expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>]
18:09:18.732 [pool-47-thread-1] DEBUG tests.output - Failing tests with true: 
[testFromMap_unordered(org.la4j.vector.sparse.CompressedVectorTest): expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>, testFromMap_unordered(org.la4j.vector.dense.BasicVectorTest): expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>]
18:09:18.733 [pool-47-thread-1] INFO  f.i.l.r.n.synth.SMTNopolSynthesizer - Not enough specifications: 0. A trivial patch is "true" or "false", please write new tests specifying SourceLocation org.la4j.vector.sparse.CompressedVector:216.
18:09:18.733 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - looking with class fr.inria.lille.repair.nopol.spoon.smt.ConditionalReplacer
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
18:09:18.818 [pool-54-thread-1] INFO  xxl.java.junit.TestCasesListener - Tests run finished (75 ms)
<> Total tests run: 143
<> Ignored tests: 0
<> Failed tests: 2
~ testFromMap_unordered(org.la4j.vector.sparse.CompressedVectorTest)
[expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>]
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
~ testFromMap_unordered(org.la4j.vector.dense.BasicVectorTest)
[expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>]
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)

java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
18:09:19.612 [pool-55-thread-1] INFO  f.i.l.c.t.SpecificationTestCasesListener - Tests run finished (31 ms)
<> Total tests run: 1
<> Ignored tests: 0
<> Failed tests: 1
~ testFromMap_unordered(org.la4j.vector.sparse.CompressedVectorTest)
[expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>]
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)

java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
18:09:19.616 [pool-56-thread-1] INFO  f.i.l.c.t.SpecificationTestCasesListener - Tests run finished (1 ms)
<> Total tests run: 1
<> Ignored tests: 0
<> Failed tests: 1
~ testFromMap_unordered(org.la4j.vector.dense.BasicVectorTest)
[expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>]
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)

java.lang.IllegalArgumentException: Check your map: Index must be 0..n-1
    at org.la4j.vector.sparse.CompressedVector.fromMap(CompressedVector.java:126)
    at org.la4j.vector.SparseVector.fromMap(SparseVector.java:141)
    at org.la4j.Vector.fromMap(Vector.java:202)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
18:09:19.618 [pool-57-thread-1] INFO  f.i.l.c.t.SpecificationTestCasesListener - Tests run finished (1 ms)
<> Total tests run: 1
<> Ignored tests: 0
<> Failed tests: 1
~ testFromMap_unordered(org.la4j.vector.sparse.CompressedVectorTest)
[Check your map: Index must be 0..n-1]
java.lang.IllegalArgumentException: Check your map: Index must be 0..n-1    at org.la4j.vector.sparse.CompressedVector.fromMap(CompressedVector.java:126)
    at org.la4j.vector.SparseVector.fromMap(SparseVector.java:141)
    at org.la4j.Vector.fromMap(Vector.java:202)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)

java.lang.IllegalArgumentException: Check your map: Index must be 0..n-1
    at org.la4j.vector.sparse.CompressedVector.fromMap(CompressedVector.java:126)
    at org.la4j.vector.SparseVector.fromMap(SparseVector.java:141)
    at org.la4j.Vector.fromMap(Vector.java:202)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
18:09:19.619 [pool-58-thread-1] INFO  f.i.l.c.t.SpecificationTestCasesListener - Tests run finished (0 ms)
<> Total tests run: 1
<> Ignored tests: 0
<> Failed tests: 1
~ testFromMap_unordered(org.la4j.vector.dense.BasicVectorTest)
[Check your map: Index must be 0..n-1]
java.lang.IllegalArgumentException: Check your map: Index must be 0..n-1    at org.la4j.vector.sparse.CompressedVector.fromMap(CompressedVector.java:126)
    at org.la4j.vector.SparseVector.fromMap(SparseVector.java:141)
    at org.la4j.Vector.fromMap(Vector.java:202)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)

18:09:19.620 [pool-53-thread-1] DEBUG tests.output - Failing tests with false: 
[testFromMap_unordered(org.la4j.vector.sparse.CompressedVectorTest): expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>, testFromMap_unordered(org.la4j.vector.dense.BasicVectorTest): expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>]
18:09:19.620 [pool-53-thread-1] DEBUG tests.output - Failing tests with true: 
[testFromMap_unordered(org.la4j.vector.sparse.CompressedVectorTest): Check your map: Index must be 0..n-1, testFromMap_unordered(org.la4j.vector.dense.BasicVectorTest): Check your map: Index must be 0..n-1]
18:09:19.620 [pool-53-thread-1] INFO  f.i.l.r.n.synth.SMTNopolSynthesizer - Not enough specifications: 0. A trivial patch is "true" or "false", please write new tests specifying SourceLocation org.la4j.vector.sparse.CompressedVector:216.
18:09:19.620 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - statement #34
18:09:19.620 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - Analysing SourceLocation org.la4j.vector.sparse.CompressedVector:215 which is executed by 6 tests
1164465221
18:09:19.705 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - statement #35
18:09:19.706 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - Analysing SourceLocation org.la4j.vector.sparse.CompressedVector:223 which is executed by 8 tests
1164465221
18:09:19.789 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - statement #36
18:09:19.789 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - Analysing SourceLocation org.la4j.vector.sparse.CompressedVector:214 which is executed by 10 tests
1164465221
18:09:19.877 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - looking with class fr.inria.lille.repair.nopol.spoon.smt.ConditionalAdder
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
18:09:19.955 [pool-60-thread-1] INFO  xxl.java.junit.TestCasesListener - Tests run finished (68 ms)
<> Total tests run: 143
<> Ignored tests: 0
<> Failed tests: 2
~ testFromMap_unordered(org.la4j.vector.sparse.CompressedVectorTest)
[expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>]
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
~ testFromMap_unordered(org.la4j.vector.dense.BasicVectorTest)
[expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>]
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)

java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 0.000 0.000>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
18:09:20.750 [pool-61-thread-1] INFO  f.i.l.c.t.SpecificationTestCasesListener - Tests run finished (28 ms)
<> Total tests run: 1
<> Ignored tests: 0
<> Failed tests: 1
~ testFromMap_unordered(org.la4j.vector.sparse.CompressedVectorTest)
[expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 0.000 0.000>]
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 0.000 0.000>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)

java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 0.000 0.000>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
18:09:20.752 [pool-62-thread-1] INFO  f.i.l.c.t.SpecificationTestCasesListener - Tests run finished (0 ms)
<> Total tests run: 1
<> Ignored tests: 0
<> Failed tests: 1
~ testFromMap_unordered(org.la4j.vector.dense.BasicVectorTest)
[expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 0.000 0.000>]
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 0.000 0.000>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)

java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
18:09:20.754 [pool-63-thread-1] INFO  f.i.l.c.t.SpecificationTestCasesListener - Tests run finished (0 ms)
<> Total tests run: 1
<> Ignored tests: 0
<> Failed tests: 1
~ testFromMap_unordered(org.la4j.vector.sparse.CompressedVectorTest)
[expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>]
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)

java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
18:09:20.756 [pool-64-thread-1] INFO  f.i.l.c.t.SpecificationTestCasesListener - Tests run finished (1 ms)
<> Total tests run: 1
<> Ignored tests: 0
<> Failed tests: 1
~ testFromMap_unordered(org.la4j.vector.dense.BasicVectorTest)
[expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>]
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)

18:09:20.757 [pool-59-thread-1] DEBUG tests.output - Failing tests with false: 
[testFromMap_unordered(org.la4j.vector.sparse.CompressedVectorTest): expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 0.000 0.000>, testFromMap_unordered(org.la4j.vector.dense.BasicVectorTest): expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 0.000 0.000>]
18:09:20.757 [pool-59-thread-1] DEBUG tests.output - Failing tests with true: 
[testFromMap_unordered(org.la4j.vector.sparse.CompressedVectorTest): expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>, testFromMap_unordered(org.la4j.vector.dense.BasicVectorTest): expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>]
18:09:20.757 [pool-59-thread-1] INFO  f.i.l.r.n.synth.SMTNopolSynthesizer - Not enough specifications: 0. A trivial patch is "true" or "false", please write new tests specifying SourceLocation org.la4j.vector.sparse.CompressedVector:214.
18:09:20.757 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - statement #37
18:09:20.757 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - Analysing SourceLocation org.la4j.vector.sparse.CompressedVector:213 which is executed by 10 tests
1164465221
18:09:20.842 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - statement #38
18:09:20.843 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - Analysing SourceLocation org.la4j.vector.sparse.CompressedVector:212 which is executed by 10 tests
1164465221
18:09:20.925 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - statement #39
18:09:20.925 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - Analysing SourceLocation org.la4j.vector.sparse.CompressedVector:211 which is executed by 10 tests
1164465221
18:09:21.006 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - statement #40
18:09:21.007 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - Analysing SourceLocation org.la4j.vector.sparse.CompressedVector:210 which is executed by 12 tests
1164465221
18:09:21.087 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - statement #41
18:09:21.088 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - Analysing SourceLocation org.la4j.Vector:202 which is executed by 12 tests
-1736520348
18:09:21.200 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - statement #42
18:09:21.200 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - Analysing SourceLocation org.la4j.vector.SparseVector:141 which is executed by 12 tests
1517253540
18:09:21.273 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - statement #43
18:09:21.273 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - Analysing SourceLocation org.la4j.Vector:811 which is executed by 16 tests
-1736520348
18:09:21.361 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - statement #44
18:09:21.361 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - Analysing SourceLocation org.la4j.Vector:865 which is executed by 92 tests
-1736520348
18:09:21.452 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - statement #45
18:09:21.452 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - Analysing SourceLocation org.la4j.vector.sparse.CompressedVector:451 which is executed by 99 tests
1164465221
18:09:21.538 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - looking with class fr.inria.lille.repair.nopol.spoon.smt.ConditionalAdder
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
18:09:21.623 [pool-66-thread-1] INFO  xxl.java.junit.TestCasesListener - Tests run finished (75 ms)
<> Total tests run: 143
<> Ignored tests: 0
<> Failed tests: 2
~ testFromMap_unordered(org.la4j.vector.sparse.CompressedVectorTest)
[expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>]
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
~ testFromMap_unordered(org.la4j.vector.dense.BasicVectorTest)
[expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>]
java.lang.AssertionError: expected:<1.000 0.000 0.000 2.000 0.000 1.000 0.000> but was:<0.000 0.000 0.000 0.000 0.000 1.000 0.000>    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotEquals(Assert.java:743)
    at org.junit.Assert.assertEquals(Assert.java:118)
    at org.junit.Assert.assertEquals(Assert.java:144)
    at org.la4j.vector.VectorTest.testFromMap_unordered(VectorTest.java:735)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)

java.lang.OutOfMemoryError: GC overhead limit exceeded
    at fr.inria.lille.commons.trace.RuntimeValues.collectionEnds(RuntimeValues.java:126)
    at org.la4j.vector.sparse.CompressedVector.searchForIndex(CompressedVector.java:298)
    at org.la4j.vector.sparse.CompressedVector.getOrElse(CompressedVector.java:114)
    at org.la4j.vector.SparseVector.get(SparseVector.java:166)
    at org.la4j.Vector.equals(Vector.java:808)
    at org.la4j.Vector.equals(Vector.java:865)
18:14:18.379 [pool-67-thread-1] INFO  f.i.l.c.t.SpecificationTestCasesListener - Tests run finished (295992 ms)
<> Total tests run: 1
<> Ignored tests: 0
<> Failed tests: 1
~ testFromMap_unordered(org.la4j.vector.sparse.CompressedVectorTest)
[GC overhead limit exceeded]
java.lang.OutOfMemoryError: GC overhead limit exceeded    at fr.inria.lille.commons.trace.RuntimeValues.collectionEnds(RuntimeValues.java:126)
    at org.la4j.vector.sparse.CompressedVector.searchForIndex(CompressedVector.java:298)
    at org.la4j.vector.sparse.CompressedVector.getOrElse(CompressedVector.java:114)
    at org.la4j.vector.SparseVector.get(SparseVector.java:166)
    at org.la4j.Vector.equals(Vector.java:808)
    at org.la4j.Vector.equals(Vector.java:865)

18:14:18.379 [pool-65-thread-1] DEBUG xxl.java.junit.TestSuiteExecution - Timeout after 200 seconds. Infinite loop?
18:14:18.380 [pool-2-thread-1] ERROR fr.inria.lille.repair.nopol.NoPol - Error ExecutionException java.util.concurrent.ExecutionException: java.lang.RuntimeException: java.util.concurrent.TimeoutException
18:14:18.380 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - statement #46
18:14:18.380 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - Analysing SourceLocation org.la4j.vector.sparse.CompressedVector:457 which is executed by 112 tests
1164465221
18:14:55.403 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - statement #47
18:14:55.403 [pool-2-thread-1] DEBUG fr.inria.lille.repair.nopol.NoPol - Analysing SourceLocation org.la4j.Vector:810 which is executed by 123 tests
java.util.concurrent.ExecutionException: java.lang.OutOfMemoryError: GC overhead limit exceeded
	at java.util.concurrent.FutureTask.report(FutureTask.java:122)
	at java.util.concurrent.FutureTask.get(FutureTask.java:206)
	at fr.inria.lille.repair.Main.main(Main.java:106)
Caused by: java.lang.OutOfMemoryError: GC overhead limit exceeded
	at java.util.zip.ZipCoder.toString(ZipCoder.java:59)
	at java.util.zip.ZipFile.getZipEntry(ZipFile.java:583)
	at java.util.zip.ZipFile.access$900(ZipFile.java:60)
	at java.util.zip.ZipFile$ZipEntryIterator.next(ZipFile.java:539)
	at java.util.zip.ZipFile$ZipEntryIterator.nextElement(ZipFile.java:514)
	at java.util.zip.ZipFile$ZipEntryIterator.nextElement(ZipFile.java:495)
	at org.eclipse.jdt.internal.compiler.batch.ClasspathJar.getModulesDeclaringPackage(ClasspathJar.java:234)
	at org.eclipse.jdt.internal.compiler.batch.ClasspathLocation.isPackage(ClasspathLocation.java:177)
	at org.eclipse.jdt.internal.compiler.batch.ClasspathJar.findClass(ClasspathJar.java:111)
	at org.eclipse.jdt.internal.compiler.batch.FileSystem.internalFindClass(FileSystem.java:443)
	at org.eclipse.jdt.internal.compiler.batch.FileSystem.findClass(FileSystem.java:385)
	at org.eclipse.jdt.internal.compiler.batch.FileSystem.findType(FileSystem.java:529)
	at org.eclipse.jdt.internal.compiler.env.IModuleAwareNameEnvironment.findType(IModuleAwareNameEnvironment.java:94)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createPackage(LookupEnvironment.java:1094)
	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.buildTypeBindings(CompilationUnitScope.java:129)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.buildTypeBindings(LookupEnvironment.java:457)
	at org.eclipse.jdt.internal.compiler.Compiler.internalBeginToCompile(Compiler.java:838)
	at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:387)
	at spoon.support.compiler.jdt.TreeBuilderCompiler.buildUnits(TreeBuilderCompiler.java:73)
	at spoon.support.compiler.jdt.JDTBatchCompiler.getUnits(JDTBatchCompiler.java:266)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnits(JDTBasedSpoonCompiler.java:444)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnitsAndModel(JDTBasedSpoonCompiler.java:388)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildSources(JDTBasedSpoonCompiler.java:340)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:129)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:113)
	at fr.inria.lille.commons.spoon.util.SpoonModelLibrary.modelFor(SpoonModelLibrary.java:53)
	at fr.inria.lille.commons.spoon.SpoonedFile.<init>(SpoonedFile.java:61)
	at fr.inria.lille.commons.spoon.SpoonedClass.<init>(SpoonedClass.java:14)
	at fr.inria.lille.commons.spoon.SpoonedProject.forked(SpoonedProject.java:47)
	at fr.inria.lille.repair.nopol.NoPol.runOnStatement(NoPol.java:222)
	at fr.inria.lille.repair.nopol.NoPol.solveWithMultipleBuild(NoPol.java:213)
	at fr.inria.lille.repair.nopol.NoPol.build(NoPol.java:154)

Usage: java -jar nopol.jar
                          [(-m|--mode) <repair|ranking>] (-e|--type) <condition|precondition|pre_then_cond|loop|arithmetic> [(-o|--oracle) <angelic|symbolic>] [(-y|--synthesis) <smt|dynamoth>] [(-l|--solver) <z3|cvc4>] [(-p|--solver-path) <solverPath>] (-s|--source) source1:source2:...:sourceN  (-c|--classpath) <classpath> [(-t|--test) test1:test2:...:testN ] [--complianceLevel <complianceLevel>] [--maxTime <maxTime>] [--maxTimeType <maxTimeType>] [(-z|--flocal) < cocospoon|dumb|gzoltar>] [--output <outputFolder>] [--json[:<outputJson>]]

  [(-m|--mode) <repair|ranking>]
        Define the mode of execution. (default: repair)

  (-e|--type) <condition|precondition|pre_then_cond|loop|arithmetic>
        The repair type (example fixing only conditions, or adding
        precondition). REQUIRED OPTION (default: condition)

  [(-o|--oracle) <angelic|symbolic>]
        Define the oracle (only used with repair mode). (default: angelic)

  [(-y|--synthesis) <smt|dynamoth>]
        Define the patch synthesis. (default: smt)

  [(-l|--solver) <z3|cvc4>]
        Define the solver (only used with smt synthesis). (default: z3)

  [(-p|--solver-path) <solverPath>]
        Define the solver binary path (only used with smt synthesis).

  (-s|--source) source1:source2:...:sourceN 
        Define the path to the source code of the project.

  (-c|--classpath) <classpath>
        Define the classpath of the project.

  [(-t|--test) test1:test2:...:testN ]
        Define the tests of the project (both failing and passing),
        fully-qualified, separated with ':' (even if the classpath contains
        other tests, only those are considered.

  [--complianceLevel <complianceLevel>]
        The compliance level of the project. (default: 7)

  [--maxTime <maxTime>]
        The maximum time execution in minute for the whole execution of
        Nopol.(default: 10)

  [--maxTimeType <maxTimeType>]
        The maximum time execution in minute for one type of patch. (default: 5)

  [(-z|--flocal) < cocospoon|dumb|gzoltar>]
        Define the fault localizer to be used. (default: gzoltar)

  [--output <outputFolder>]
        Define the location where the patches will be saved. (default: .)

  [--json[:<outputJson>]]
        Output a json file in the current working directory.

Command exited with non-zero status 255
2840.72user 12.30system 7:14.88elapsed 656%CPU (0avgtext+0avgdata 4532008maxresident)k
39352inputs+6736outputs (3major+1281364minor)pagefaults 0swaps


Node: granduc-9.luxembourg.grid5000.fr



Date: Mon Nov 12 18:15:30 EST 2018

